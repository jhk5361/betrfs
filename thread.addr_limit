linux-4.15.18+/drivers/xen/gntdev.c:270:	set_pte_at(current->mm, addr, pte, pte_mkspecial(*pte));
linux-4.15.18+/drivers/xen/gntdev.c:656:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/xen/gntdev.c:657:	vma = find_vma(current->mm, op.vaddr);
linux-4.15.18+/drivers/xen/gntdev.c:670:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/xen/evtchn.c:651:	u->name = kasprintf(GFP_KERNEL, "evtchn:%s", current->comm);
linux-4.15.18+/drivers/xen/xenbus/xenbus_xs.c:804:	if (current->pid != xenwatch_pid)
linux-4.15.18+/drivers/xen/xenbus/xenbus_xs.c:817:	if (current->pid != xenwatch_pid)
linux-4.15.18+/drivers/xen/xenbus/xenbus_xs.c:863:	xenwatch_pid = current->pid;
linux-4.15.18+/drivers/xen/privcmd.c:255:	struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/xen/privcmd.c:449:	struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/xen/grant-table.c:840:		pr_err("%s: %s eagain grant\n", func, current->comm);
linux-4.15.18+/drivers/tty/serial/8250/8250_of.c:85:	/* If current-speed was set, then try not to change it. */
linux-4.15.18+/drivers/tty/serial/8250/8250_of.c:86:	if (of_property_read_u32(np, "current-speed", &spd) == 0)
linux-4.15.18+/drivers/tty/serial/8250/8250_aspeed_vuart.c:233:	/* If current-speed was set, then try not to change it. */
linux-4.15.18+/drivers/tty/serial/8250/8250_aspeed_vuart.c:234:	if (of_property_read_u32(np, "current-speed", &prop) == 0)
linux-4.15.18+/drivers/tty/serial/earlycon.c:283:	val = of_get_flat_dt_prop(node, "current-speed", NULL);
linux-4.15.18+/drivers/tty/serial/arc_uart.c:605:	if (of_property_read_u32(np, "current-speed", &val)) {
linux-4.15.18+/drivers/tty/serial/arc_uart.c:606:		dev_err(&pdev->dev, "current-speed property NOT set\n");
linux-4.15.18+/drivers/tty/serial/amba-pl011.c:2692:		ret = of_property_read_u32(np, "current-speed", &baudrate);
linux-4.15.18+/drivers/tty/serial/crisv10.c:3586:	printk("[%d] rs_close ttyS%d, count = %d\n", current->pid,
linux-4.15.18+/drivers/tty/serial/crisv10.c:3858:        printk("[%d] rs_open %s, count = %d\n", current->pid, tty->name,
linux-4.15.18+/drivers/tty/serial/serial_core.c:970:				      current->comm,
linux-4.15.18+/drivers/tty/n_r3964.c:946:		tty, current->pid, tty->disc_data);
linux-4.15.18+/drivers/tty/n_tty.c:2070: *		 current->signal->tty check is safe
linux-4.15.18+/drivers/tty/mxser.c:1493:					current->comm, cmd);
linux-4.15.18+/drivers/tty/cyclades.c:1572:		current->pid, info->port.count);
linux-4.15.18+/drivers/tty/tty_audit.c:26:	buf = current->signal->tty_audit_buf;
linux-4.15.18+/drivers/tty/tty_audit.c:107: *	Only needs to be called if current->signal->tty_audit_buf != %NULL.
linux-4.15.18+/drivers/tty/tty_audit.c:110: *	current->signal.
linux-4.15.18+/drivers/tty/tty_audit.c:116:	buf = xchg(&current->signal->tty_audit_buf, ERR_PTR(-ESRCH));
linux-4.15.18+/drivers/tty/tty_audit.c:131:	sig->audit_tty = current->signal->audit_tty;
linux-4.15.18+/drivers/tty/tty_audit.c:158:	if (~current->signal->audit_tty & AUDIT_TTY_ENABLE)
linux-4.15.18+/drivers/tty/tty_audit.c:192:	if (cmpxchg(&current->signal->tty_audit_buf, NULL, buf) != NULL)
linux-4.15.18+/drivers/tty/tty_audit.c:209:	audit_tty = READ_ONCE(current->signal->audit_tty);
linux-4.15.18+/drivers/tty/vt/vt_ioctl.c:357:	if (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
linux-4.15.18+/drivers/tty/vt/vt_ioctl.c:1191:	if (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
linux-4.15.18+/drivers/tty/vt/vt.c:2681:	if (current->signal->tty != tty && !capable(CAP_SYS_ADMIN))
linux-4.15.18+/drivers/tty/tty_jobctrl.c:17:	return (sigismember(&current->blocked, sig) ||
linux-4.15.18+/drivers/tty/tty_jobctrl.c:18:		current->sighand->action[sig-1].sa.sa_handler == SIG_IGN);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:37:	if (current->signal->tty != tty)
linux-4.15.18+/drivers/tty/tty_jobctrl.c:108:	if (current->signal->tty) {
linux-4.15.18+/drivers/tty/tty_jobctrl.c:110:			  current->signal->tty->name);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:111:		tty_kref_put(current->signal->tty);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:113:	put_pid(current->signal->tty_old_pgrp);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:114:	current->signal->tty = tty_kref_get(tty);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:115:	current->signal->tty_old_pgrp = NULL;
linux-4.15.18+/drivers/tty/tty_jobctrl.c:120:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:122:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:131:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:132:	if (current->signal->leader &&
linux-4.15.18+/drivers/tty/tty_jobctrl.c:133:	    !current->signal->tty &&
linux-4.15.18+/drivers/tty/tty_jobctrl.c:152:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:161:	spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:162:	tty = tty_kref_get(current->signal->tty);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:163:	spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:261:	if (!current->signal->leader)
linux-4.15.18+/drivers/tty/tty_jobctrl.c:281:		spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:282:		old_pgrp = current->signal->tty_old_pgrp;
linux-4.15.18+/drivers/tty/tty_jobctrl.c:283:		current->signal->tty_old_pgrp = NULL;
linux-4.15.18+/drivers/tty/tty_jobctrl.c:284:		spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:293:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:294:	put_pid(current->signal->tty_old_pgrp);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:295:	current->signal->tty_old_pgrp = NULL;
linux-4.15.18+/drivers/tty/tty_jobctrl.c:297:	tty = tty_kref_get(current->signal->tty);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:309:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/drivers/tty/tty_jobctrl.c:350:	if (current->signal->leader && (task_session(current) == tty->session))
linux-4.15.18+/drivers/tty/tty_jobctrl.c:357:	if (!current->signal->leader || current->signal->tty) {
linux-4.15.18+/drivers/tty/tty_jobctrl.c:441: *	Locking: none. Reference to current->signal->tty is safe.
linux-4.15.18+/drivers/tty/tty_jobctrl.c:451:	if (tty == real_tty && current->signal->tty != real_tty)
linux-4.15.18+/drivers/tty/tty_jobctrl.c:480:	if (!current->signal->tty ||
linux-4.15.18+/drivers/tty/tty_jobctrl.c:481:	    (current->signal->tty != real_tty) ||
linux-4.15.18+/drivers/tty/tty_jobctrl.c:515: *	Locking: none. Reference to current->signal->tty is safe.
linux-4.15.18+/drivers/tty/tty_jobctrl.c:523:	if (tty == real_tty && current->signal->tty != real_tty)
linux-4.15.18+/drivers/tty/tty_jobctrl.c:541:		if (current->signal->tty != tty)
linux-4.15.18+/drivers/tty/tty_io.c:2144: *		current->signal->tty check is safe without locks
linux-4.15.18+/drivers/tty/tty_io.c:2154:	if ((current->signal->tty != tty) && !capable(CAP_SYS_ADMIN))
linux-4.15.18+/drivers/crypto/nx/nx.c:70:		atomic_set(&(nx_ctx->stats->last_error_pid), current->pid);
linux-4.15.18+/drivers/crypto/nx/nx.c:140:			       current->pid);
linux-4.15.18+/drivers/crypto/caam/qi.c:500:	struct cpumask old_cpumask = current->cpus_allowed;
linux-4.15.18+/drivers/crypto/caam/qi.c:715:	struct cpumask old_cpumask = current->cpus_allowed;
linux-4.15.18+/drivers/scsi/aic7xxx/aic79xx_core.c:7225:		printk("%s: Timedout during current-sensing test\n",
linux-4.15.18+/drivers/scsi/aacraid/commsup.c:1504:	if (aac->thread->pid != current->pid) {
linux-4.15.18+/drivers/scsi/sg.c:675:				   current->comm);
linux-4.15.18+/drivers/scsi/scsi_error.c:1189:					     current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1203:						  current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1297:						    current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1366:					    current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1383:				    current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1399:					    current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1432:					     current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1447:				     "%s: Sending BDR\n", current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1464:					    "%s: BDR failed\n", current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1501:					     current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1511:				     current->comm, id));
linux-4.15.18+/drivers/scsi/scsi_error.c:1518:					     current->comm, id));
linux-4.15.18+/drivers/scsi/scsi_error.c:1564:					     current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1585:				     current->comm, channel));
linux-4.15.18+/drivers/scsi/scsi_error.c:1602:					     current->comm, channel));
linux-4.15.18+/drivers/scsi/scsi_error.c:1629:				     current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:1642:					     current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:2053:					     current->comm));
linux-4.15.18+/drivers/scsi/scsi_error.c:2066:					     current->comm));
linux-4.15.18+/drivers/scsi/lpfc/lpfc_bsg.c:2591:	evt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,
linux-4.15.18+/drivers/scsi/lpfc/lpfc_bsg.c:3141:	evt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,
linux-4.15.18+/drivers/scsi/scsi_ioctl.c:216:		       "ioctl, please convert it to SG_IO\n", current->comm);
linux-4.15.18+/drivers/scsi/lpfc/lpfc_hbadisc.c:747:	current->flags |= PF_NOFREEZE;
linux-4.15.18+/drivers/scsi/cxlflash/superpipe.c:150: * NOTE: despite the name pid, in linux, current->pid actually refers
linux-4.15.18+/drivers/video/backlight/sky81452-backlight.c:224:	ret = of_property_read_u32(np, "skyworks,current-limit-mA",
linux-4.15.18+/drivers/video/backlight/as3711_bl.c:240:	/* max tuning I = 31uA for voltage- and 38250uA for current-feedback */
linux-4.15.18+/drivers/video/backlight/pm8941-wled.c:290:			"qcom,current-boost-limit",
linux-4.15.18+/drivers/video/backlight/pm8941-wled.c:295:			"qcom,current-limit",
linux-4.15.18+/drivers/mtd/ubi/debug.h:33:		       __func__, __LINE__, current->pid);                    \
linux-4.15.18+/drivers/mtd/ubi/debug.h:42:	pr_debug("UBI DBG " type " (pid %d): " fmt "\n", current->pid,       \
linux-4.15.18+/drivers/mtd/ubi/gluebi.c:45:	       current->pid, __func__, ##__VA_ARGS__)
linux-4.15.18+/drivers/infiniband/ulp/isert/ib_isert.c:625:	isert_info("conn %p final kref %s/%d\n", isert_conn, current->comm,
linux-4.15.18+/drivers/infiniband/ulp/isert/ib_isert.c:626:		   current->pid);
linux-4.15.18+/drivers/infiniband/sw/rdmavt/qp.c:957:		qp->pid = current->pid;
linux-4.15.18+/drivers/infiniband/hw/mthca/mthca_provider.c:920:				   current->comm);
linux-4.15.18+/drivers/infiniband/hw/mlx5/mlx5_ib.h:51:	 __LINE__, current->pid, ##arg)
linux-4.15.18+/drivers/infiniband/hw/mlx5/mlx5_ib.h:55:	__LINE__, current->pid, ##arg)
linux-4.15.18+/drivers/infiniband/hw/mlx5/mlx5_ib.h:59:	__LINE__, current->pid, ##arg)
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_sdma.c:224:					current->pid);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_sdma.c:236:		sdma_rb_node->pid = current->pid;
linux-4.15.18+/drivers/infiniband/hw/qib/qib_file_ops.c:1159:	const unsigned int weight = cpumask_weight(&current->cpus_allowed);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_file_ops.c:1192:			current->pid);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_file_ops.c:1336:	rcd->pid = current->pid;
linux-4.15.18+/drivers/infiniband/hw/qib/qib_file_ops.c:1338:	strlcpy(rcd->comm, current->comm, sizeof(rcd->comm));
linux-4.15.18+/drivers/infiniband/hw/qib/qib_file_ops.c:1521:			rcd->subpid[subctxt_fp(fp)] = current->pid;
linux-4.15.18+/drivers/infiniband/hw/qib/qib_file_ops.c:1640:		const unsigned int cpu = cpumask_first(&current->cpus_allowed);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_file_ops.c:1642:			cpumask_weight(&current->cpus_allowed);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_file_ops.c:2062:			    task_tgid_vnr(current), current->comm);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:53: * Call with current->mm->mmap_sem held.
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:78:	current->mm->pinned_vm += num_pages;
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:138:	down_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:142:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:149:	if (current->mm) /* during close after signal, mm can be NULL */
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:150:		down_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:154:	if (current->mm) {
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:155:		current->mm->pinned_vm -= num_pages;
linux-4.15.18+/drivers/infiniband/hw/qib/qib_user_pages.c:156:		up_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/infiniband/hw/qib/qib_diag.c:93:		dc->pid = current->pid;
linux-4.15.18+/drivers/infiniband/hw/qib/qib_diag.c:766:	if (dc->pid != current->pid) {
linux-4.15.18+/drivers/infiniband/hw/qib/qib_diag.c:840:	if (dc->pid != current->pid) {
linux-4.15.18+/drivers/infiniband/hw/hfi1/affinity.c:579:		*proc_mask = &current->cpus_allowed;
linux-4.15.18+/drivers/infiniband/hw/hfi1/affinity.c:589:			  current->pid, current->comm,
linux-4.15.18+/drivers/infiniband/hw/hfi1/affinity.c:600:			  current->pid, current->comm,
linux-4.15.18+/drivers/infiniband/hw/hfi1/sdma.c:859:	const struct cpumask *current_mask = &current->cpus_allowed;
linux-4.15.18+/drivers/infiniband/hw/hfi1/file_ops.c:208:		fd->mm = current->mm;
linux-4.15.18+/drivers/infiniband/hw/hfi1/file_ops.c:968:		  uctxt->ctxt, fd->subctxt, current->pid, fd->rec_cpu_num,
linux-4.15.18+/drivers/infiniband/hw/hfi1/file_ops.c:996:	strlcpy(uctxt->comm, current->comm, sizeof(uctxt->comm));
linux-4.15.18+/drivers/infiniband/hw/i40iw/i40iw_verbs.c:1392:	vma = find_vma(current->mm, addr);
linux-4.15.18+/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c:710:	qp_grp->owner_pid = current->pid;
linux-4.15.18+/drivers/infiniband/hw/usnic/usnic_uiom.c:128:	down_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/infiniband/hw/usnic/usnic_uiom.c:130:	locked = npages + current->mm->locked_vm;
linux-4.15.18+/drivers/infiniband/hw/usnic/usnic_uiom.c:189:		current->mm->locked_vm = locked;
linux-4.15.18+/drivers/infiniband/hw/usnic/usnic_uiom.c:191:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/infiniband/hw/usnic/usnic_uiom.c:458:	current->mm->locked_vm -= diff;
linux-4.15.18+/drivers/infiniband/core/ucm.c:1109:			    task_tgid_vnr(current), current->comm);
linux-4.15.18+/drivers/infiniband/core/umem_odp.c:354:	our_pid = get_task_pid(current->group_leader, PIDTYPE_PID);
linux-4.15.18+/drivers/infiniband/core/umem.c:166:	down_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/infiniband/core/umem.c:168:	locked     = npages + current->mm->pinned_vm;
linux-4.15.18+/drivers/infiniband/core/umem.c:237:		current->mm->pinned_vm = locked;
linux-4.15.18+/drivers/infiniband/core/umem.c:239:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/infiniband/core/ucma.c:480:	cm_id = rdma_create_id(current->nsproxy->net_ns,
linux-4.15.18+/drivers/infiniband/core/ucma.c:1637:			    task_tgid_vnr(current), current->comm);
linux-4.15.18+/drivers/infiniband/core/user_mad.c:718:				current->comm);
linux-4.15.18+/drivers/infiniband/core/uverbs_cmd.c:116:	ucontext->tgid = get_task_pid(current->group_leader, PIDTYPE_PID);
linux-4.15.18+/drivers/infiniband/core/uverbs_main.c:673:			    task_tgid_vnr(current), current->comm);
linux-4.15.18+/drivers/misc/mic/scif/scif_dma.c:277:	scif_init_mmu_notifier(mmn, current->mm, ep);
linux-4.15.18+/drivers/misc/mic/scif/scif_dma.c:278:	if (mmu_notifier_register(&mmn->ep_mmu_notifier, current->mm)) {
linux-4.15.18+/drivers/misc/mic/scif/scif_dma.c:1709:		mmn = scif_find_mmu_notifier(current->mm, &ep->rma_info);
linux-4.15.18+/drivers/misc/mic/scif/scif_dma.c:1711:			mmn = scif_add_mmu_notifier(current->mm, ep);
linux-4.15.18+/drivers/misc/mic/scif/scif_api.c:779:	lep->files = current->files;
linux-4.15.18+/drivers/misc/mic/scif/scif_rma.c:1387:		mm = current->mm;
linux-4.15.18+/drivers/misc/cxl/fault.c:164:		 * update_mmu_cache() will not have loaded the hash since current->trap
linux-4.15.18+/drivers/misc/cxl/guest.c:540:		pid = current->pid;
linux-4.15.18+/drivers/misc/cxl/native.c:731:	pid = current->pid;
linux-4.15.18+/drivers/misc/cxl/native.c:921:	pid = (u64)current->pid << 32;
linux-4.15.18+/drivers/misc/qcom-coincell.c:49:	/* find index for current-limiting resistor */
linux-4.15.18+/drivers/misc/sgi-gru/grufault.c:65:	vma = find_vma(current->mm, vaddr);
linux-4.15.18+/drivers/misc/sgi-gru/grufault.c:81:	struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/misc/sgi-gru/grufault.c:98:	struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/misc/sgi-gru/grufault.c:125:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/misc/sgi-gru/grufault.c:895:		gts->ts_tgid_owner = current->tgid;
linux-4.15.18+/drivers/misc/sgi-gru/grufile.c:151:	down_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/misc/sgi-gru/grufile.c:162:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/drivers/misc/sgi-gru/grutlbpurge.c:291:	mn = mmu_find_ops(current->mm, &gru_mmuops);
linux-4.15.18+/drivers/misc/sgi-gru/grutlbpurge.c:304:		err = __mmu_notifier_register(&gms->ms_notifier, current->mm);
linux-4.15.18+/drivers/misc/sgi-gru/grutlbpurge.c:323:			mmu_notifier_unregister(&gms->ms_notifier, current->mm);
linux-4.15.18+/drivers/misc/sgi-gru/grumain.c:353:		gts->ts_mm = current->mm;
linux-4.15.18+/drivers/misc/sgi-gru/grumain.c:742:	if (!gru || gts->ts_tgid_owner != current->tgid)
linux-4.15.18+/drivers/iio/health/max30102.c:236:	ret = of_property_read_u32(np, "maxim,red-led-current-microamp", &val);
linux-4.15.18+/drivers/iio/health/max30102.c:238:		dev_info(dev, "no red-led-current-microamp set\n");
linux-4.15.18+/drivers/iio/health/max30102.c:254:	ret = of_property_read_u32(np, "maxim,ir-led-current-microamp", &val);
linux-4.15.18+/drivers/iio/health/max30102.c:256:		dev_info(dev, "no ir-led-current-microamp set\n");
linux-4.15.18+/drivers/iio/health/max30100.c:282:	ret = of_property_read_u32_array(np, "maxim,led-current-microamp",
linux-4.15.18+/drivers/iio/health/max30100.c:289:		dev_warn(dev, "no led-current-microamp set");
linux-4.15.18+/drivers/iio/adc/palmas_gpadc.c:476:	ret = of_property_read_u32(np, "ti,channel0-current-microamp", &pval);
linux-4.15.18+/drivers/iio/adc/palmas_gpadc.c:480:	ret = of_property_read_u32(np, "ti,channel3-current-microamp", &pval);
linux-4.15.18+/drivers/iio/adc/max9611.c:15: * This driver supports input common-mode voltage, current-sense
linux-4.15.18+/drivers/iio/dac/ad5755.c:669:		    of_property_read_bool(pp, "adi,ext-current-sense-resistor");
linux-4.15.18+/drivers/block/swim.c:334:			current->state = TASK_INTERRUPTIBLE;
linux-4.15.18+/drivers/block/swim.c:353:		current->state = TASK_INTERRUPTIBLE;
linux-4.15.18+/drivers/block/swim.c:377:		current->state = TASK_INTERRUPTIBLE;
linux-4.15.18+/drivers/block/aoe/aoecmd.c:1254:	current->flags |= PF_NOFREEZE;
linux-4.15.18+/drivers/block/skd_main.c:3090:		bdev->bd_disk->disk_name, current->comm);
linux-4.15.18+/drivers/block/paride/pd.c:420:			pi_current = pd_current->pi;
linux-4.15.18+/drivers/block/paride/pd.c:431:				pi_current->proto->connect(pi_current);
linux-4.15.18+/drivers/block/paride/pd.c:548:		pi_write_block(pd_current->pi, pd_buf, 512);
linux-4.15.18+/drivers/block/paride/pd.c:576:		pi_read_block(pd_current->pi, pd_buf, 512);
linux-4.15.18+/drivers/block/paride/pf.c:835:		pi_do_claimed(pf_current->pi, do_pf_read);
linux-4.15.18+/drivers/block/paride/pf.c:837:		pi_do_claimed(pf_current->pi, do_pf_write);
linux-4.15.18+/drivers/block/paride/pf.c:894:		pi_disconnect(pf_current->pi);
linux-4.15.18+/drivers/block/paride/pf.c:897:			pi_do_claimed(pf_current->pi, do_pf_read_start);
linux-4.15.18+/drivers/block/paride/pf.c:912:			pi_disconnect(pf_current->pi);
linux-4.15.18+/drivers/block/paride/pf.c:916:				pi_do_claimed(pf_current->pi, do_pf_read_start);
linux-4.15.18+/drivers/block/paride/pf.c:922:		pi_read_block(pf_current->pi, pf_buf, 512);
linux-4.15.18+/drivers/block/paride/pf.c:926:	pi_disconnect(pf_current->pi);
linux-4.15.18+/drivers/block/paride/pf.c:940:		pi_disconnect(pf_current->pi);
linux-4.15.18+/drivers/block/paride/pf.c:943:			pi_do_claimed(pf_current->pi, do_pf_write_start);
linux-4.15.18+/drivers/block/paride/pf.c:953:			pi_disconnect(pf_current->pi);
linux-4.15.18+/drivers/block/paride/pf.c:956:				pi_do_claimed(pf_current->pi, do_pf_write_start);
linux-4.15.18+/drivers/block/paride/pf.c:962:		pi_write_block(pf_current->pi, pf_buf, 512);
linux-4.15.18+/drivers/block/paride/pf.c:973:		pi_disconnect(pf_current->pi);
linux-4.15.18+/drivers/block/paride/pf.c:976:			pi_do_claimed(pf_current->pi, do_pf_write_start);
linux-4.15.18+/drivers/block/paride/pf.c:982:	pi_disconnect(pf_current->pi);
linux-4.15.18+/drivers/block/loop.c:840:	current->flags |= PF_LESS_THROTTLE;
linux-4.15.18+/drivers/block/paride/pcd.c:860:	pi_do_claimed(pcd_current->pi, pcd_start);
linux-4.15.18+/drivers/block/paride/pcd.c:871:			pi_do_claimed(pcd_current->pi, pcd_start);
linux-4.15.18+/drivers/block/xen-blkback/blkback.c:592:		 current->comm, ring->st_oo_req,
linux-4.15.18+/drivers/block/drbd/drbd_actlog.c:198:	     current->comm, current->pid, __func__,
linux-4.15.18+/drivers/block/drbd/drbd_actlog.c:205:		     current->comm, current->pid, __func__,
linux-4.15.18+/drivers/block/drbd/drbd_bitmap.c:131:		 current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/block/drbd/drbd_bitmap.c:150:			  current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/block/drbd/drbd_main.c:333:	snprintf(current->comm, sizeof(current->comm), "drbd_%c_%s",
linux-4.15.18+/drivers/block/drbd/drbd_main.c:365:	drbd_info(resource, "Terminating %s\n", current->comm);
linux-4.15.18+/drivers/block/drbd/drbd_main.c:401:			 thi->name, current->comm, current->pid);
linux-4.15.18+/drivers/block/drbd/drbd_main.c:441:				thi->name, current->comm, current->pid);
linux-4.15.18+/drivers/block/drbd/drbd_main.c:1501:			 current->comm, current->pid, connection->ko_count);
linux-4.15.18+/drivers/block/ataflop.c:1502:	DPRINT(("do_fd_request for pid %d\n",current->pid));
linux-4.15.18+/drivers/block/drbd/drbd_receiver.c:1202:	if (current->plug == &connection->receiver_plug) {
linux-4.15.18+/drivers/power/supply/tps65090-charger.c:210:	prop = of_property_read_bool(np, "ti,enable-low-current-chrg");
linux-4.15.18+/drivers/power/supply/qcom_smbb.c:204:		.name = "qcom,fast-charge-current-limit",
linux-4.15.18+/drivers/power/supply/qcom_smbb.c:212:		.name = "qcom,dc-current-limit",
linux-4.15.18+/drivers/power/supply/qcom_smbb.c:256:		.name = "usb-charge-current-limit",
linux-4.15.18+/drivers/power/supply/bq24190_charger.c:1223:/* Sync the input-current-limit with our parent supply (if we have one) */
linux-4.15.18+/drivers/power/supply/bq24190_charger.c:1233:	 * too low default 500mA iinlim. Delay setting the input-current-limit
linux-4.15.18+/drivers/power/supply/bq24190_charger.c:1747:			dev_warn(bdi->dev, "invalid value for battery:precharge-current-microamp: %d\n",
linux-4.15.18+/drivers/power/supply/bq24190_charger.c:1755:			dev_warn(bdi->dev, "invalid value for battery:charge-term-current-microamp: %d\n",
linux-4.15.18+/drivers/power/supply/bq24257_charger.c:921:	ret = device_property_read_u32(bq->dev, "ti,current-limit",
linux-4.15.18+/drivers/power/supply/max8903_charger.c:99:	/* Set Current-Limit-Mode 1:DC 0:USB */
linux-4.15.18+/drivers/power/supply/max8903_charger.c:140:	/* Do not touch Current-Limit-Mode */
linux-4.15.18+/drivers/power/supply/max17042_battery.c:882:	 * current-sense functionality to be enabled at all.
linux-4.15.18+/drivers/power/supply/rt9455_charger.c:1242:	device_property_read_u32(dev, "richtek,avg-input-current-regulation",
linux-4.15.18+/drivers/power/supply/max77693_charger.c:659:	if (of_property_read_u32(np, "maxim,battery-overcurrent-microamp",
linux-4.15.18+/drivers/power/supply/power_supply_core.c:604:	of_property_read_u32(battery_np, "precharge-current-microamp",
linux-4.15.18+/drivers/power/supply/power_supply_core.c:606:	of_property_read_u32(battery_np, "charge-term-current-microamp",
linux-4.15.18+/drivers/power/supply/bq2415x_charger.c:1607:					       "ti,current-limit",
linux-4.15.18+/drivers/power/supply/Kconfig:422:	  The driver supports controlling charger-enable and current-limit
linux-4.15.18+/drivers/pci/pci-sysfs.c:1221:			current->comm, vma->vm_end-vma->vm_start, vma->vm_pgoff,
linux-4.15.18+/drivers/macintosh/windfarm_pm72.c:728:	else if (!strcmp(sr->name, "cpu-current-0"))
linux-4.15.18+/drivers/macintosh/windfarm_pm72.c:730:	else if (!strcmp(sr->name, "cpu-current-1"))
linux-4.15.18+/drivers/macintosh/via-pmu.c:1855:	switch_mmu_context(NULL, current->active_mm, NULL);
linux-4.15.18+/drivers/macintosh/via-pmu.c:1944:	switch_mmu_context(NULL, current->active_mm, NULL);
linux-4.15.18+/drivers/macintosh/windfarm_smu_sensors.c:227:	} else if (!strcmp(c, "current-sensor") &&
linux-4.15.18+/drivers/macintosh/windfarm_smu_sat.c:267:		} else if (strcmp(type, "current-sensor") == 0) {
linux-4.15.18+/drivers/macintosh/windfarm_rm31.c:618:	else if (!strcmp(sr->name, "cpu-current-0"))
linux-4.15.18+/drivers/macintosh/windfarm_rm31.c:620:	else if (!strcmp(sr->name, "cpu-current-1"))
linux-4.15.18+/drivers/char/pcmcia/cm4040_cs.c:226:	DEBUGP(2, dev, "-> cm4040_read(%s,%d)\n", current->comm, current->pid);
linux-4.15.18+/drivers/char/pcmcia/cm4040_cs.c:326:	DEBUGP(2, dev, "-> cm4040_write(%s,%d)\n", current->comm, current->pid);
linux-4.15.18+/drivers/char/pcmcia/cm4000_cs.c:929:	DEBUGP(2, dev, "-> cmm_read(%s,%d)\n", current->comm, current->pid);
linux-4.15.18+/drivers/char/pcmcia/cm4000_cs.c:1059:	DEBUGP(2, dev, "-> cmm_write(%s,%d)\n", current->comm, current->pid);
linux-4.15.18+/drivers/char/pcmcia/cm4000_cs.c:1658:	      imajor(inode), minor, current->comm, current->pid);
linux-4.15.18+/drivers/char/agp/frontend.c:592:		client = agp_find_client_by_pid(current->pid);
linux-4.15.18+/drivers/char/agp/frontend.c:692:	priv->my_pid = current->pid;
linux-4.15.18+/drivers/char/agp/frontend.c:698:	client = agp_find_client_by_pid(current->pid);
linux-4.15.18+/drivers/char/agp/generic.c:517:			printk(KERN_INFO PFX "%s tried to set rate=x0. Setting to x1 mode.\n", current->comm);
linux-4.15.18+/drivers/char/agp/generic.c:595:		printk(KERN_INFO PFX "%s tried to set rate=x0. Setting to AGP3 x4 mode.\n", current->comm);
linux-4.15.18+/drivers/char/agp/generic.c:599:		printk(KERN_INFO PFX "%s tried to set rate=x%d. Setting to AGP3 x8 mode.\n", current->comm, tmp * 4);
linux-4.15.18+/drivers/char/agp/generic.c:629:						current->comm, *requested_mode);
linux-4.15.18+/drivers/char/agp/generic.c:640:					current->comm, *requested_mode);
linux-4.15.18+/drivers/char/agp/generic.c:649:			printk(KERN_INFO PFX "%s requested AGPx8 but bridge not capable.\n", current->comm);
linux-4.15.18+/drivers/char/agp/generic.c:655:			printk(KERN_INFO PFX "%s requested AGPx8 but graphic card not capable.\n", current->comm);
linux-4.15.18+/drivers/char/random.c:1776:		       current->comm, nbytes);
linux-4.15.18+/drivers/char/mem.c:730:	return current->mm->get_unmapped_area(file, addr, len, pgoff, flags);
linux-4.15.18+/drivers/nvdimm/region_devs.c:1051:	idx = this_cpu_add_return(flush_idx, hash_32(current->pid + idx, 8));
linux-4.15.18+/drivers/usb/misc/usb251xb.c:487:	if (!of_property_read_u32(np, "sp-max-total-current-microamp",
linux-4.15.18+/drivers/usb/misc/usb251xb.c:492:	if (!of_property_read_u32(np, "bp-max-total-current-microamp",
linux-4.15.18+/drivers/usb/misc/usb251xb.c:497:	if (!of_property_read_u32(np, "sp-max-removable-current-microamp",
linux-4.15.18+/drivers/usb/misc/usb251xb.c:502:	if (!of_property_read_u32(np, "bp-max-removable-current-microamp",
linux-4.15.18+/drivers/usb/mtu3/mtu3_qmu.c:425:	if (le16_to_cpu(gpd_current->buf_len) != 0) {
linux-4.15.18+/drivers/usb/mtu3/mtu3_qmu.c:443:	gpd_current->flag |= GPD_FLAGS_BPS;
linux-4.15.18+/drivers/usb/mtu3/mtu3_qmu.c:444:	gpd_current->chksum = qmu_calc_checksum((u8 *)gpd_current);
linux-4.15.18+/drivers/usb/mtu3/mtu3_qmu.c:445:	gpd_current->flag |= GPD_FLAGS_HWO;
linux-4.15.18+/drivers/usb/chipidea/ci_hdrc_imx.c:138:	if (of_find_property(np, "over-current-active-high", NULL))
linux-4.15.18+/drivers/usb/core/devio.c:783:		 current->comm, ifnum);
linux-4.15.18+/drivers/usb/core/devio.c:858:					current->comm, index, index ^ 0x80);
linux-4.15.18+/drivers/usb/core/devio.c:1022:			current->comm);
linux-4.15.18+/drivers/usb/core/devio.c:1143:			   current->comm, ctrl.bRequestType, ctrl.bRequest,
linux-4.15.18+/drivers/usb/core/devio.c:1238:				task_pid_nr(current), current->comm,
linux-4.15.18+/drivers/usb/core/devio.c:1333:					number,	interface->dev.driver->name, current->comm);
linux-4.15.18+/drivers/usb/core/devio.c:1387:					current->comm, u);
linux-4.15.18+/drivers/usb/core/devio.c:2227:			portnum, task_pid_nr(current), current->comm);
linux-4.15.18+/drivers/usb/core/message.c:67:			current->comm,
linux-4.15.18+/drivers/usb/core/urb.c:330: *   (c) current->state != TASK_RUNNING, this is the case only after
linux-4.15.18+/drivers/usb/usbip/usbip_common.c:329:			pr_debug("%-10s:", current->comm);
linux-4.15.18+/drivers/usb/gadget/legacy/inode.c:535:	priv->mm = current->mm; /* mm teardown waits for iocbs in exit_aio() */
linux-4.15.18+/drivers/usb/gadget/function/f_fs.c:1107:	p->mm = current->mm;
linux-4.15.18+/drivers/usb/gadget/function/f_fs.c:1152:	p->mm = current->mm;
linux-4.15.18+/drivers/md/bcache/btree.c:453:	BUG_ON(current->bio_list);
linux-4.15.18+/drivers/md/bcache/btree.c:547:	    !current->bio_list)
linux-4.15.18+/drivers/md/bcache/btree.c:895:	BUG_ON(current->bio_list);
linux-4.15.18+/drivers/md/bcache/btree.c:982:		if (current->bio_list)
linux-4.15.18+/drivers/md/bcache/btree.c:2137:	if (current->bio_list) {
linux-4.15.18+/drivers/md/bcache/btree.c:2219:	BUG_ON(current->bio_list);
linux-4.15.18+/drivers/md/raid1.c:1126:	if (from_schedule || current->bio_list) {
linux-4.15.18+/drivers/md/dm-bufio.c:190:#define dm_bufio_in_request()	(!!current->bio_list)
linux-4.15.18+/drivers/md/dm.c:477:				current->comm, cmd);
linux-4.15.18+/drivers/md/dm.c:1119: * Flush current->bio_list when the target map method blocks.
linux-4.15.18+/drivers/md/dm.c:1136:	if (unlikely(!current->bio_list))
linux-4.15.18+/drivers/md/dm.c:1140:		list = current->bio_list[i];
linux-4.15.18+/drivers/md/dm.c:1141:		bio_list_init(&current->bio_list[i]);
linux-4.15.18+/drivers/md/dm.c:1147:				bio_list_add(&current->bio_list[i], bio);
linux-4.15.18+/drivers/md/dm.c:1163:	list_add(&o->cb.list, &current->plug->cb_list);
linux-4.15.18+/drivers/md/dm-integrity.c:1660:		 * stall bios on current->bio_list.
linux-4.15.18+/drivers/md/raid10.c:998:				     current->bio_list &&
linux-4.15.18+/drivers/md/raid10.c:999:				     (!bio_list_empty(&current->bio_list[0]) ||
linux-4.15.18+/drivers/md/raid10.c:1000:				      !bio_list_empty(&current->bio_list[1]))),
linux-4.15.18+/drivers/md/raid10.c:1078:	if (from_schedule || current->bio_list) {
linux-4.15.18+/drivers/net/tun.c:1320:		struct page_frag *pfrag = &current->task_frag;
linux-4.15.18+/drivers/net/tun.c:1437:	struct page_frag *alloc_frag = &current->task_frag;
linux-4.15.18+/drivers/net/tun.c:1932:	current->state = TASK_INTERRUPTIBLE;
linux-4.15.18+/drivers/net/tun.c:1950:	current->state = TASK_RUNNING;
linux-4.15.18+/drivers/net/tun.c:2568:		tun_get_iff(current->nsproxy->net_ns, tun, &ifr);
linux-4.15.18+/drivers/net/tun.c:2837:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/drivers/net/tun.c:2892:		tun_get_iff(current->nsproxy->net_ns, tun, &ifr);
linux-4.15.18+/drivers/net/slip/slip.c:818:	sl->pid = current->pid;
linux-4.15.18+/drivers/net/slip/slip.c:1256:		if (sl->tty != current->signal->tty &&
linux-4.15.18+/drivers/net/slip/slip.c:1257:						sl->pid != current->pid) {
linux-4.15.18+/drivers/net/wimax/i2400m/tx.c:893:		 current->pid, (void *) tx_msg - i2400m->tx_buf,
linux-4.15.18+/drivers/net/wan/dscc4.c:428:                      ((dpriv->tx_current-1)%TX_RING_SIZE)*sizeof(struct TxFD);
linux-4.15.18+/drivers/net/tap.c:505:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/drivers/net/ethernet/realtek/8139too.c:79:		buffer overrun setting current->comm.
linux-4.15.18+/drivers/net/ethernet/mellanox/mlx5/core/cq.c:176:	cq->pid = current->pid;
linux-4.15.18+/drivers/net/ethernet/mellanox/mlx5/core/fpga/core.h:60:		 __func__, __LINE__, current->pid, ##__VA_ARGS__)
linux-4.15.18+/drivers/net/ethernet/mellanox/mlx5/core/fpga/core.h:64:		__func__, __LINE__, current->pid, ##__VA_ARGS__)
linux-4.15.18+/drivers/net/ethernet/mellanox/mlx5/core/fpga/core.h:68:		__func__, __LINE__, current->pid, ##__VA_ARGS__)
linux-4.15.18+/drivers/net/ethernet/mellanox/mlx5/core/qp.c:163:	qp->pid = current->pid;
linux-4.15.18+/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h:55:		 __func__, __LINE__, current->pid,			\
linux-4.15.18+/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h:66:		__func__, __LINE__, current->pid,	\
linux-4.15.18+/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h:71:		 __func__, __LINE__, current->pid,			\
linux-4.15.18+/drivers/net/ethernet/neterion/vxge/vxge-traffic.h:189: *             cleared by H/W at the end of the current-timer-interval when
linux-4.15.18+/drivers/net/ethernet/qualcomm/qca_uart.c:350:	of_property_read_u32(serdev->dev.of_node, "current-speed", &speed);
linux-4.15.18+/drivers/net/ethernet/tile/tilepro.c:464:		HV_PTE pte = *virt_to_pte(current->mm, (unsigned long)va);
linux-4.15.18+/drivers/net/ethernet/tile/tilepro.c:1891:		HV_PTE pte = *virt_to_pte(current->mm, (unsigned long)data);
linux-4.15.18+/drivers/net/ethernet/freescale/fec_mpc52xx.c:938:	prop = of_get_property(np, "current-speed", &prop_size);
linux-4.15.18+/drivers/net/ppp/ppp_generic.c:601:		err = ppp_unattached_ioctl(current->nsproxy->net_ns,
linux-4.15.18+/drivers/net/ppp/ppp_generic.c:2569:	return ppp_register_net_channel(current->nsproxy->net_ns, chan);
linux-4.15.18+/drivers/net/wireless/realtek/rtlwifi/debug.c:77:			current->comm, current->pid, titlestring);
linux-4.15.18+/drivers/net/wireless/intersil/hostap/hostap_ioctl.c:2907:	       dev->name, task_pid_nr(current), current->comm);
linux-4.15.18+/drivers/net/wireless/broadcom/b43/phy_g.c:1970:			/* Current-Idle-TSSI sanity check. */
linux-4.15.18+/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c:695:		  current->pid, name, ifp->mac_addr);
linux-4.15.18+/drivers/net/wireless/ti/wl1251/boot.c:195:	 * 1.35-BB_REFDIV[1:0], set charge pump current- BB_CPGAIN[4:2],
linux-4.15.18+/drivers/net/wireless/intel/iwlegacy/3945.c:1485:	/* Get this channel's rate-to-current-power settings table */
linux-4.15.18+/drivers/net/wireless/cisco/airo.c:3107:			current->state = TASK_RUNNING;
linux-4.15.18+/drivers/staging/rtl8188eu/os_dep/usb_intf.c:211:	pr_debug("==> %s (%s:%d)\n", __func__, current->comm, current->pid);
linux-4.15.18+/drivers/staging/rtl8188eu/os_dep/usb_intf.c:276:	pr_debug("==> %s (%s:%d)\n", __func__, current->comm, current->pid);
linux-4.15.18+/drivers/staging/comedi/comedi_fops.c:2202:	 * 'trylock' avoids circular dependency with current->mm->mmap_sem
linux-4.15.18+/drivers/staging/lustre/lustre/llite/statahead.c:1551:		     lli->lli_opendir_pid != current->pid)) {
linux-4.15.18+/drivers/staging/lustre/lustre/llite/llite_mmap.c:228:	CDEBUG(D_MMAP, "%s mkwrite with %d\n", current->comm, result);
linux-4.15.18+/drivers/staging/lustre/lustre/llite/llite_mmap.c:322:	CDEBUG(D_MMAP, "%s fault %d/%d\n", current->comm, fault_ret, result);
linux-4.15.18+/drivers/staging/lustre/lustre/llite/llite_mmap.c:354:				      current->comm);
linux-4.15.18+/drivers/staging/lustre/lustre/llite/llite_mmap.c:384:			      current->comm, vmf->pgoff,
linux-4.15.18+/drivers/staging/lustre/lustre/llite/llite_lib.c:307:	sbi->ll_mnt.mnt = current->fs->root.mnt;
linux-4.15.18+/drivers/staging/lustre/lustre/llite/lproc_llite.c:1106:		 sbi->ll_stats_track_id == current->pid)
linux-4.15.18+/drivers/staging/lustre/lustre/llite/lproc_llite.c:1109:		 sbi->ll_stats_track_id == current->real_parent->pid)
linux-4.15.18+/drivers/staging/lustre/lustre/llite/file.c:1959:				       current->comm);
linux-4.15.18+/drivers/staging/lustre/lustre/llite/file.c:2449:	 * pointer space for current->files are not intersecting
linux-4.15.18+/drivers/staging/lustre/lustre/llite/vvp_io.c:372:	struct mm_struct       *mm = current->mm;
linux-4.15.18+/drivers/staging/lustre/lustre/llite/vvp_io.c:730:		ll_rw_stats_tally(ll_i2sbi(inode), current->pid,
linux-4.15.18+/drivers/staging/lustre/lustre/llite/vvp_io.c:1000:		ll_rw_stats_tally(ll_i2sbi(inode), current->pid,
linux-4.15.18+/drivers/staging/lustre/lustre/include/lustre_import.h:259:	 * Current connection. \a imp_connection is imp_conn_current->oic_conn
linux-4.15.18+/drivers/staging/lustre/lustre/osc/osc_io.c:463:			      start, current->comm);
linux-4.15.18+/drivers/staging/lustre/lustre/mdc/mdc_lib.c:373:	rec->lk_fsuid    = op_data->op_fsuid; /* current->fsuid; */
linux-4.15.18+/drivers/staging/lustre/lustre/mdc/mdc_lib.c:374:	rec->lk_fsgid    = op_data->op_fsgid; /* current->fsgid; */
linux-4.15.18+/drivers/staging/lustre/lustre/mdc/mdc_lib.c:375:	rec->lk_cap      = op_data->op_cap;   /* current->cap_effective; */
linux-4.15.18+/drivers/staging/lustre/lustre/ptlrpc/import.c:774:	list_del(&imp->imp_conn_current->oic_item);
linux-4.15.18+/drivers/staging/lustre/lustre/ptlrpc/import.c:775:	list_add(&imp->imp_conn_current->oic_item, &imp->imp_conn_list);
linux-4.15.18+/drivers/staging/lustre/lustre/ptlrpc/import.c:776:	imp->imp_last_success_conn = imp->imp_conn_current->oic_last_attempt;
linux-4.15.18+/drivers/staging/lustre/include/linux/libcfs/curproc.h:54:#define current_pid()		(current->pid)
linux-4.15.18+/drivers/staging/lustre/include/linux/libcfs/curproc.h:55:#define current_comm()		(current->comm)
linux-4.15.18+/drivers/staging/lustre/include/linux/libcfs/libcfs_prim.h:53:	return current->flags & PF_MEMALLOC;
linux-4.15.18+/drivers/staging/lustre/include/linux/libcfs/libcfs_prim.h:58:	current->flags |= PF_MEMALLOC;
linux-4.15.18+/drivers/staging/lustre/include/linux/libcfs/libcfs_prim.h:63:	current->flags &= ~PF_MEMALLOC;
linux-4.15.18+/drivers/staging/lustre/lnet/klnds/o2iblnd/o2iblnd.h:108:#define kiblnd_rdma_create_id(cb, dev, ps, qpt) rdma_create_id(current->nsproxy->net_ns, \
linux-4.15.18+/drivers/staging/lustre/lnet/lnet/config.c:184:	if (current->nsproxy->net_ns)
linux-4.15.18+/drivers/staging/lustre/lnet/lnet/config.c:185:		ni->ni_net_ns = get_net(current->nsproxy->net_ns);
linux-4.15.18+/drivers/staging/lustre/lnet/lnet/lib-move.c:2336:			if (!net_eq(ni->ni_net_ns, current->nsproxy->net_ns))
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-tracefile.c:194:	header->ph_pid = current->pid;
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:52:	spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:53:	old = current->blocked;
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:54:	sigfillset(&current->blocked);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:56:	spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:67:	spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:68:	old = current->blocked;
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:69:	sigaddsetmask(&current->blocked, sigs);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:71:	spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:82:	spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:83:	old = current->blocked;
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:84:	sigaddsetmask(&current->blocked, ~sigs);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:86:	spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:97:	spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:98:	current->blocked = old;
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:100:	spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:109:	spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/linux/linux-prim.c:111:	spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/debug.c:338:	journal_info = current->journal_info;
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/debug.c:339:	current->journal_info = NULL;
linux-4.15.18+/drivers/staging/lustre/lnet/libcfs/debug.c:353:	current->journal_info = journal_info;
linux-4.15.18+/drivers/staging/rtl8723bs/os_dep/sdio_intf.c:622:	DBG_871X("==> %s (%s:%d)\n", __func__, current->comm, current->pid);
linux-4.15.18+/drivers/staging/rtl8723bs/os_dep/os_intfs.c:1489:	DBG_871X("==> %s (%s:%d)\n", __func__, current->comm, current->pid);
linux-4.15.18+/drivers/staging/rtl8723bs/os_dep/os_intfs.c:1845:	DBG_871X("==> %s (%s:%d)\n", __func__, current->comm, current->pid);
linux-4.15.18+/drivers/staging/android/ashmem.c:503:	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
linux-4.15.18+/drivers/staging/unisys/visornic/visornic_main.c:1453:	for_each_netdev_rcu(current->nsproxy->net_ns, dev) {
linux-4.15.18+/drivers/staging/media/atomisp/pci/atomisp2/hmm/hmm_bo.c:999:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/staging/media/atomisp/pci/atomisp2/hmm/hmm_bo.c:1000:	vma = find_vma(current->mm, (unsigned long)userptr);
linux-4.15.18+/drivers/staging/media/atomisp/pci/atomisp2/hmm/hmm_bo.c:1001:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/staging/media/atomisp/pci/atomisp2/hmm/hmm_bo.c:1015:		page_nr = get_pfnmap_pages(current, current->mm,
linux-4.15.18+/drivers/staging/irda/net/irqueue.c:879:	entry = hashbin->hb_current->q_next;
linux-4.15.18+/drivers/staging/rtlwifi/debug.c:77:			current->comm, current->pid, titlestring);
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_kern_lib.c:293:		status = vchiq_open_service_internal(service, current->pid);
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_kern_lib.c:399:				list)->pid == current->pid) {
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_kern_lib.c:451:		waiter->pid = current->pid;
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_kern_lib.c:457:				waiter, current->pid);
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:807:					list)->pid == current->pid) {
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:820:					current->pid);
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:826:				current->pid);
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:850:			waiter->pid = current->pid;
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:856:				waiter, current->pid);
linux-4.15.18+/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c:1689:		instance->pid = current->tgid;
linux-4.15.18+/drivers/sbus/char/envctrl.c:999:	printk(KERN_INFO PFX "%s starting...\n", current->comm);
linux-4.15.18+/drivers/sbus/char/envctrl.c:1014:						current->comm, whichcpu, 
linux-4.15.18+/drivers/sbus/char/envctrl.c:1021:	printk(KERN_INFO PFX "%s exiting...\n", current->comm);
linux-4.15.18+/drivers/isdn/hisax/hfc_pci.c:687:			count, current->state);
linux-4.15.18+/drivers/isdn/hisax/config.c:712:	i = (ulong) & len - current->kernel_stack_page;
linux-4.15.18+/drivers/isdn/hisax/config.c:713:	sprintf(tmpbuf, "kstack %s %lx use %ld\n", current->comm,
linux-4.15.18+/drivers/isdn/hisax/config.c:714:		current->kernel_stack_page, i);
linux-4.15.18+/drivers/isdn/hisax/hfc_2bds0.c:297:			count, current->state);
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:325:		diva_current->dsp_mask = 0x00000003;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:327:		diva_current->xdi_adapter.a.io =
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:328:			&diva_current->xdi_adapter;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:329:		diva_current->xdi_adapter.DIRequest = request;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:330:		diva_current->interface.cmd_proc = diva_4bri_cmd_card_proc;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:331:		diva_current->xdi_adapter.Properties =
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:333:		diva_current->CardOrdinal = a->CardOrdinal;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:335:		diva_current->xdi_adapter.Channels =
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:337:		diva_current->xdi_adapter.e_max =
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:339:		diva_current->xdi_adapter.e_tbl =
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:341:				       diva_current->xdi_adapter.e_max *
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:344:		if (!diva_current->xdi_adapter.e_tbl) {
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:352:		memset(diva_current->xdi_adapter.e_tbl, 0x00,
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:353:		       diva_current->xdi_adapter.e_max * sizeof(E_INFO));
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:355:		if (diva_os_initialize_spin_lock(&diva_current->xdi_adapter.isr_spin_lock, "isr")) {
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:363:		if (diva_os_initialize_spin_lock(&diva_current->xdi_adapter.data_spin_lock, "data")) {
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:372:		strcpy(diva_current->xdi_adapter.req_soft_isr. dpc_thread_name, "kdivas4brid");
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:374:		if (diva_os_initialize_soft_isr(&diva_current->xdi_adapter.req_soft_isr, DIDpcRoutine,
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:375:						&diva_current->xdi_adapter)) {
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:387:		diva_current->xdi_adapter.isr_soft_isr.object =
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:388:			diva_current->xdi_adapter.req_soft_isr.object;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:400:			memcpy(&diva_current->resources, &a->resources, sizeof(divas_card_resources_t));
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:401:		diva_current->resources.pci.qoffset = (a->xdi_adapter.MemorySize >> factor);
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:596:			diva_os_destroy_spin_lock(&diva_current->
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:599:			diva_os_destroy_spin_lock(&diva_current->
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:604:			diva_os_cancel_soft_isr(&diva_current->xdi_adapter.
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:606:			diva_os_cancel_soft_isr(&diva_current->xdi_adapter.
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:609:			diva_os_remove_soft_isr(&diva_current->xdi_adapter.
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:611:			diva_current->xdi_adapter.isr_soft_isr.object = NULL;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:613:			if (diva_current->xdi_adapter.e_tbl) {
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:615:					     diva_current->xdi_adapter.
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:618:			diva_current->xdi_adapter.e_tbl = NULL;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:619:			diva_current->xdi_adapter.e_max = 0;
linux-4.15.18+/drivers/isdn/hardware/eicon/os_4bri.c:620:			diva_current->xdi_adapter.e_count = 0;
linux-4.15.18+/drivers/isdn/mISDN/clock.c:154:		       iclock_current ? iclock_current->name : "nothing");
linux-4.15.18+/drivers/isdn/mISDN/clock.c:182:			       iclock_current ? iclock_current->name : "nothing");
linux-4.15.18+/drivers/isdn/mISDN/stack.c:213:	sigfillset(&current->blocked);
linux-4.15.18+/drivers/gpu/host1x/syncpt.c:296:				 current->comm, sp->id, sp->name,
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_cs.c:193:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_cs.c:198:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_gem.c:336:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_gem.c:339:			up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_gem.c:346:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_ttm.c:553:	if (current->mm != gtt->usermm)
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_ttm.c:808:	gtt->usermm = current->mm;
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_mn.c:181: * Creates a notifier context for current->mm.
linux-4.15.18+/drivers/gpu/drm/radeon/radeon_mn.c:185:	struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/gpu/drm/drm_vm.c:395:		vma_entry->pid = current->pid;
linux-4.15.18+/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c:455:			 pool->dev_name, pool->name, current->pid,
linux-4.15.18+/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c:765:			 pool->dev_name, pool->name, current->pid, count);
linux-4.15.18+/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c:1158:			 p->pool->dev_name, p->pool->name, current->pid,
linux-4.15.18+/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c:1234:			current->pid);
linux-4.15.18+/drivers/gpu/drm/amd/scheduler/gpu_scheduler.c:216:	if ((current->flags & PF_SIGNALED) && current->exit_code == SIGKILL)
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_gem.c:123:	if (mm && mm != current->mm)
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c:482:		if (usermm && usermm != current->mm)
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.h:68:			if ((mmptr) == current->mm) {			\
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.h:70:			} else if (current->mm == NULL) {		\
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c:706:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c:716:			up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c:745:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c:750:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c:1088:	gtt->usermm = current->mm;
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c:253: * Creates a notifier context for current->mm.
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_mn.c:257:	struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/gpu/drm/amd/amdgpu/amdgpu_bo_list.c:143:			if (usermm != current->mm) {
linux-4.15.18+/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c:116:			current->pid);
linux-4.15.18+/drivers/gpu/drm/amd/powerplay/hwmgr/pp_psm.c:238:			&pcurrent->hardware, &requested->hardware, &equal)))
linux-4.15.18+/drivers/gpu/drm/amd/powerplay/hwmgr/pp_psm.c:242:		phm_set_power_state(hwmgr, &pcurrent->hardware, &requested->hardware);
linux-4.15.18+/drivers/gpu/drm/exynos/exynos_drm_g2d.c:1382:	runqueue_node->pid = current->pid;
linux-4.15.18+/drivers/gpu/drm/i915/i915_gem_userptr.c:346:	mm = __i915_mm_struct_find(dev_priv, current->mm);
linux-4.15.18+/drivers/gpu/drm/i915/i915_gem_userptr.c:357:		mm->mm = current->mm;
linux-4.15.18+/drivers/gpu/drm/i915/i915_gem_userptr.c:358:		mmgrab(current->mm);
linux-4.15.18+/drivers/gpu/drm/i915/i915_gem_userptr.c:638:	if (mm == current->mm) {
linux-4.15.18+/drivers/gpu/drm/i915/i915_gem_userptr.c:806:	/* And keep a pointer to the current->mm for resolving the user pages
linux-4.15.18+/drivers/gpu/drm/i915/gvt/kvmgt.c:1381:	if (!kvm || kvm->mm != current->mm) {
linux-4.15.18+/drivers/gpu/drm/i915/gvt/kvmgt.c:1490:	bool kthread = current->mm == NULL;
linux-4.15.18+/drivers/gpu/drm/i915/i915_gem.c:1728:		struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/gpu/drm/i915/i915_gem_context.c:296:				      current->comm,
linux-4.15.18+/drivers/gpu/drm/i915/i915_gem_context.c:988:			  current->comm,
linux-4.15.18+/drivers/gpu/drm/etnaviv/etnaviv_gem.c:814:	if (mm == current->mm) {
linux-4.15.18+/drivers/mmc/host/tmio_mmc_core.c:1025:				current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/mmc/host/tmio_mmc_core.c:1031:				current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/mmc/host/tmio_mmc_core.c:1066:			current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/mmc/core/queue.c:47:	current->flags |= PF_MEMALLOC;
linux-4.15.18+/drivers/android/binder_alloc.c:156:				       alloc->pid, current->pid, (u64)user_ptr);
linux-4.15.18+/drivers/android/binder_alloc.c:1000:	alloc->pid = current->group_leader->pid;
linux-4.15.18+/drivers/android/binder.c:1078:		      current->pid, nice, min_nice);
linux-4.15.18+/drivers/android/binder.c:1082:	binder_user_error("%d RLIMIT_NICE not set\n", current->pid);
linux-4.15.18+/drivers/android/binder.c:1174:		     proc->pid, current->pid, node->debug_id,
linux-4.15.18+/drivers/android/binder.c:4189:		if (current->pid < thread->pid)
linux-4.15.18+/drivers/android/binder.c:4191:		else if (current->pid > thread->pid)
linux-4.15.18+/drivers/android/binder.c:4201:	thread->pid = current->pid;
linux-4.15.18+/drivers/android/binder.c:4513:			proc->pid, current->pid, cmd, arg);*/
linux-4.15.18+/drivers/android/binder.c:4601:		pr_info("%d:%d ioctl %x %lx returned %d\n", proc->pid, current->pid, cmd, arg, ret);
linux-4.15.18+/drivers/android/binder.c:4648:	if (proc->tsk != current->group_leader)
linux-4.15.18+/drivers/android/binder.c:4689:		     current->group_leader->pid, current->pid);
linux-4.15.18+/drivers/android/binder.c:4696:	get_task_struct(current->group_leader);
linux-4.15.18+/drivers/android/binder.c:4697:	proc->tsk = current->group_leader;
linux-4.15.18+/drivers/android/binder.c:4707:	proc->pid = current->group_leader->pid;
linux-4.15.18+/drivers/connector/cn_proc.c:209:		ev->event_data.ptrace.tracer_pid  = current->pid;
linux-4.15.18+/drivers/connector/cn_proc.c:210:		ev->event_data.ptrace.tracer_tgid = current->tgid;
linux-4.15.18+/drivers/dma/dmatest.c:302:	const char	*thread_name = current->comm;
linux-4.15.18+/drivers/dma/dmatest.c:348:			current->comm, error_count - MAX_ERROR_COUNT);
linux-4.15.18+/drivers/dma/dmatest.c:385:		current->comm, n, err, src_off, dst_off, len, data);
linux-4.15.18+/drivers/dma/dmatest.c:393:		 current->comm, n, err, src_off, dst_off, len, data);
linux-4.15.18+/drivers/dma/dmatest.c:735:		pr_debug("%s: verifying source buffer...\n", current->comm);
linux-4.15.18+/drivers/dma/dmatest.c:745:		pr_debug("%s: verifying dest buffer...\n", current->comm);
linux-4.15.18+/drivers/dma/dmatest.c:792:		current->comm, total_tests, failed_tests,
linux-4.15.18+/drivers/atm/solos-pci.c:211:			  "L%05d\n%s\n", current->pid, attr->attr.name);
linux-4.15.18+/drivers/atm/solos-pci.c:219:	prm.pid = current->pid;
linux-4.15.18+/drivers/atm/solos-pci.c:267:			  "L%05d\n%s\n%s\n", current->pid, attr->attr.name, buf);
linux-4.15.18+/drivers/atm/solos-pci.c:275:	prm.pid = current->pid;
linux-4.15.18+/drivers/oprofile/buffer_sync.c:91:	struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/ntb/test/ntb_perf.c:319:		pr_debug("%s: All DMA descriptors submitted\n", current->comm);
linux-4.15.18+/drivers/ntb/test/ntb_perf.c:331:	pr_debug("%s: copied %llu bytes\n", current->comm, copied);
linux-4.15.18+/drivers/ntb/test/ntb_perf.c:333:	pr_debug("%s: lasted %llu usecs\n", current->comm, diff_us);
linux-4.15.18+/drivers/ntb/test/ntb_perf.c:337:	pr_debug("%s: MBytes/s: %llu\n", current->comm, perf);
linux-4.15.18+/drivers/ntb/test/ntb_perf.c:366:	pr_debug("kthread %s starting...\n", current->comm);
linux-4.15.18+/drivers/ntb/test/ntb_perf.c:379:				current->comm);
linux-4.15.18+/drivers/ntb/test/ntb_perf.c:414:		pr_err("%s: failed\n", current->comm);
linux-4.15.18+/drivers/media/v4l2-core/videobuf-dma-sg.c:205:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/media/v4l2-core/videobuf-dma-sg.c:207:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/media/v4l2-core/videobuf-dma-sg.c:539:			we take current->mm->mmap_sem there, to prevent
linux-4.15.18+/drivers/media/v4l2-core/videobuf-core.c:540:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/media/v4l2-core/videobuf-core.c:627:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/media/v4l2-core/videobuf-dma-contig.c:163:	struct mm_struct *mm = current->mm;
linux-4.15.18+/drivers/media/v4l2-core/videobuf-dma-contig.c:206:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/drivers/media/pci/zoran/zoran_driver.c:918:		ZR_DEVNAME(zr), __func__, current->comm, task_pid_nr(current), zr->user + 1);
linux-4.15.18+/drivers/media/pci/zoran/zoran_driver.c:994:		ZR_DEVNAME(zr), __func__, current->comm, task_pid_nr(current), zr->user - 1);
linux-4.15.18+/drivers/media/usb/gspca/gspca.c:1285:	PDEBUG(D_STREAM, "[%s] open", current->comm);
linux-4.15.18+/drivers/media/usb/gspca/gspca.c:1301:	PDEBUG(D_STREAM, "[%s] close", current->comm);
linux-4.15.18+/drivers/media/dvb-frontends/mt352.c:333:	/* Use TPS_RECEIVED-registers, not the TPS_CURRENT-registers because
linux-4.15.18+/drivers/s390/crypto/zcrypt_msgtype50.c:466:	ap_msg.psmid = (((unsigned long long) current->pid) << 32) +
linux-4.15.18+/drivers/s390/crypto/zcrypt_msgtype50.c:512:	ap_msg.psmid = (((unsigned long long) current->pid) << 32) +
linux-4.15.18+/drivers/s390/crypto/zcrypt_msgtype6.c:1019:	ap_msg.psmid = (((unsigned long long) current->pid) << 32) +
linux-4.15.18+/drivers/s390/crypto/zcrypt_msgtype6.c:1063:	ap_msg.psmid = (((unsigned long long) current->pid) << 32) +
linux-4.15.18+/drivers/s390/crypto/zcrypt_msgtype6.c:1101:	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
linux-4.15.18+/drivers/s390/crypto/zcrypt_msgtype6.c:1161:	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
linux-4.15.18+/drivers/s390/crypto/zcrypt_msgtype6.c:1266:	ap_msg->psmid = (((unsigned long long) current->pid) << 32) +
linux-4.15.18+/drivers/s390/char/keyboard.c:462:	perm = current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG);
linux-4.15.18+/drivers/vhost/vhost.c:455:	return dev->mm == current->mm ? 0 : -EPERM;
linux-4.15.18+/drivers/vhost/vhost.c:505:	worker = kthread_create(vhost_worker, dev, "vhost-%d", current->pid);
linux-4.15.18+/drivers/hid/hid-core.c:1132:			 n, current->comm);
linux-4.15.18+/drivers/hid/hid-core.c:1178:			 __func__, n, current->comm);
linux-4.15.18+/drivers/hid/hid-core.c:1186:				 __func__, value, n, current->comm);
linux-4.15.18+/drivers/dax/device.c:192:				current->comm, func);
linux-4.15.18+/drivers/dax/device.c:199:				current->comm, func, vma->vm_start, vma->vm_end,
linux-4.15.18+/drivers/dax/device.c:207:				current->comm, func);
linux-4.15.18+/drivers/dax/device.c:213:				current->comm, func);
linux-4.15.18+/drivers/dax/device.c:403:			current->comm, (vmf->flags & FAULT_FLAG_WRITE)
linux-4.15.18+/drivers/dax/device.c:495:	addr_align = current->mm->get_unmapped_area(filp, addr, len_align,
linux-4.15.18+/drivers/dax/device.c:502:	return current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);
linux-4.15.18+/drivers/regulator/of_regulator.c:60:	if (!of_property_read_u32(np, "regulator-input-current-limit-microamp",
linux-4.15.18+/drivers/regulator/of_regulator.c:142:					"regulator-over-current-protection");
linux-4.15.18+/drivers/regulator/tps65090-regulator.c:393:					 "ti,overcurrent-wait",
linux-4.15.18+/drivers/firmware/efi/arm-runtime.c:167:	efi_set_pgd(current->active_mm);
linux-4.15.18+/drivers/cpufreq/pmac32-cpufreq.c:303:	switch_mmu_context(NULL, current->active_mm, NULL);
linux-4.15.18+/drivers/vfio/vfio_iommu_type1.c:258:	is_current = (task->mm == current->mm);
linux-4.15.18+/drivers/vfio/vfio_iommu_type1.c:344:	if (mm == current->mm) {
linux-4.15.18+/drivers/vfio/vfio_iommu_type1.c:404:	if (!current->mm)
linux-4.15.18+/drivers/vfio/vfio_iommu_type1.c:407:	ret = vaddr_get_pfn(current->mm, vaddr, dma->prot, pfn_base);
linux-4.15.18+/drivers/vfio/vfio_iommu_type1.c:419:		if (!lock_cap && current->mm->locked_vm + 1 > limit) {
linux-4.15.18+/drivers/vfio/vfio_iommu_type1.c:434:		ret = vaddr_get_pfn(current->mm, vaddr, dma->prot, &pfn);
linux-4.15.18+/drivers/vfio/vfio_iommu_type1.c:446:			    current->mm->locked_vm + lock_acct + 1 > limit) {
linux-4.15.18+/drivers/vfio/vfio_iommu_type1.c:841:		if (dma->task->mm != current->mm)
linux-4.15.18+/drivers/vfio/vfio_iommu_spapr_tce.c:55:	pr_debug("[%d] RLIMIT_MEMLOCK +%ld %ld/%ld%s\n", current->pid,
linux-4.15.18+/drivers/vfio/vfio_iommu_spapr_tce.c:75:	pr_debug("[%d] RLIMIT_MEMLOCK -%ld %ld/%ld\n", current->pid,
linux-4.15.18+/drivers/vfio/vfio_iommu_spapr_tce.c:123:		if (container->mm == current->mm)
linux-4.15.18+/drivers/vfio/vfio_iommu_spapr_tce.c:127:	BUG_ON(!current->mm);
linux-4.15.18+/drivers/vfio/vfio_iommu_spapr_tce.c:128:	container->mm = current->mm;
linux-4.15.18+/drivers/vfio/vfio_iommu_spapr_tce.c:854:	if (container->mm && container->mm != current->mm)
linux-4.15.18+/drivers/vfio/vfio.c:994:					 current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/vfio/vfio.c:1508:			 "(%s:%d)\n", current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/rio_cm.c:801:		riocm_error("%s(%d) ch_%d not found", current->comm,
linux-4.15.18+/drivers/rapidio/rio_cm.c:1449:		    ch->id, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/rio_cm.c:1465:		       current->comm, task_pid_nr(current), ch->id);
linux-4.15.18+/drivers/rapidio/rio_cm.c:1470:			current->comm, task_pid_nr(current), ch->id);
linux-4.15.18+/drivers/rapidio/rio_cm.c:1490:		    current->comm, task_pid_nr(current), filp);
linux-4.15.18+/drivers/rapidio/rio_cm.c:1508:		    current->comm, task_pid_nr(current), filp);
linux-4.15.18+/drivers/rapidio/rio_cm.c:1515:				    ch->id, current->comm,
linux-4.15.18+/drivers/rapidio/rio_cm.c:1673:		    ch_num, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/rio_cm.c:1680:		    ch_num, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/rio_cm.c:1699:		    ch_num, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/rio_cm.c:1763:		    param.ch_num, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/rio_cm.c:1774:		    ch->id, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:746:		   current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:807:		       current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:815:			current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:823:			current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:1098:		       current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:1107:			current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:1116:			current->comm, task_pid_nr(current),
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:2000:		   filp, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:2014:			   filp, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:2032:			   filp, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:2048:			current->comm, task_pid_nr(current), wret);
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:2055:			   filp, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/rapidio/devices/rio_mport_cdev.c:2062:			   filp, current->comm, task_pid_nr(current));
linux-4.15.18+/drivers/target/iscsi/iscsi_target_nego.c:597:			conn, current->comm, current->pid);
linux-4.15.18+/drivers/target/iscsi/iscsi_target_nego.c:633:	pr_debug("Starting login timer for %s/%d\n", current->comm, current->pid);
linux-4.15.18+/drivers/target/iscsi/iscsi_target_nego.c:645:			conn, current->comm, current->pid);
linux-4.15.18+/drivers/target/iscsi/iscsi_target.c:4120:	if (!strcmp(current->comm, ISCSI_RX_THREAD_NAME)) {
linux-4.15.18+/drivers/target/iscsi/iscsi_target.c:4126:	} else if (!strcmp(current->comm, ISCSI_TX_THREAD_NAME)) {
linux-4.15.18+/tools/perf/builtin-timechart.c:250:	if (pp->current && pp->current->comm && !p->current)
linux-4.15.18+/tools/perf/builtin-timechart.c:251:		pid_set_comm(tchart, pid, pp->current->comm);
linux-4.15.18+/tools/perf/builtin-timechart.c:254:	if (p->current && !p->current->start_time) {
linux-4.15.18+/tools/perf/builtin-timechart.c:255:		p->current->start_time = timestamp;
linux-4.15.18+/tools/perf/builtin-timechart.c:256:		p->current->state_since = timestamp;
linux-4.15.18+/tools/perf/builtin-timechart.c:266:		p->current->end_time = timestamp;
linux-4.15.18+/tools/perf/builtin-timechart.c:429:	if (p && p->current && p->current->state == TYPE_NONE) {
linux-4.15.18+/tools/perf/builtin-timechart.c:430:		p->current->state_since = timestamp;
linux-4.15.18+/tools/perf/builtin-timechart.c:431:		p->current->state = TYPE_WAITING;
linux-4.15.18+/tools/perf/builtin-timechart.c:433:	if (p && p->current && p->current->state == TYPE_BLOCKED) {
linux-4.15.18+/tools/perf/builtin-timechart.c:434:		pid_put_sample(tchart, p->pid, p->current->state, cpu,
linux-4.15.18+/tools/perf/builtin-timechart.c:435:			       p->current->state_since, timestamp, NULL);
linux-4.15.18+/tools/perf/builtin-timechart.c:436:		p->current->state_since = timestamp;
linux-4.15.18+/tools/perf/builtin-timechart.c:437:		p->current->state = TYPE_WAITING;
linux-4.15.18+/tools/perf/builtin-timechart.c:451:	if (prev_p->current && prev_p->current->state != TYPE_NONE)
linux-4.15.18+/tools/perf/builtin-timechart.c:453:			       prev_p->current->state_since, timestamp,
linux-4.15.18+/tools/perf/builtin-timechart.c:456:		if (p->current->state != TYPE_NONE)
linux-4.15.18+/tools/perf/builtin-timechart.c:457:			pid_put_sample(tchart, next_pid, p->current->state, cpu,
linux-4.15.18+/tools/perf/builtin-timechart.c:458:				       p->current->state_since, timestamp,
linux-4.15.18+/tools/perf/builtin-timechart.c:461:		p->current->state_since = timestamp;
linux-4.15.18+/tools/perf/builtin-timechart.c:462:		p->current->state = TYPE_RUNNING;
linux-4.15.18+/tools/perf/builtin-timechart.c:466:		prev_p->current->state = TYPE_NONE;
linux-4.15.18+/tools/perf/builtin-timechart.c:467:		prev_p->current->state_since = timestamp;
linux-4.15.18+/tools/perf/builtin-timechart.c:469:			prev_p->current->state = TYPE_BLOCKED;
linux-4.15.18+/tools/perf/builtin-timechart.c:471:			prev_p->current->state = TYPE_WAITING;
linux-4.15.18+/tools/perf/perf-completion.sh:235:		prev=${words[CURRENT-1]}
linux-4.15.18+/tools/perf/perf-completion.sh:236:		let cword=CURRENT-1
linux-4.15.18+/tools/iio/iio_utils.c:426:			current->scale = 1.0;
linux-4.15.18+/tools/iio/iio_utils.c:427:			current->offset = 0;
linux-4.15.18+/tools/iio/iio_utils.c:428:			current->name = strndup(ent->d_name,
linux-4.15.18+/tools/iio/iio_utils.c:431:			if (!current->name) {
linux-4.15.18+/tools/iio/iio_utils.c:439:			ret = iioutils_break_up_name(current->name,
linux-4.15.18+/tools/iio/iio_utils.c:440:						     &current->generic_name);
linux-4.15.18+/tools/iio/iio_utils.c:443:				free(current->name);
linux-4.15.18+/tools/iio/iio_utils.c:451:				       current->name);
linux-4.15.18+/tools/iio/iio_utils.c:468:			if (fscanf(sysfsfp, "%u", &current->index) != 1) {
linux-4.15.18+/tools/iio/iio_utils.c:485:			ret = iioutils_get_param_float(&current->scale,
linux-4.15.18+/tools/iio/iio_utils.c:488:						       current->name,
linux-4.15.18+/tools/iio/iio_utils.c:489:						       current->generic_name);
linux-4.15.18+/tools/iio/iio_utils.c:493:			ret = iioutils_get_param_float(&current->offset,
linux-4.15.18+/tools/iio/iio_utils.c:496:						       current->name,
linux-4.15.18+/tools/iio/iio_utils.c:497:						       current->generic_name);
linux-4.15.18+/tools/iio/iio_utils.c:501:			ret = iioutils_get_type(&current->is_signed,
linux-4.15.18+/tools/iio/iio_utils.c:502:						&current->bytes,
linux-4.15.18+/tools/iio/iio_utils.c:503:						&current->bits_used,
linux-4.15.18+/tools/iio/iio_utils.c:504:						&current->shift,
linux-4.15.18+/tools/iio/iio_utils.c:505:						&current->mask,
linux-4.15.18+/tools/iio/iio_utils.c:506:						&current->be,
linux-4.15.18+/tools/iio/iio_utils.c:508:						current->name,
linux-4.15.18+/tools/iio/iio_utils.c:509:						current->generic_name);
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:282:				current->next = malloc(sizeof(*current));
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:283:				if (!current->next)
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:285:				current = current->next;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:292:			current->first = first;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:293:			current->next = NULL;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:295:			current->governor = malloc(i - pos + 1);
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:296:			if (!current->governor)
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:299:			memcpy(current->governor, linebuf + pos, i - pos);
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:300:			current->governor[i - pos] = '\0';
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:359:				current->next = malloc(sizeof(*current));
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:360:				if (!current->next)
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:362:				current = current->next;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:369:			current->first = first;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:370:			current->next = NULL;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:374:			if (sscanf(one_value, "%lu", &current->frequency) != 1)
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:429:				current->next = malloc(sizeof(*current));
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:430:				if (!current->next)
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:432:				current = current->next;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:439:			current->first = first;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:440:			current->next = NULL;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:445:			if (sscanf(one_value, "%u", &current->cpu) != 1)
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:662:				current->next = malloc(sizeof(*current));
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:663:				if (!current->next)
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:665:				current = current->next;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:672:			current->first = first;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:673:			current->next = NULL;
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:678:					&current->frequency,
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:679:					&current->time_in_state) != 2)
linux-4.15.18+/tools/power/cpupower/lib/cpufreq.c:682:			*total_time = *total_time + current->time_in_state;
linux-4.15.18+/tools/include/uapi/linux/prctl.h:12:/* Get/set current->mm->dumpable */
linux-4.15.18+/tools/include/uapi/linux/bpf.h:391: *     Return: current->tgid << 32 | current->pid
linux-4.15.18+/tools/include/uapi/linux/bpf.h:397: *     stores current->comm into buf
linux-4.15.18+/tools/testing/selftests/gpio/gpio-mockup-chardev.c:170:			if (strcmp(current->label, gpiochip_name) == 0
linux-4.15.18+/tools/testing/selftests/gpio/gpio-mockup-chardev.c:171:			    || check_prefix(current->label, gpiochip_name)) {
linux-4.15.18+/tools/testing/selftests/gpio/gpio-mockup-chardev.c:306:		gpio_pin_tests(current, current->lines - 1);
linux-4.15.18+/tools/testing/selftests/gpio/gpio-mockup-chardev.c:307:		gpio_pin_tests(current, random() % current->lines);
linux-4.15.18+/block/blk-mq.c:1714:	plug = current->plug;
linux-4.15.18+/block/blk-mq.c:2943:	state = current->state;
linux-4.15.18+/block/blk-mq.c:2959:		if (current->state == TASK_RUNNING)
linux-4.15.18+/block/blk-ioc.c:317: * %current->io_context + get_io_context() for %current.
linux-4.15.18+/block/scsi_ioctl.c:669:			printk(KERN_WARNING "program %s is using a deprecated SCSI ioctl, please convert it to SG_IO\n", current->comm);
linux-4.15.18+/block/scsi_ioctl.c:725:			   "%s: sending ioctl %x to a partition!\n", current->comm, cmd);
linux-4.15.18+/block/cfq-iosched.c:2594:	cic = cfq_cic_lookup(cfqd, current->io_context);
linux-4.15.18+/block/cfq-iosched.c:3845:	cfq_init_cfqq(cfqd, cfqq, current->pid, is_sync);
linux-4.15.18+/block/cfq-iosched.c:4404:		cfqq->pid = current->pid;
linux-4.15.18+/block/blk.h:264: * %NULL if %current->io_context doesn't exist.
linux-4.15.18+/block/blk.h:272:	return current->io_context;
linux-4.15.18+/block/blk.h:280: * If %current->io_context is %NULL, allocate a new io_context and install
linux-4.15.18+/block/blk.h:281: * it.  Returns the current %current->io_context which may be %NULL if
linux-4.15.18+/block/blk.h:285: * task_lock which protects %current->io_context is IRQ-unsafe.
linux-4.15.18+/block/blk.h:290:	if (unlikely(!current->io_context))
linux-4.15.18+/block/blk.h:292:	return current->io_context;
linux-4.15.18+/samples/trace_events/trace-events-sample.c:36:		      &current->cpus_allowed);
linux-4.15.18+/block/bio.c:385:	while ((bio = bio_list_pop(&current->bio_list[0])))
linux-4.15.18+/block/bio.c:387:	current->bio_list[0] = nopunt;
linux-4.15.18+/block/bio.c:390:	while ((bio = bio_list_pop(&current->bio_list[1])))
linux-4.15.18+/block/bio.c:392:	current->bio_list[1] = nopunt;
linux-4.15.18+/block/bio.c:474:		 * bios on current->bio_list, we first try the allocation
linux-4.15.18+/block/bio.c:480:		if (current->bio_list &&
linux-4.15.18+/block/bio.c:481:		    (!bio_list_empty(&current->bio_list[0]) ||
linux-4.15.18+/block/bio.c:482:		     !bio_list_empty(&current->bio_list[1])) &&
linux-4.15.18+/block/bio.c:1174:		if (!current->mm)
linux-4.15.18+/virt/kvm/async_pf.c:203:	work->mm = current->mm;
linux-4.15.18+/block/blk-core.c:1465:	ioc_set_batching(q, current->io_context);
linux-4.15.18+/block/blk-core.c:1802:	plug = current->plug;
linux-4.15.18+/block/blk-core.c:1857:	plug = current->plug;
linux-4.15.18+/block/blk-core.c:1989:	plug = current->plug;
linux-4.15.18+/block/blk-core.c:2208:	 * Various block parts want %current->io_context and lazy ioc
linux-4.15.18+/block/blk-core.c:2277:	 * current->bio_list to keep a list of requests submited by a
linux-4.15.18+/block/blk-core.c:2278:	 * make_request_fn function.  current->bio_list is also used as a
linux-4.15.18+/block/blk-core.c:2284:	if (current->bio_list) {
linux-4.15.18+/block/blk-core.c:2285:		bio_list_add(&current->bio_list[0], bio);
linux-4.15.18+/block/blk-core.c:2305:	current->bio_list = bio_list_on_stack;
linux-4.15.18+/block/blk-core.c:2344:	current->bio_list = NULL; /* deactivate */
linux-4.15.18+/block/blk-core.c:2418:			current->comm, task_pid_nr(current),
linux-4.15.18+/block/blk-core.c:2434:	if (current->plug)
linux-4.15.18+/block/blk-core.c:2435:		blk_flush_plug_list(current->plug, false);
linux-4.15.18+/block/blk-core.c:3526:	struct blk_plug *plug = current->plug;
linux-4.15.18+/block/blk-core.c:3621:	if (plug != current->plug)
linux-4.15.18+/block/blk-core.c:3625:	current->plug = NULL;
linux-4.15.18+/virt/kvm/arm/mmu.c:786:		struct vm_area_struct *vma = find_vma(current->mm, hva);
linux-4.15.18+/virt/kvm/arm/mmu.c:820:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/arm/mmu.c:828:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/arm/mmu.c:1305:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/arm/mmu.c:1306:	vma = find_vma_intersection(current->mm, hva, hva + 1);
linux-4.15.18+/virt/kvm/arm/mmu.c:1309:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/arm/mmu.c:1330:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/arm/mmu.c:1855:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/arm/mmu.c:1869:		struct vm_area_struct *vma = find_vma(current->mm, hva);
linux-4.15.18+/virt/kvm/arm/mmu.c:1923:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/block/bfq-iosched.c:1649:	struct bfq_io_cq *bic = bfq_bic_lookup(bfqd, current->io_context, q);
linux-4.15.18+/block/bfq-iosched.c:4064:		bfq_init_bfqq(bfqd, bfqq, bic, current->pid,
linux-4.15.18+/block/bfq-iosched.c:4553:		bfqq->pid = current->pid;
linux-4.15.18+/virt/kvm/kvm_main.c:491:	return mmu_notifier_register(&kvm->mmu_notifier, current->mm);
linux-4.15.18+/virt/kvm/kvm_main.c:617:	mmgrab(current->mm);
linux-4.15.18+/virt/kvm/kvm_main.c:618:	kvm->mm = current->mm;
linux-4.15.18+/virt/kvm/kvm_main.c:690:	mmdrop(current->mm);
linux-4.15.18+/virt/kvm/kvm_main.c:1237:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/kvm_main.c:1238:	vma = find_vma(current->mm, addr);
linux-4.15.18+/virt/kvm/kvm_main.c:1245:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/kvm_main.c:1392:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/kvm_main.c:1394:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/kvm_main.c:1448:		r = fixup_user_fault(current, current->mm, addr,
linux-4.15.18+/virt/kvm/kvm_main.c:1514:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/kvm_main.c:1522:	vma = find_vma_intersection(current->mm, addr, addr + 1);
linux-4.15.18+/virt/kvm/kvm_main.c:1538:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/virt/kvm/kvm_main.c:2086:	sigprocmask(SIG_SETMASK, &vcpu->sigset, &current->real_blocked);
linux-4.15.18+/virt/kvm/kvm_main.c:2094:	sigprocmask(SIG_SETMASK, &current->real_blocked, NULL);
linux-4.15.18+/virt/kvm/kvm_main.c:2095:	sigemptyset(&current->real_blocked);
linux-4.15.18+/virt/kvm/kvm_main.c:2546:	if (vcpu->kvm->mm != current->mm)
linux-4.15.18+/virt/kvm/kvm_main.c:2572:		if (unlikely(oldpid != current->pids[PIDTYPE_PID].pid)) {
linux-4.15.18+/virt/kvm/kvm_main.c:2750:	if (vcpu->kvm->mm != current->mm)
linux-4.15.18+/virt/kvm/kvm_main.c:2966:	if (kvm->mm != current->mm)
linux-4.15.18+/virt/kvm/kvm_main.c:3143:	if (kvm->mm != current->mm)
linux-4.15.18+/virt/kvm/kvm_main.c:3987:	if (current->state == TASK_RUNNING)
linux-4.15.18+/samples/kprobes/kretprobe_example.c:43:	if (!current->mm)
linux-4.15.18+/init/do_mounts.c:371:	s = current->fs->pwd.dentry->d_sb;
linux-4.15.18+/init/do_mounts_initrd.c:73:	current->flags |= PF_FREEZER_SKIP;
linux-4.15.18+/init/do_mounts_initrd.c:81:	current->flags &= ~PF_FREEZER_SKIP;
linux-4.15.18+/Documentation/admin-guide/bug-hunting.rst:345:	Aug 29 09:51:01 blizard kernel: current->tss.cr3 = 0062d000, %cr3 = 0062d000
linux-4.15.18+/Documentation/devicetree/bindings/marvell.txt:209:     - current-speed : The current speed setting (presumably by
linux-4.15.18+/Documentation/devicetree/bindings/marvell.txt:218:	     current-speed = <9600>;
linux-4.15.18+/Documentation/devicetree/bindings/iio/health/max30100.txt:15:  - maxim,led-current-microamp: configuration for LED current in microamperes
linux-4.15.18+/Documentation/devicetree/bindings/iio/health/max30100.txt:26:	maxim,led-current-microamp = <24000 50000>;
linux-4.15.18+/Documentation/devicetree/bindings/iio/health/max30102.txt:15:  - maxim,red-led-current-microamp: configuration for RED LED current
linux-4.15.18+/Documentation/devicetree/bindings/iio/health/max30102.txt:16:  - maxim,ir-led-current-microamp: configuration for IR LED current
linux-4.15.18+/Documentation/devicetree/bindings/iio/health/max30102.txt:26:	maxim,red-led-current-microamp = <7000>;
linux-4.15.18+/Documentation/devicetree/bindings/iio/health/max30102.txt:27:	maxim,ir-led-current-microamp = <7000>;
linux-4.15.18+/Documentation/devicetree/bindings/iio/adc/palmas-gpadc.txt:26:ti,channel0-current-microamp: Channel 0 current in uA.
linux-4.15.18+/Documentation/devicetree/bindings/iio/adc/palmas-gpadc.txt:28:ti,channel3-current-microamp: Channel 3 current in uA.
linux-4.15.18+/Documentation/devicetree/bindings/iio/adc/palmas-gpadc.txt:43:		ti,channel0-current-microamp = <5>;
linux-4.15.18+/Documentation/devicetree/bindings/iio/adc/palmas-gpadc.txt:44:		ti,channel3-current-microamp = <10>;
linux-4.15.18+/Documentation/devicetree/bindings/iio/adc/max9611.txt:26:A sense resistor of 0,005 Ohm is installed between RS+ and RS- current-sensing
linux-4.15.18+/Documentation/devicetree/bindings/iio/dac/ad5755.txt:55: - adi,ext-current-sense-resistor: boolean set if the hardware a external
linux-4.15.18+/Documentation/devicetree/bindings/iio/dac/ad5755.txt:103:		adi,ext-current-sense-resistor;
linux-4.15.18+/Documentation/devicetree/bindings/iio/dac/ad5755.txt:109:		adi,ext-current-sense-resistor;
linux-4.15.18+/Documentation/devicetree/bindings/iio/dac/ad5755.txt:115:		adi,ext-current-sense-resistor;
linux-4.15.18+/Documentation/devicetree/bindings/iio/dac/ad5755.txt:121:		adi,ext-current-sense-resistor;
linux-4.15.18+/Documentation/devicetree/bindings/xilinx.txt:82:		current-speed = <d#115200>;	// standard serial device prop
linux-4.15.18+/Documentation/devicetree/bindings/xilinx.txt:269:       - current-speed : Baud rate of uartlite
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/battery.txt:21: - precharge-current-microamp: current for pre-charge phase
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/battery.txt:22: - charge-term-current-microamp: current for charge termination phase
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/battery.txt:23: - constant-charge-current-max-microamp: maximum constant input current
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/battery.txt:41:		precharge-current-microamp = <256000>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/battery.txt:42:		charge-term-current-microamp = <128000>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/battery.txt:43:		constant-charge-current-max-microamp = <900000>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/qcom,coincell-charger.txt:20:	Definition: resistance (in ohms) for current-limiting resistor
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/bq2415x.txt:18:- ti,current-limit:	   integer, initial maximum current charger can pull
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/bq2415x.txt:39:	ti,current-limit = <100>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/rt9455_charger.txt:28:- richtek,avg-input-current-regulation: integer, input current value in uA drained by the
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/rt9455_charger.txt:47:	richtek,avg-input-current-regulation = <500000>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/bq24257.txt:24:- ti,current-limit: The maximum current to be drawn from the charger's input
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/bq24257.txt:61:	ti,current-limit = <900000>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/tps65090.txt:7:-ti,enable-low-current-chrg: Enables charging when a low current is detected
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/tps65090.txt:16:		ti,enable-low-current-chrg;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/qcom_smbb.txt:43:- qcom,fast-charge-current-limit:
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/qcom_smbb.txt:74:               'qcom,fast-charge-current-limit' will be clamped by this value.
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/qcom_smbb.txt:88:- qcom,dc-current-limit:
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/qcom_smbb.txt:145:       qcom,fast-charge-current-limit = <1000000>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/qcom_smbb.txt:146:       qcom,dc-charge-current-limit = <1000000>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/max17042_battery.txt:10:   Defining this property enables current-sense functionality.
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/bq24190.txt:13:    + precharge-current-microamp: maximum charge current during precharge
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/bq24190.txt:15:    + charge-term-current-microamp: a charge cycle terminates when the
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/bq24190.txt:31:		precharge-current-microamp = <256000>;
linux-4.15.18+/Documentation/devicetree/bindings/power/supply/bq24190.txt:32:		charge-term-current-microamp = <128000>;
linux-4.15.18+/Documentation/devicetree/bindings/serial/cavium-uart.txt:11:- current-speed: Optional, the current bit rate in bits per second.
linux-4.15.18+/Documentation/devicetree/bindings/serial/cavium-uart.txt:17:		current-speed = <115200>;
linux-4.15.18+/Documentation/devicetree/bindings/serial/arm_sbsa_uart.txt:10:- current-speed: the (fixed) baud rate set by the firmware
linux-4.15.18+/Documentation/devicetree/bindings/serial/arc-uart.txt:8:- current-speed		: baud rate for UART
linux-4.15.18+/Documentation/devicetree/bindings/serial/arc-uart.txt:17:	current-speed = <115200>;
linux-4.15.18+/Documentation/devicetree/bindings/serial/8250.txt:37:- current-speed : the current active speed of the UART.
linux-4.15.18+/Documentation/devicetree/bindings/serial/slave-device.txt:24:- current-speed	: The current baud rate the device operates at. This should
linux-4.15.18+/Documentation/devicetree/bindings/leds/backlight/sky81452-backlight.txt:17:- skyworks,current-limit-mA
linux-4.15.18+/Documentation/devicetree/bindings/leds/backlight/sky81452-backlight.txt:28:		skyworks,current-limit-mA = <2300>;
linux-4.15.18+/Documentation/devicetree/bindings/leds/backlight/pm8941-wled.txt:14:- qcom,current-limit: mA; per-string current limit; value from 0 to 25
linux-4.15.18+/Documentation/devicetree/bindings/leds/backlight/pm8941-wled.txt:16:- qcom,current-boost-limit: mA; boost current limit; one of:
linux-4.15.18+/Documentation/devicetree/bindings/leds/backlight/pm8941-wled.txt:37:	qcom,current-limit = <20>;
linux-4.15.18+/Documentation/devicetree/bindings/leds/backlight/pm8941-wled.txt:38:	qcom,current-boost-limit = <805>;
linux-4.15.18+/Documentation/devicetree/bindings/usb/usb251xb.txt:48: - sp-max-total-current-microamp: Specifies max current consumed by the hub
linux-4.15.18+/Documentation/devicetree/bindings/usb/usb251xb.txt:52: - bp-max-total-current-microamp: Specifies max current consumed by the hub
linux-4.15.18+/Documentation/devicetree/bindings/usb/usb251xb.txt:56: - sp-max-removable-current-microamp: Specifies max current consumed by the hub
linux-4.15.18+/Documentation/devicetree/bindings/usb/usb251xb.txt:60: - bp-max-removable-current-microamp: Specifies max current consumed by the hub
linux-4.15.18+/Documentation/devicetree/bindings/usb/ci-hdrc-usb2.txt:84:- over-current-active-high: over current signal polarity is high active,
linux-4.15.18+/Documentation/devicetree/bindings/net/qca,qca7000.txt:69:- current-speed     : current baud rate of QCA7000 which defaults to 115200
linux-4.15.18+/Documentation/devicetree/bindings/net/qca,qca7000.txt:84:		current-speed = <38400>;
linux-4.15.18+/Documentation/devicetree/bindings/opp/opp.txt:4:Devices work at voltage-current-frequency combinations and some implementations
linux-4.15.18+/Documentation/devicetree/bindings/opp/opp.txt:61:- OPP nodes: One or more OPP nodes describing voltage-current-frequency
linux-4.15.18+/Documentation/devicetree/bindings/opp/opp.txt:76:This defines voltage-current-frequency combinations along with other related
linux-4.15.18+/Documentation/devicetree/bindings/mfd/sky81452.txt:25:			skyworks,current-limit = <2300>;
linux-4.15.18+/Documentation/devicetree/bindings/mfd/zii,rave-sp.txt:16: - current-speed: Should be set to baud rate SP device is using
linux-4.15.18+/Documentation/devicetree/bindings/mfd/zii,rave-sp.txt:33:		current-speed = <1000000>;
linux-4.15.18+/Documentation/devicetree/bindings/mfd/max77693.txt:67:  - maxim,battery-overcurrent-microamp : Overcurrent protection threshold
linux-4.15.18+/Documentation/devicetree/bindings/mfd/max77693.txt:177:			maxim,battery-overcurrent-microamp = <3000000>;
linux-4.15.18+/Documentation/devicetree/bindings/powerpc/fsl/mpc5200.txt:164:- current-speed   - Specifies that the MII should be configured for a fixed
linux-4.15.18+/Documentation/devicetree/bindings/regulator/tps65090.txt:24:- ti,overcurrent-wait: This is applicable to FET registers, which have a
linux-4.15.18+/Documentation/devicetree/bindings/regulator/regulator.txt:10:- regulator-input-current-limit-microamp: maximum input current regulator allows
linux-4.15.18+/Documentation/devicetree/bindings/regulator/regulator.txt:57:- regulator-over-current-protection: Enable over current protection.
linux-4.15.18+/Documentation/devicetree/bindings/pinctrl/oxnas,pinctrl.txt:51:	current-speed = <115200>;
linux-4.15.18+/Documentation/devicetree/bindings/sound/st,sta350.txt:63:  -  st,overcurrent-warning-adjustment:
linux-4.15.18+/Documentation/static-keys.txt:225:        pid = task_tgid_vnr(rcu_dereference(current->real_parent));
linux-4.15.18+/Documentation/robust-futexes.txt:97:the cost of robust futexes is just a simple current->robust_list != NULL
linux-4.15.18+/Documentation/robust-futexes.txt:181:current->robust_list. [Note that in the future, if robust futexes become
linux-4.15.18+/Documentation/memory-barriers.txt:2134:	    STORE current->state
linux-4.15.18+/Documentation/memory-barriers.txt:2175:	    STORE current->state	  <write barrier>
linux-4.15.18+/Documentation/memory-barriers.txt:2176:	    <general barrier>		  STORE current->state
linux-4.15.18+/Documentation/md/md-cluster.txt:61: Normally all nodes hold a concurrent-read lock on this device.
linux-4.15.18+/Documentation/md/md-cluster.txt:118: 1. receive status - all nodes have concurrent-reader lock on "ack".
linux-4.15.18+/Documentation/translations/zh_CN/oops-tracing.txt:161:Aug 29 09:51:01 blizard kernel: current->tss.cr3 = 0062d000, %cr3 = 0062d000
linux-4.15.18+/Documentation/translations/ko_KR/memory-barriers.txt:2104:	    STORE current->state
linux-4.15.18+/Documentation/translations/ko_KR/memory-barriers.txt:2146:	    STORE current->state	  < >
linux-4.15.18+/Documentation/translations/ko_KR/memory-barriers.txt:2147:	    < >		  STORE current->state
linux-4.15.18+/Documentation/hwmon/max16065:36:current-sense amplifier. The MAX16065 manages up to twelve system voltages
linux-4.15.18+/Documentation/hwmon/max16065:47:one current channel using a dedicated high-side current-sense amplifier. The
linux-4.15.18+/Documentation/ABI/testing/sysfs-class-led-driver-lm3533:7:		ALS-current-control mode (1, 2), where
linux-4.15.18+/Documentation/ABI/testing/sysfs-class-led-driver-lm3533:17:		Enable ALS-current-control mode (0, 1).
linux-4.15.18+/Documentation/ABI/testing/sysfs-class-backlight-driver-lm3533:7:		ALS-current-control mode (0, 1), where
linux-4.15.18+/Documentation/ABI/testing/sysfs-class-backlight-driver-lm3533:17:		Enable ALS-current-control mode (0, 1).
linux-4.15.18+/Documentation/media/uapi/v4l/nv12mt.svg:45:     inkscape:current-layer="svg2" /><defs
linux-4.15.18+/Documentation/media/uapi/v4l/vbi_625.svg:42:     inkscape:current-layer="g10"
linux-4.15.18+/Documentation/media/uapi/v4l/subdev-image-processing-crop.svg:54:     inkscape:current-layer="svg2" />
linux-4.15.18+/Documentation/media/uapi/v4l/nv12mt_example.svg:45:     inkscape:current-layer="svg2" /><defs
linux-4.15.18+/Documentation/media/uapi/v4l/crop.svg:67:     inkscape:current-layer="g10"
linux-4.15.18+/Documentation/media/uapi/v4l/subdev-image-processing-scaling-multi-source.svg:54:     inkscape:current-layer="svg2" />
linux-4.15.18+/Documentation/media/uapi/v4l/vbi_hsync.svg:38:     inkscape:current-layer="g10"
linux-4.15.18+/Documentation/media/uapi/v4l/subdev-image-processing-full.svg:54:     inkscape:current-layer="svg2" />
linux-4.15.18+/Documentation/media/uapi/v4l/fieldseq_tb.svg:43:     inkscape:current-layer="g5551" /><metadata
linux-4.15.18+/Documentation/media/uapi/v4l/vbi_525.svg:42:     inkscape:current-layer="g10"
linux-4.15.18+/Documentation/media/uapi/v4l/fieldseq_bt.svg:43:     inkscape:current-layer="g3627" /><metadata
linux-4.15.18+/Documentation/security/credentials.rst:440:this locks current->cred_replace_mutex and then allocates and constructs a
linux-4.15.18+/Documentation/security/credentials.rst:462:actually commit the new credentials to ``current->cred``, it will release
linux-4.15.18+/Documentation/security/credentials.rst:463:``current->cred_replace_mutex`` to allow ``ptrace()`` to take place, and it
linux-4.15.18+/Documentation/security/credentials.rst:482:This releases the lock on ``current->cred_replace_mutex`` that
linux-4.15.18+/Documentation/filesystems/caching/cachefiles.txt:410:its own task_security structure, and redirects current->cred to point to it
linux-4.15.18+/Documentation/filesystems/path-lookup.txt:50:current->fs->cwd or current->fs->root) as the first parent of the lookup. Then
linux-4.15.18+/Documentation/filesystems/path-lookup.txt:241:start from current->fs->root, which is a pinned dentry. Alternatively,
linux-4.15.18+/Documentation/RCU/Design/Requirements/GPpartitionReaders1.svg:60:     inkscape:current-layer="layer1"
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/TreeMappingLevel.svg:70:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Requirements/ReadersPartitionGP1.svg:88:     inkscape:current-layer="g4433-6"
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/BigTreePreemptRCUBHdyntick.svg:70:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/blkd_task.svg:70:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/BigTreeClassicRCU.svg:70:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/TreeLevel.svg:70:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/BigTreeClassicRCUBHdyntick.svg:83:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/TreeMapping.svg:96:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/HugeTreeClassicRCU.svg:70:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/BigTreePreemptRCUBHdyntickCB.svg:70:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-dyntick.svg:435:     inkscape:current-layer="svg2"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-gp-init-2.svg:267:     inkscape:current-layer="svg2"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-callback-invocation.svg:197:     inkscape:current-layer="g3058"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-hotplug.svg:435:     inkscape:current-layer="svg2"
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/nxtlist.svg:70:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Data-Structures/BigTreeClassicRCUBH.svg:83:     inkscape:current-layer="g4" />
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-gp-cleanup.svg:393:     inkscape:current-layer="g3188-3"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-gp-init-3.svg:267:     inkscape:current-layer="svg2"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-gp-init-1.svg:281:     inkscape:current-layer="svg2"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/rcu_node-lock.svg:71:     inkscape:current-layer="g4"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel4.svg:88:     inkscape:current-layer="layer1"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel3.svg:88:     inkscape:current-layer="layer1"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-qs.svg:309:     inkscape:current-layer="g4405"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-gp-fqs.svg:491:     inkscape:current-layer="svg2"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-callback-registry.svg:197:     inkscape:current-layer="g4"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel2.svg:88:     inkscape:current-layer="g3997-7"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel8.svg:88:     inkscape:current-layer="layer1"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel5.svg:88:     inkscape:current-layer="layer1"
linux-4.15.18+/Documentation/vm/active_mm.txt:66:	if (current->mm == &init_mm)
linux-4.15.18+/Documentation/vm/active_mm.txt:70:	if (!current->mm)
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/ExpSchedFlow.svg:337:     inkscape:current-layer="g4114-9-3-9"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel1.svg:88:     inkscape:current-layer="g3997-7"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel6.svg:88:     inkscape:current-layer="layer1"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel7.svg:88:     inkscape:current-layer="layer1"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/Funnel0.svg:88:     inkscape:current-layer="layer1"
linux-4.15.18+/Documentation/RCU/Design/Memory-Ordering/TreeRCU-gp.svg:1079:     inkscape:current-layer="svg2"
linux-4.15.18+/Documentation/RCU/Design/Expedited-Grace-Periods/ExpRCUFlow.svg:323:     inkscape:current-layer="g4"
linux-4.15.18+/Documentation/mn10300/ABI.txt:122:	MOV	(yyy,Rm)	// Access current->yyy
linux-4.15.18+/Documentation/mn10300/ABI.txt:127:	MOV	(yyy,E2)	// Access current->yyy
linux-4.15.18+/include/xen/interface/grant_table.h:41: * NB. WMB is a no-op on current-generation x86 processors. However, a
linux-4.15.18+/include/uapi/linux/prctl.h:12:/* Get/set current->mm->dumpable */
linux-4.15.18+/include/uapi/linux/bpf.h:391: *     Return: current->tgid << 32 | current->pid
linux-4.15.18+/include/uapi/linux/bpf.h:397: *     stores current->comm into buf
linux-4.15.18+/include/linux/wait.h:493:				       current->timer_slack_ns,			\
linux-4.15.18+/include/linux/lockdep.h:603:		WARN_ONCE(debug_locks && !current->lockdep_recursion &&	\
linux-4.15.18+/include/linux/lockdep.h:604:			  !current->hardirqs_enabled,			\
linux-4.15.18+/include/linux/lockdep.h:609:		WARN_ONCE(debug_locks && !current->lockdep_recursion &&	\
linux-4.15.18+/include/linux/lockdep.h:610:			  current->hardirqs_enabled,			\
linux-4.15.18+/include/linux/sched/mm.h:164:	if (unlikely(current->flags & PF_MEMALLOC_NOIO))
linux-4.15.18+/include/linux/sched/mm.h:166:	else if (unlikely(current->flags & PF_MEMALLOC_NOFS))
linux-4.15.18+/include/linux/sched/mm.h:181:	unsigned int flags = current->flags & PF_MEMALLOC_NOIO;
linux-4.15.18+/include/linux/sched/mm.h:182:	current->flags |= PF_MEMALLOC_NOIO;
linux-4.15.18+/include/linux/sched/mm.h:188:	current->flags = (current->flags & ~PF_MEMALLOC_NOIO) | flags;
linux-4.15.18+/include/linux/sched/mm.h:193:	unsigned int flags = current->flags & PF_MEMALLOC_NOFS;
linux-4.15.18+/include/linux/sched/mm.h:194:	current->flags |= PF_MEMALLOC_NOFS;
linux-4.15.18+/include/linux/sched/mm.h:200:	current->flags = (current->flags & ~PF_MEMALLOC_NOFS) | flags;
linux-4.15.18+/include/linux/sched/mm.h:205:	unsigned int flags = current->flags & PF_MEMALLOC;
linux-4.15.18+/include/linux/sched/mm.h:206:	current->flags |= PF_MEMALLOC;
linux-4.15.18+/include/linux/sched/mm.h:212:	current->flags = (current->flags & ~PF_MEMALLOC) | flags;
linux-4.15.18+/include/linux/sched/signal.h:195:	 * getrlimit/setrlimit use task_lock(current->group_leader) to
linux-4.15.18+/include/linux/sched/signal.h:281:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/include/linux/sched/signal.h:282:	if (current->jobctl & JOBCTL_STOP_DEQUEUED)
linux-4.15.18+/include/linux/sched/signal.h:284:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/include/linux/sched/signal.h:398:	current->restore_sigmask = true;
linux-4.15.18+/include/linux/sched/signal.h:403:	current->restore_sigmask = false;
linux-4.15.18+/include/linux/sched/signal.h:407:	return current->restore_sigmask;
linux-4.15.18+/include/linux/sched/signal.h:411:	if (!current->restore_sigmask)
linux-4.15.18+/include/linux/sched/signal.h:413:	current->restore_sigmask = false;
linux-4.15.18+/include/linux/sched/signal.h:421:		__set_current_blocked(&current->saved_sigmask);
linux-4.15.18+/include/linux/sched/signal.h:426:	sigset_t *res = &current->blocked;
linux-4.15.18+/include/linux/sched/signal.h:428:		res = &current->saved_sigmask;
linux-4.15.18+/include/linux/sched/signal.h:456:	if (current->sas_ss_flags & SS_AUTODISARM)
linux-4.15.18+/include/linux/sched/signal.h:460:	return sp >= current->sas_ss_sp &&
linux-4.15.18+/include/linux/sched/signal.h:461:		sp - current->sas_ss_sp < current->sas_ss_size;
linux-4.15.18+/include/linux/sched/signal.h:463:	return sp > current->sas_ss_sp &&
linux-4.15.18+/include/linux/sched/signal.h:464:		sp - current->sas_ss_sp <= current->sas_ss_size;
linux-4.15.18+/include/linux/sched/signal.h:470:	if (!current->sas_ss_size)
linux-4.15.18+/include/linux/sched/signal.h:487:		return current->sas_ss_sp;
linux-4.15.18+/include/linux/sched/signal.h:489:		return current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/include/linux/delayacct.h:25: * Used to set current->delays->flags
linux-4.15.18+/include/linux/delayacct.h:90:	if (current->delays)
linux-4.15.18+/include/linux/delayacct.h:91:		current->delays->flags |= flag;
linux-4.15.18+/include/linux/delayacct.h:96:	if (current->delays)
linux-4.15.18+/include/linux/delayacct.h:97:		current->delays->flags &= ~flag;
linux-4.15.18+/include/linux/delayacct.h:121:	if (current->delays)
linux-4.15.18+/include/linux/delayacct.h:127:	if (current->delays)
linux-4.15.18+/include/linux/delayacct.h:149:	if (current->delays)
linux-4.15.18+/include/linux/delayacct.h:155:	if (current->delays)
linux-4.15.18+/include/linux/cpuset.h:61:#define cpuset_current_mems_allowed (current->mems_allowed)
linux-4.15.18+/include/linux/cpuset.h:133:	return read_seqcount_begin(&current->mems_allowed_seq);
linux-4.15.18+/include/linux/cpuset.h:147:	return read_seqcount_retry(&current->mems_allowed_seq, seq);
linux-4.15.18+/include/linux/cpuset.h:156:	write_seqcount_begin(&current->mems_allowed_seq);
linux-4.15.18+/include/linux/cpuset.h:157:	current->mems_allowed = nodemask;
linux-4.15.18+/include/linux/cpuset.h:158:	write_seqcount_end(&current->mems_allowed_seq);
linux-4.15.18+/include/linux/freezer.h:65:	if (!(current->flags & PF_NOFREEZE))
linux-4.15.18+/include/linux/freezer.h:109:	current->flags |= PF_FREEZER_SKIP;
linux-4.15.18+/include/linux/freezer.h:121:	current->flags &= ~PF_FREEZER_SKIP;
linux-4.15.18+/include/linux/freezer.h:134:	current->flags &= ~PF_FREEZER_SKIP;
linux-4.15.18+/include/linux/power/max8903_charger.h:38:	int dcm;	/* Current-Limit Mode input (1: DC, 2: USB) */
linux-4.15.18+/include/linux/cred.h:276:	rcu_dereference_protected(current->cred, 1)
linux-4.15.18+/include/linux/cred.h:285:	rcu_dereference_protected(current->real_cred, 1)
linux-4.15.18+/include/linux/filter.h:774:	       proglen, pass, image, current->comm, task_pid_nr(current));
linux-4.15.18+/include/linux/kernel.h:228:# define sched_annotate_sleep()	(current->task_state_change = 0)
linux-4.15.18+/include/linux/usb/tcpm.h:134: *		current-limit detection method for the cc=Rp-def case.
linux-4.15.18+/include/linux/lsm_hooks.h:65: *	pointed to by @current->cred and the information set in @bprm->cred by
linux-4.15.18+/include/linux/lsm_hooks.h:74: *	have, by this point, been set to @current->cred.  @bprm points to the
linux-4.15.18+/include/linux/lsm_hooks.h:505: *	Save owner security information (typically from current->security) in
linux-4.15.18+/include/linux/lsm_hooks.h:594: *	should be made to this rather than to @current->cred.
linux-4.15.18+/include/linux/sched.h:118:		current->task_state_change = _THIS_IP_;		\
linux-4.15.18+/include/linux/sched.h:119:		current->state = (state_value);			\
linux-4.15.18+/include/linux/sched.h:123:		current->task_state_change = _THIS_IP_;		\
linux-4.15.18+/include/linux/sched.h:124:		smp_store_mb(current->state, (state_value));	\
linux-4.15.18+/include/linux/sched.h:129: * set_current_state() includes a barrier so that the write of current->state
linux-4.15.18+/include/linux/sched.h:162:#define __set_current_state(state_value) do { current->state = (state_value); } while (0)
linux-4.15.18+/include/linux/sched.h:163:#define set_current_state(state_value)	 smp_store_mb(current->state, (state_value))
linux-4.15.18+/include/linux/sched.h:1336:	do { (child)->flags &= ~PF_USED_MATH, (child)->flags |= current->flags & PF_USED_MATH; } while (0)
linux-4.15.18+/include/linux/sched.h:1345:	return (current->flags & PF_NO_SETAFFINITY) &&
linux-4.15.18+/include/linux/sched.h:1346:		(current->nr_cpus_allowed  == 1);
linux-4.15.18+/include/linux/sched.h:1384:	current->flags &= ~flags;
linux-4.15.18+/include/linux/sched.h:1385:	current->flags |= orig_flags & flags;
linux-4.15.18+/include/linux/suspend.h:448:	current->flags |= PF_FREEZER_SKIP;
linux-4.15.18+/include/linux/suspend.h:469:	current->flags &= ~PF_FREEZER_SKIP;
linux-4.15.18+/include/linux/task_io_accounting_ops.h:13:	current->ioac.read_bytes += bytes;
linux-4.15.18+/include/linux/task_io_accounting_ops.h:27:	current->ioac.write_bytes += bytes;
linux-4.15.18+/include/linux/task_io_accounting_ops.h:41:	current->ioac.cancelled_write_bytes += bytes;
linux-4.15.18+/include/linux/rcuwait.h:45:	WARN_ON(current->exit_state);                                   \
linux-4.15.18+/include/linux/tracehook.h:61:	int ptrace = current->ptrace;
linux-4.15.18+/include/linux/tracehook.h:73:	if (current->exit_code) {
linux-4.15.18+/include/linux/tracehook.h:74:		send_sig(current->exit_code, current, 1);
linux-4.15.18+/include/linux/tracehook.h:75:		current->exit_code = 0;
linux-4.15.18+/include/linux/tracehook.h:190:	if (unlikely(current->task_works))
linux-4.15.18+/include/linux/memcontrol.h:466:	WARN_ON(current->memcg_may_oom);
linux-4.15.18+/include/linux/memcontrol.h:467:	current->memcg_may_oom = 1;
linux-4.15.18+/include/linux/memcontrol.h:472:	WARN_ON(!current->memcg_may_oom);
linux-4.15.18+/include/linux/memcontrol.h:473:	current->memcg_may_oom = 0;
linux-4.15.18+/include/linux/uaccess.h:171:	current->pagefault_disabled++;
linux-4.15.18+/include/linux/uaccess.h:176:	current->pagefault_disabled--;
linux-4.15.18+/include/linux/uaccess.h:209:#define pagefault_disabled() (current->pagefault_disabled != 0)
linux-4.15.18+/include/linux/ptrace.h:151:		current->ptrace_message = message;
linux-4.15.18+/include/linux/ptrace.h:155:		if ((current->ptrace & (PT_PTRACED|PT_SEIZED)) == PT_PTRACED)
linux-4.15.18+/include/linux/ptrace.h:183:	ns = task_active_pid_ns(rcu_dereference(current->parent));
linux-4.15.18+/include/linux/ptrace.h:209:	if (unlikely(ptrace) && current->ptrace) {
linux-4.15.18+/include/linux/ptrace.h:210:		child->ptrace = current->ptrace;
linux-4.15.18+/include/linux/ptrace.h:211:		__ptrace_link(child, current->parent, current->ptracer_cred);
linux-4.15.18+/include/linux/ptrace.h:356: * @code:	current->exit_code value ptrace will stop with
linux-4.15.18+/include/linux/ptrace.h:377: * @code:	current->exit_code value ptrace will stop with
linux-4.15.18+/include/linux/cgroup.h:637:	current->no_cgroup_migration = 1;
linux-4.15.18+/include/linux/cgroup.h:646:	current->no_cgroup_migration = 0;
linux-4.15.18+/include/linux/fdtable.h:104:#define fcheck(fd)	fcheck_files(current->files, fd)
linux-4.15.18+/include/linux/mm_types.h:456:	 * current->mm != mm
linux-4.15.18+/include/linux/utsname.h:76:	return &current->nsproxy->uts_ns->name;
linux-4.15.18+/include/linux/irqflags.h:29:	current->hardirq_context++;		\
linux-4.15.18+/include/linux/irqflags.h:33:	current->hardirq_context--;		\
linux-4.15.18+/include/linux/irqflags.h:37:	current->softirq_context++;		\
linux-4.15.18+/include/linux/irqflags.h:41:	current->softirq_context--;		\
linux-4.15.18+/include/linux/ratelimit.h:63:			current->comm, rs->missed);
linux-4.15.18+/include/linux/ftrace.h:839:	atomic_inc(&current->tracing_graph_pause);
linux-4.15.18+/include/linux/ftrace.h:844:	atomic_dec(&current->tracing_graph_pause);
linux-4.15.18+/include/linux/ftrace.h:880:/* flags for current->trace */
linux-4.15.18+/include/linux/personality.h:15:#define set_personality(pers)	(current->personality = (pers))
linux-4.15.18+/include/linux/binfmts.h:55:	unsigned int per_clear;	/* bits to clear in current->personality */
linux-4.15.18+/include/linux/jbd2.h:1336:	return current->journal_info;
linux-4.15.18+/include/linux/regulator/driver.h:91: * @set_current_limit: Configure a limit for a current-limited regulator.
linux-4.15.18+/include/linux/regulator/driver.h:93: * @get_current_limit: Get the configured limit for a current-limited regulator.
linux-4.15.18+/include/linux/rcupdate.h:76:#define rcu_preempt_depth() (current->rcu_read_lock_nesting)
linux-4.15.18+/include/linux/audit.h:242:	void *p = current->audit_context;
linux-4.15.18+/include/linux/audit.h:254:	if (unlikely(current->audit_context))
linux-4.15.18+/include/linux/audit.h:259:	if (unlikely(current->audit_context)) {
linux-4.15.18+/include/linux/swap.h:35:	return current->flags & PF_KSWAPD;
linux-4.15.18+/include/linux/swap.h:126: * current->reclaim_state points to one of these when a task is running
linux-4.15.18+/include/linux/elf.h:16:	set_personality(PER_LINUX | (current->personality & (~PER_MASK)))
linux-4.15.18+/include/linux/oom.h:51:	current->signal->oom_flag_origin = true;
linux-4.15.18+/include/linux/oom.h:56:	current->signal->oom_flag_origin = false;
linux-4.15.18+/include/linux/context_tracking.h:109:		current->flags |= PF_VCPU;
linux-4.15.18+/include/linux/context_tracking.h:133:		current->flags &= ~PF_VCPU;
linux-4.15.18+/include/linux/context_tracking.h:145:	current->flags |= PF_VCPU;
linux-4.15.18+/include/linux/context_tracking.h:153:	current->flags &= ~PF_VCPU;
linux-4.15.18+/include/net/xfrm.h:739:	audit_buf = audit_log_start(current->audit_context, GFP_ATOMIC,
linux-4.15.18+/include/net/sock.h:2143:		return &current->task_frag;
linux-4.15.18+/include/trace/events/block.h:172:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/block.h:244:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/block.h:309:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/block.h:376:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/block.h:405:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/block.h:467:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/block.h:486:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/block.h:539:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/sched.h:261:		memcpy(__entry->comm, current->comm, TASK_COMM_LEN);
linux-4.15.18+/include/trace/events/sched.h:263:		__entry->prio		= current->prio; /* XXX SCHED_DEADLINE */
linux-4.15.18+/include/trace/events/writeback.h:538:		__entry->dirtied_pause	= current->nr_dirtied_pause;
linux-4.15.18+/include/trace/events/writeback.h:539:		__entry->think		= current->dirty_paused_when == 0 ? 0 :
linux-4.15.18+/include/trace/events/writeback.h:540:			 (long)(jiffies - current->dirty_paused_when) * 1000/HZ;
linux-4.15.18+/net/netfilter/x_tables.c:1250:		audit_log(current->audit_context, GFP_KERNEL,
linux-4.15.18+/net/netfilter/nf_conntrack_core.c:1953:	if (current->nsproxy->net_ns != &init_net)
linux-4.15.18+/net/ceph/ceph_common.c:136:	if (!net_eq(current->nsproxy->net_ns, read_pnet(&client->msgr.net)))
linux-4.15.18+/net/ceph/messenger.c:3014:	write_pnet(&msgr->net, get_net(current->nsproxy->net_ns));
linux-4.15.18+/net/l2tp/l2tp_debugfs.c:271:	pd->net = get_net_ns_by_pid(current->pid);
linux-4.15.18+/net/l2tp/l2tp_ppp.c:584:	ps->owner = current->pid;
linux-4.15.18+/net/rxrpc/ar-internal.h:1151:	printk("[%-6.6s] "FMT"\n", current->comm ,##__VA_ARGS__)
linux-4.15.18+/net/9p/trans_fd.c:963:	err = __sock_create(current->nsproxy->net_ns, PF_INET,
linux-4.15.18+/net/9p/trans_fd.c:1011:	err = __sock_create(current->nsproxy->net_ns, PF_UNIX,
linux-4.15.18+/net/9p/client.c:808:		spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/net/9p/client.c:810:		spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/net/9p/client.c:889:		spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/net/9p/client.c:891:		spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/net/llc/af_llc.c:817:					    current->comm,
linux-4.15.18+/net/ipv4/raw.c:547:				     __func__, current->comm);
linux-4.15.18+/net/ipv4/ip_output.c:1482:			       &current->task_frag, getfrag,
linux-4.15.18+/net/ipv4/tcp.c:1940:					    current->comm,
linux-4.15.18+/net/ipv4/af_inet.c:423:		    !(current->flags & PF_EXITING))
linux-4.15.18+/net/rds/tcp.c:610:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/net/sysctl_net.c:32:	return &current->nsproxy->net_ns->sysctls;
linux-4.15.18+/net/sysctl_net.c:37:	return &current->nsproxy->net_ns->sysctls == set;
linux-4.15.18+/net/netlabel/netlabel_user.c:107:	audit_buf = audit_log_start(current->audit_context, GFP_ATOMIC, type);
linux-4.15.18+/net/sunrpc/sched.c:935:	task->tk_owner = current->tgid;
linux-4.15.18+/net/sunrpc/rpc_pipe.c:1450:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/net/sunrpc/svc.c:1118:	spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/net/sunrpc/svc.c:1120:	spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/net/sctp/sysctl.c:333:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/net/sctp/sysctl.c:379:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/net/sctp/sysctl.c:408:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/net/sctp/sysctl.c:448:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/net/appletalk/ddp.c:1208:			current->comm);
linux-4.15.18+/net/bpf/test_run.c:130:	skb->protocol = eth_type_trans(skb, current->nsproxy->net_ns->loopback_dev);
linux-4.15.18+/net/socket.c:1218:			     current->comm);
linux-4.15.18+/net/socket.c:1307:	return __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);
linux-4.15.18+/net/sctp/socket.c:2709:				    current->comm, task_pid_nr(current));
linux-4.15.18+/net/sctp/socket.c:3160:				    current->comm, task_pid_nr(current));
linux-4.15.18+/net/sctp/socket.c:3430:				    current->comm, task_pid_nr(current));
linux-4.15.18+/net/sctp/socket.c:5049:	if (!net_eq(current->nsproxy->net_ns, sock_net(sk)))
linux-4.15.18+/net/sctp/socket.c:5408:				    current->comm, task_pid_nr(current));
linux-4.15.18+/net/sctp/socket.c:6100:				    current->comm, task_pid_nr(current));
linux-4.15.18+/net/sctp/socket.c:6195:				    current->comm, task_pid_nr(current));
linux-4.15.18+/net/ax25/af_ax25.c:1216:			current->comm);
linux-4.15.18+/net/ax25/af_ax25.c:1797:					current->comm);
linux-4.15.18+/net/atm/ioctl.c:102:				     current->comm, task_pid_nr(current));
linux-4.15.18+/net/core/sock.c:394:				__func__, current->comm, task_pid_nr(current));
linux-4.15.18+/net/core/sock.c:410:	if (strcmp(warncomm, current->comm) && warned < 5) {
linux-4.15.18+/net/core/sock.c:411:		strcpy(warncomm,  current->comm);
linux-4.15.18+/net/core/net-sysfs.c:1433:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/net/core/net-sysfs.c:1440:	struct net *ns = current->nsproxy->net_ns;
linux-4.15.18+/net/core/skbuff.c:3383:	struct page_frag *pfrag = &current->task_frag;
linux-4.15.18+/net/core/pktgen.c:489:	struct pktgen_net *pn = net_generic(current->nsproxy->net_ns, pg_net_id);
linux-4.15.18+/net/core/netpoll.c:670:		struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/net/core/dev.c:6652:			audit_log(current->audit_context, GFP_ATOMIC,
linux-4.15.18+/net/ipv6/ndisc.c:1805:	if (strcmp(warncomm, current->comm) && warned < 5) {
linux-4.15.18+/net/ipv6/ndisc.c:1806:		strcpy(warncomm, current->comm);
linux-4.15.18+/net/ipv6/ip6_output.c:1765:				&current->task_frag, getfrag, from,
linux-4.15.18+/net/bridge/netfilter/ebtables.c:1068:		audit_log(current->audit_context, GFP_KERNEL,
linux-4.15.18+/net/bluetooth/sco.c:987:		    !(current->flags & PF_EXITING))
linux-4.15.18+/net/bluetooth/sco.c:1011:	    !(current->flags & PF_EXITING)) {
linux-4.15.18+/net/bluetooth/rfcomm/sock.c:928:		    !(current->flags & PF_EXITING))
linux-4.15.18+/net/bluetooth/l2cap_sock.c:1171:	    !(current->flags & PF_EXITING))
linux-4.15.18+/net/smc/smc_close.c:184:	timeout = current->flags & PF_EXITING ?
linux-4.15.18+/net/smc/smc_close.c:423:	timeout = current->flags & PF_EXITING ?
linux-4.15.18+/net/dns_resolver/internal.h:47:		       current->comm, ##__VA_ARGS__);	\
linux-4.15.18+/net/vmw_vsock/virtio_transport_common.c:764:	if (sock_flag(sk, SOCK_LINGER) && !(current->flags & PF_EXITING))
linux-4.15.18+/lib/fault-inject.c:111:		unsigned int fail_nth = READ_ONCE(current->fail_nth);
linux-4.15.18+/lib/fault-inject.c:114:			if (!WRITE_ONCE(current->fail_nth, fail_nth - 1))
linux-4.15.18+/lib/smp_processor_id.c:26:	if (cpumask_equal(&current->cpus_allowed, cpumask_of(this_cpu)))
linux-4.15.18+/lib/smp_processor_id.c:44:		what1, what2, preempt_count() - 1, current->comm, current->pid);
linux-4.15.18+/lib/ubsan.c:60:	return current->in_ubsan || was_reported(loc);
linux-4.15.18+/lib/ubsan.c:154:	current->in_ubsan++;
linux-4.15.18+/lib/ubsan.c:168:	current->in_ubsan--;
linux-4.15.18+/lib/nlattr.c:86:				    current->comm, type);
linux-4.15.18+/lib/nlattr.c:268:				    rem, current->comm);
linux-4.15.18+/lib/locking-selftest.c:1173:		current->softirqs_enabled = 0;
linux-4.15.18+/lib/locking-selftest.c:1175:		current->softirqs_enabled = 1;
linux-4.15.18+/lib/dma-debug.c:1197:			addr = (u8 *)current->stack + i * PAGE_SIZE + offset;
linux-4.15.18+/scripts/kconfig/gconf.c:711:	current = current->parent;
linux-4.15.18+/scripts/kconfig/gconf.c:712:	ptype = current->prompt ? current->prompt->type : P_UNKNOWN;
linux-4.15.18+/scripts/kconfig/gconf.c:714:		current = current->parent;
linux-4.15.18+/arch/blackfin/include/asm/page.h:15:	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
linux-4.15.18+/arch/blackfin/mm/sram-alloc.c:310:	pavail->pid = current->pid;
linux-4.15.18+/arch/blackfin/mm/sram-alloc.c:745:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/blackfin/mm/sram-alloc.c:769:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/blackfin/kernel/process.c:88:	if (current->mm)
linux-4.15.18+/arch/blackfin/kernel/process.c:89:		regs->p5 = current->mm->start_data;
linux-4.15.18+/arch/blackfin/kernel/process.c:92:		(void *)current->mm->context.stack_start;
linux-4.15.18+/arch/blackfin/kernel/process.c:108:	if (current->nr_cpus_allowed == num_possible_cpus())
linux-4.15.18+/arch/blackfin/kernel/signal.c:48:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/blackfin/kernel/signal.c:172:	if (current->personality & FDPIC_FUNCPTRS) {
linux-4.15.18+/arch/blackfin/kernel/signal.c:256:	current->thread.esp0 = (unsigned long)regs;
linux-4.15.18+/arch/blackfin/kernel/trace.c:156:					if (current->mm &&
linux-4.15.18+/arch/blackfin/kernel/trace.c:157:					    (address > current->mm->start_code) &&
linux-4.15.18+/arch/blackfin/kernel/trace.c:158:					    (address < current->mm->end_code))
linux-4.15.18+/arch/blackfin/kernel/trace.c:159:						offset = address - current->mm->start_code;
linux-4.15.18+/arch/blackfin/kernel/trace.c:758:	    !((unsigned long)current & 0x3) && current->pid) {
linux-4.15.18+/arch/blackfin/kernel/trace.c:760:		if (current->comm >= (char *)FIXED_CODE_START)
linux-4.15.18+/arch/blackfin/kernel/trace.c:762:				current->comm, current->pid);
linux-4.15.18+/arch/blackfin/kernel/trace.c:767:		if (!((unsigned long)current->mm & 0x3) &&
linux-4.15.18+/arch/blackfin/kernel/trace.c:768:			(unsigned long)current->mm >= FIXED_CODE_START) {
linux-4.15.18+/arch/blackfin/kernel/trace.c:770:				(void *)current->mm->start_code,
linux-4.15.18+/arch/blackfin/kernel/trace.c:771:				(void *)current->mm->end_code,
linux-4.15.18+/arch/blackfin/kernel/trace.c:772:				(void *)current->mm->start_data,
linux-4.15.18+/arch/blackfin/kernel/trace.c:773:				(void *)current->mm->end_data);
linux-4.15.18+/arch/blackfin/kernel/trace.c:775:				(void *)current->mm->end_data,
linux-4.15.18+/arch/blackfin/kernel/trace.c:776:				(void *)current->mm->brk,
linux-4.15.18+/arch/blackfin/kernel/trace.c:777:				(void *)current->mm->start_stack);
linux-4.15.18+/arch/blackfin/kernel/trace.c:834:		     (current->pid && current->mm)) {
linux-4.15.18+/arch/blackfin/kernel/trace.c:836:			if ((fp + 1)->pc >= current->mm->start_code &&
linux-4.15.18+/arch/blackfin/kernel/trace.c:837:			    (fp + 1)->pc <= current->mm->end_code) {
linux-4.15.18+/arch/blackfin/kernel/traps.c:432:	if (kernel_mode_regs(fp) || (current && !current->mm)) {
linux-4.15.18+/arch/blackfin/kernel/ftrace.c:106:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/blackfin/kernel/ftrace.c:117:		current->curr_ret_stack--;
linux-4.15.18+/arch/blackfin/kernel/flat.c:50:		return val + current->mm->context.end_brk;
linux-4.15.18+/arch/blackfin/kernel/ipipe.c:225:	if (current->ipipe_flags & PF_EVTRET) {
linux-4.15.18+/arch/blackfin/kernel/ipipe.c:226:		current->ipipe_flags &= ~PF_EVTRET;
linux-4.15.18+/arch/blackfin/mach-common/ints-priority.c:1339:	    (current->ipipe_flags & PF_EVTRET) != 0) {
linux-4.15.18+/arch/blackfin/mach-common/ints-priority.c:1351:		current->ipipe_flags &= ~PF_EVTRET;
linux-4.15.18+/arch/blackfin/mach-common/smp.c:313:	current->active_mm = mm;
linux-4.15.18+/arch/unicore32/mm/proc-macros.S:58: * act_mm - get current->active_mm
linux-4.15.18+/arch/unicore32/mm/mmu.c:459:	pgd = current->active_mm->pgd;
linux-4.15.18+/arch/unicore32/kernel/ptrace.c:122:	if (!(current->ptrace & PT_PTRACED))
linux-4.15.18+/arch/unicore32/kernel/ptrace.c:136:	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
linux-4.15.18+/arch/unicore32/kernel/ptrace.c:143:	if (current->exit_code) {
linux-4.15.18+/arch/unicore32/kernel/ptrace.c:144:		send_sig(current->exit_code, current, 1);
linux-4.15.18+/arch/unicore32/kernel/ptrace.c:145:		current->exit_code = 0;
linux-4.15.18+/arch/unicore32/kernel/process.c:202:			task_pid_nr(current), current->comm);
linux-4.15.18+/arch/unicore32/kernel/process.c:312:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/unicore32/kernel/traps.c:247:		current->thread.error_code = err;
linux-4.15.18+/arch/unicore32/kernel/traps.c:248:		current->thread.trap_no = trap;
linux-4.15.18+/arch/unicore32/kernel/signal.c:108:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/unicore32/kernel/signal.c:175:	err |= __put_user(current->thread.trap_no,
linux-4.15.18+/arch/unicore32/kernel/signal.c:177:	err |= __put_user(current->thread.error_code,
linux-4.15.18+/arch/unicore32/kernel/signal.c:179:	err |= __put_user(current->thread.address,
linux-4.15.18+/arch/unicore32/kernel/signal.c:198:		sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/unicore32/kernel/fpu-ucf64.c:69:	current->thread.error_code = 0;
linux-4.15.18+/arch/unicore32/kernel/fpu-ucf64.c:70:	current->thread.trap_no = 6;
linux-4.15.18+/arch/riscv/include/asm/elf.h:75:		(elf_addr_t)current->mm->context.vdso);		\
linux-4.15.18+/arch/riscv/kernel/smpboot.c:104:	current->active_mm = mm;
linux-4.15.18+/arch/riscv/kernel/process.c:92:	memset(&current->thread.fstate, 0, sizeof(current->thread.fstate));
linux-4.15.18+/arch/riscv/kernel/vdso.c:69:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/riscv/kernel/signal.c:44:	err = __copy_from_user(&current->thread.fstate, state, sizeof(*state));
linux-4.15.18+/arch/riscv/kernel/signal.c:54:	return __copy_to_user(state, &current->thread.fstate, sizeof(*state));
linux-4.15.18+/arch/riscv/kernel/signal.c:90:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/riscv/kernel/signal.c:185:		current->mm->context.vdso, rt_sigreturn);
linux-4.15.18+/arch/riscv/kernel/signal.c:202:		current->comm, task_pid_nr(current), ksig->sig,
linux-4.15.18+/arch/riscv/kernel/smp.c:150:	if (mm != current->active_mm || !local)
linux-4.15.18+/arch/riscv/kernel/sys_riscv.c:69:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/ia64/include/uapi/asm/fcntl.h:10:		(personality(current->personality) != PER_LINUX32)
linux-4.15.18+/arch/ia64/include/asm/tlbflush.h:42:	if (mm == current->active_mm)
linux-4.15.18+/arch/ia64/include/asm/tlbflush.h:81:	if (vma->vm_mm == current->active_mm)
linux-4.15.18+/arch/ia64/include/asm/switch_to.h:69:	if (unlikely((current->thread.flags & IA64_THREAD_MIGRATION) &&	       \
linux-4.15.18+/arch/ia64/include/asm/processor.h:41:#define TASK_UNMAPPED_BASE	(current->thread.map_base)
linux-4.15.18+/arch/ia64/include/asm/processor.h:316:	regs->ar_bspstore = current->thread.rbs_bot;						\
linux-4.15.18+/arch/ia64/include/asm/processor.h:319:	regs->r8 = get_dumpable(current->mm);	/* set "don't zap registers" flag */		\
linux-4.15.18+/arch/ia64/include/asm/processor.h:321:	if (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) {	\
linux-4.15.18+/arch/ia64/include/asm/user.h:17: *  data: The data segment follows next.  We use current->end_text to
linux-4.15.18+/arch/ia64/include/asm/user.h:18: *	current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/ia64/include/asm/user.h:25: *	current->start_stack, so we round each of these in order to be able
linux-4.15.18+/arch/ia64/include/asm/page.h:223:					 (((current->personality & READ_IMPLIES_EXEC) != 0)	\
linux-4.15.18+/arch/ia64/mm/fault.c:87:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/ia64/mm/fault.c:189:			current->maj_flt++;
linux-4.15.18+/arch/ia64/mm/fault.c:191:			current->min_flt++;
linux-4.15.18+/arch/ia64/mm/tlb.c:243:	struct mm_struct *active_mm = current->active_mm;
linux-4.15.18+/arch/ia64/mm/tlb.c:309:	if (mm != current->active_mm) {
linux-4.15.18+/arch/ia64/mm/tlb.c:325:	if (mm != current->active_mm || cpumask_weight(mm_cpumask(mm)) != 1) {
linux-4.15.18+/arch/ia64/mm/init.c:96:	current->thread.rbs_bot = PAGE_ALIGN(current->mm->start_stack - stack_size);
linux-4.15.18+/arch/ia64/mm/init.c:120:		vma->vm_mm = current->mm;
linux-4.15.18+/arch/ia64/mm/init.c:121:		vma->vm_start = current->thread.rbs_bot & PAGE_MASK;
linux-4.15.18+/arch/ia64/mm/init.c:125:		down_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/ia64/mm/init.c:126:		if (insert_vm_struct(current->mm, vma)) {
linux-4.15.18+/arch/ia64/mm/init.c:127:			up_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/ia64/mm/init.c:131:		up_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/ia64/mm/init.c:135:	if (!(current->personality & MMAP_PAGE_ZERO)) {
linux-4.15.18+/arch/ia64/mm/init.c:139:			vma->vm_mm = current->mm;
linux-4.15.18+/arch/ia64/mm/init.c:144:			down_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/ia64/mm/init.c:145:			if (insert_vm_struct(current->mm, vma)) {
linux-4.15.18+/arch/ia64/mm/init.c:146:				up_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/ia64/mm/init.c:150:			up_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/ia64/sn/kernel/sn2/sn2_smp.c:126:	if (mm == current->mm && mm && atomic_read(&mm->mm_users) == 1)
linux-4.15.18+/arch/ia64/sn/kernel/sn2/sn2_smp.c:169:	int mymm = (mm == current->active_mm && mm == current->mm);
linux-4.15.18+/arch/ia64/sn/kernel/setup.c:497:	current->thread.flags |= IA64_THREAD_MIGRATION;
linux-4.15.18+/arch/ia64/kernel/crash.c:46:	prstatus->pr_pid = current->pid;
linux-4.15.18+/arch/ia64/kernel/crash.c:144:	current->thread.ksp = (__u64)info->sw - 16;
linux-4.15.18+/arch/ia64/kernel/process.c:181:	if (current->thread.pfm_needs_checking)
linux-4.15.18+/arch/ia64/kernel/process.c:378:	p->thread.flags = ((current->thread.flags & ~THREAD_FLAGS_TO_CLEAR)
linux-4.15.18+/arch/ia64/kernel/process.c:441:	if (current->thread.pfm_context)
linux-4.15.18+/arch/ia64/kernel/process.c:573:	current->thread.flags &= ~(IA64_THREAD_FPH_VALID | IA64_THREAD_DBG_VALID);
linux-4.15.18+/arch/ia64/kernel/perfmon_default_smpl.c:159:	ent->pid            = current->pid;
linux-4.15.18+/arch/ia64/kernel/perfmon_default_smpl.c:171:	ent->tgid      = current->tgid;
linux-4.15.18+/arch/ia64/kernel/machine_kexec.c:97:		current->thread.ksp = (__u64)info->sw - 16;
linux-4.15.18+/arch/ia64/kernel/entry.S:85:	 * security sensitive state (e.g., if current->mm->dumpable is zero).  However,
linux-4.15.18+/arch/ia64/kernel/entry.S:975:(pUStk)	st1 [r18]=r17		// restore current->thread.on_ustack
linux-4.15.18+/arch/ia64/kernel/entry.S:984:(pUStk)	st1 [r18]=r17		// restore current->thread.on_ustack
linux-4.15.18+/arch/ia64/kernel/entry.S:1123:	 *	r20 = &current->thread_info->pre_count (if CONFIG_PREEMPT)
linux-4.15.18+/arch/ia64/kernel/entry.S:1124:	 *	r31 = current->thread_info->flags
linux-4.15.18+/arch/ia64/kernel/mca.c:877:	char *p, comm[sizeof(current->comm)];
linux-4.15.18+/arch/ia64/kernel/mca.c:878:	if (previous_current->pid)
linux-4.15.18+/arch/ia64/kernel/mca.c:880:			current->comm, previous_current->pid);
linux-4.15.18+/arch/ia64/kernel/mca.c:883:		if ((p = strchr(previous_current->comm, ' ')))
linux-4.15.18+/arch/ia64/kernel/mca.c:884:			l = p - previous_current->comm;
linux-4.15.18+/arch/ia64/kernel/mca.c:886:			l = strlen(previous_current->comm);
linux-4.15.18+/arch/ia64/kernel/mca.c:888:			current->comm, l, previous_current->comm,
linux-4.15.18+/arch/ia64/kernel/mca.c:891:	memcpy(current->comm, comm, sizeof(current->comm));
linux-4.15.18+/arch/ia64/kernel/mca.c:992:	if ((p = strchr(current->comm, ' ')))
linux-4.15.18+/arch/ia64/kernel/mca.c:1123:	previous_current->thread.ksp = (u64)p - 16;
linux-4.15.18+/arch/ia64/kernel/traps.c:68:		current->comm, task_pid_nr(current), str, err, ++die_counter);
linux-4.15.18+/arch/ia64/kernel/traps.c:226:	if ((current->thread.flags & IA64_THREAD_FPH_VALID) != 0) {
linux-4.15.18+/arch/ia64/kernel/traps.c:227:		__ia64_load_fpu(current->thread.fph);
linux-4.15.18+/arch/ia64/kernel/traps.c:304:	if (!(current->thread.flags & IA64_THREAD_FPEMU_NOPRINT))  {
linux-4.15.18+/arch/ia64/kernel/traps.c:332:		       			current->comm, task_pid_nr(current), regs->cr_iip + ia64_psr(regs)->ri, isr);
linux-4.15.18+/arch/ia64/kernel/traps.c:471:			       current->comm, task_pid_nr(current),
linux-4.15.18+/arch/ia64/kernel/traps.c:585:		if ((result < 0) || (current->thread.flags & IA64_THREAD_FPEMU_SIGFPE)) {
linux-4.15.18+/arch/ia64/kernel/minstate.h:61:	ld1 r17=[r16];				/* load current->thread.on_ustack flag */	\
linux-4.15.18+/arch/ia64/kernel/minstate.h:62:	st1 [r16]=r0;				/* clear current->thread.on_ustack flag */	\
linux-4.15.18+/arch/ia64/kernel/signal.c:50:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/ia64/kernel/signal.c:93:		err |= __copy_from_user(current->thread.fph, &sc->sc_fr[32], 96*16);
linux-4.15.18+/arch/ia64/kernel/signal.c:100:			__ia64_load_fpu(current->thread.fph);
linux-4.15.18+/arch/ia64/kernel/signal.c:201:	       current->comm, current->pid, scr->pt.r12, scr->pt.cr_iip);
linux-4.15.18+/arch/ia64/kernel/signal.c:239:	if ((current->thread.flags & IA64_THREAD_FPH_VALID)) {
linux-4.15.18+/arch/ia64/kernel/signal.c:241:		err = __copy_to_user(&sc->sc_fr[32], current->thread.fph, 96*16);
linux-4.15.18+/arch/ia64/kernel/signal.c:282:	return (bsp - current->sas_ss_sp < current->sas_ss_size);
linux-4.15.18+/arch/ia64/kernel/signal.c:301:		spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/arch/ia64/kernel/signal.c:302:		current->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;
linux-4.15.18+/arch/ia64/kernel/signal.c:303:		spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/arch/ia64/kernel/signal.c:329:			new_sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/ia64/kernel/signal.c:337:				new_rbs = ALIGN(current->sas_ss_sp,
linux-4.15.18+/arch/ia64/kernel/signal.c:396:	       current->comm, current->pid, ksig->sig, scr->pt.r12, frame->sc.sc_ip, frame->handler);
linux-4.15.18+/arch/ia64/kernel/mca_drv_asm.S:34:	st1	[r2]=r0		// clear current->thread.on_ustack flag
linux-4.15.18+/arch/ia64/kernel/smp.c:298:	if (likely(mm == current->active_mm && atomic_read(&mm->mm_users) == 1))
linux-4.15.18+/arch/ia64/kernel/mca_drv.c:161:	       raw_smp_processor_id(), current->pid,
linux-4.15.18+/arch/ia64/kernel/mca_drv.c:163:		iip, ipsr, paddr, current->comm);
linux-4.15.18+/arch/ia64/kernel/setup.c:19: * 03/31/00 R.Seth	cpu_initialized and current->processor fixes
linux-4.15.18+/arch/ia64/kernel/setup.c:1002:	current->active_mm = &init_mm;
linux-4.15.18+/arch/ia64/kernel/setup.c:1003:	BUG_ON(current->mm);
linux-4.15.18+/arch/ia64/kernel/fsys.S:67:	ld8 r17=[r17]				// r17 = current->group_leader
linux-4.15.18+/arch/ia64/kernel/fsys.S:74:	ld8 r17=[r17]				// r17 = current->group_leader->pids[PIDTYPE_PID].pid
linux-4.15.18+/arch/ia64/kernel/fsys.S:103:	ld8 r17=[r17]				// r17 = current->pids[PIDTYPE_PID].pid
linux-4.15.18+/arch/ia64/kernel/fsys.S:477:	st1 [r16]=r0				// M2|3 clear current->thread.on_ustack flag
linux-4.15.18+/arch/ia64/kernel/ivt.S:768:	ld1.bias r17=[r16]			// M0|1 r17 = current->thread.on_ustack flag
linux-4.15.18+/arch/ia64/kernel/ivt.S:806:	st1 [r16]=r0				// M2|3 clear current->thread.on_ustack flag
linux-4.15.18+/arch/ia64/kernel/sys_ia64.c:32:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/ia64/kernel/unaligned.c:538:		current->thread.fph[fph_index(regs, regnum)] = *fpval;
linux-4.15.18+/arch/ia64/kernel/unaligned.c:592:	 * to current->thread.fph to get access to it.  See discussion in setfpreg()
linux-4.15.18+/arch/ia64/kernel/unaligned.c:597:		*fpval = current->thread.fph[fph_index(regs, regnum)];
linux-4.15.18+/arch/ia64/kernel/unaligned.c:1324:		if ((current->thread.flags & IA64_THREAD_UAC_SIGBUS) != 0)
linux-4.15.18+/arch/ia64/kernel/unaligned.c:1328:		    !(current->thread.flags & IA64_THREAD_UAC_NOPRINT) &&
linux-4.15.18+/arch/ia64/kernel/unaligned.c:1335:				      "ip=0x%016lx\n\r", current->comm,
linux-4.15.18+/arch/ia64/kernel/unaligned.c:1361:				       current->comm, task_pid_nr(current));
linux-4.15.18+/arch/ia64/kernel/perfmon.c:1918:	if (ctx->ctx_smpl_vaddr && current->mm) {
linux-4.15.18+/arch/ia64/kernel/perfmon.c:4190:	if (CTX_OVFL_NOBLOCK(ctx) == 0 && req->load_pid == current->pid) {
linux-4.15.18+/arch/ia64/kernel/perfmon.c:6709:		current->comm);
linux-4.15.18+/arch/nios2/include/asm/mmu_context.h:63: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/parisc/include/asm/tlbflush.h:73:		if (mm == current->active_mm)
linux-4.15.18+/arch/nios2/mm/cacheflush.c:75:	struct mm_struct *mm = current->active_mm;
linux-4.15.18+/arch/nios2/mm/mmu_context.c:103: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/nios2/mm/init.c:124:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/nios2/mm/fault.c:157:			current->maj_flt++;
linux-4.15.18+/arch/nios2/mm/fault.c:159:			current->min_flt++;
linux-4.15.18+/arch/nios2/mm/fault.c:191:				"cause %ld\n", current->comm, SIGSEGV, address, cause);
linux-4.15.18+/arch/nios2/mm/tlb.c:43:	if (current->mm == mm)
linux-4.15.18+/arch/nios2/kernel/process.c:158:	pr_emerg("COMM=%s PID=%d\n", current->comm, current->pid);
linux-4.15.18+/arch/nios2/kernel/process.c:160:	if (current->mm) {
linux-4.15.18+/arch/nios2/kernel/process.c:162:			(int) current->mm->start_code,
linux-4.15.18+/arch/nios2/kernel/process.c:163:			(int) current->mm->end_code,
linux-4.15.18+/arch/nios2/kernel/process.c:164:			(int) current->mm->start_data,
linux-4.15.18+/arch/nios2/kernel/process.c:165:			(int) current->mm->end_data,
linux-4.15.18+/arch/nios2/kernel/process.c:166:			(int) current->mm->end_data,
linux-4.15.18+/arch/nios2/kernel/process.c:167:			(int) current->mm->brk);
linux-4.15.18+/arch/nios2/kernel/process.c:169:			(int) current->mm->start_stack,
linux-4.15.18+/arch/nios2/kernel/signal.c:46:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/nios2/kernel/signal.c:238:	current->thread.kregs = regs;
linux-4.15.18+/arch/nios2/kernel/sys_nios2.c:41:	vma = find_vma(current->mm, addr);
linux-4.15.18+/arch/nios2/kernel/misaligned.c:162:				current->pid);
linux-4.15.18+/arch/nios2/boot/dts/3c120_devboard.dts:141:				current-speed = <115200>;
linux-4.15.18+/arch/parisc/include/asm/compat.h:278:	struct pt_regs *regs = &current->thread.regs;
linux-4.15.18+/arch/parisc/include/asm/processor.h:38:#define TASK_UNMAPPED_BASE      (current->thread.map_base)
linux-4.15.18+/arch/parisc/include/asm/processor.h:256: * it in here from the current->personality
linux-4.15.18+/arch/parisc/include/asm/processor.h:267:	__u32 spaceid = (__u32)current->mm->context;	\
linux-4.15.18+/arch/parisc/include/asm/elf.h:251:	set_personality((current->personality & ~PER_MASK) | PER_LINUX); \
linux-4.15.18+/arch/parisc/include/asm/elf.h:252:	current->thread.map_base = DEFAULT_MAP_BASE; \
linux-4.15.18+/arch/parisc/include/asm/elf.h:253:	current->thread.task_size = DEFAULT_TASK_SIZE \
linux-4.15.18+/arch/parisc/mm/fault.c:326:			current->maj_flt++;
linux-4.15.18+/arch/parisc/mm/fault.c:328:			current->min_flt++;
linux-4.15.18+/arch/parisc/kernel/sys_parisc32.c:23:    	current->comm, current->pid, r20);
linux-4.15.18+/arch/parisc/kernel/sys_parisc.c:92:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/parisc/kernel/sys_parisc.c:148:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/parisc/kernel/sys_parisc.c:217:	if (current->personality & ADDR_COMPAT_LAYOUT)
linux-4.15.18+/arch/parisc/kernel/sys_parisc.c:233:	if (current->flags & PF_RANDOMIZE)
linux-4.15.18+/arch/parisc/kernel/sys_parisc.c:378:	if (personality(current->personality) == PER_LINUX32
linux-4.15.18+/arch/parisc/kernel/traps.c:241:			current->comm, task_pid_nr(current), str, err, regs->iaoq[0]);
linux-4.15.18+/arch/parisc/kernel/traps.c:272:			current->comm, task_pid_nr(current), str, err);
linux-4.15.18+/arch/parisc/kernel/traps.c:275:	if (current->thread.flags & PARISC_KERNEL_DEATH) {
linux-4.15.18+/arch/parisc/kernel/traps.c:280:	current->thread.flags |= PARISC_KERNEL_DEATH;
linux-4.15.18+/arch/parisc/kernel/traps.c:330:			task_pid_nr(current), current->comm);
linux-4.15.18+/arch/parisc/kernel/traps.c:722:			down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/parisc/kernel/traps.c:723:			vma = find_vma(current->mm,regs->iaoq[0]);
linux-4.15.18+/arch/parisc/kernel/traps.c:730:				up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/parisc/kernel/traps.c:733:			up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/parisc/kernel/traps.c:762:				task_pid_nr(current), current->comm);
linux-4.15.18+/arch/parisc/kernel/traps.c:782:				task_pid_nr(current), current->comm);
linux-4.15.18+/arch/parisc/kernel/signal.c:102:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/parisc/kernel/signal.c:188:		sp = (current->sas_ss_sp + 0x7f) & ~0x3f; /* Stacks grow up! */
linux-4.15.18+/arch/parisc/kernel/signal.c:409:	       current->comm, current->pid, frame, regs->gr[30],
linux-4.15.18+/arch/parisc/kernel/signal.c:484:		current->comm, task_pid_nr(current), opcode);
linux-4.15.18+/arch/parisc/kernel/ftrace.c:39:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/parisc/kernel/ftrace.c:45:	trace.depth = current->curr_ret_stack + 1;
linux-4.15.18+/arch/parisc/kernel/binfmt_elf32.c:92:	current->thread.map_base = DEFAULT_MAP_BASE32; \
linux-4.15.18+/arch/parisc/kernel/binfmt_elf32.c:93:	current->thread.task_size = DEFAULT_TASK_SIZE32 \
linux-4.15.18+/arch/parisc/kernel/smp.c:282:	current->active_mm = &init_mm;
linux-4.15.18+/arch/parisc/kernel/smp.c:283:	BUG_ON(current->mm);
linux-4.15.18+/arch/parisc/kernel/irq.c:439:		current->comm, sp, stack_start, stack_start + IRQ_STACK_SIZE);
linux-4.15.18+/arch/parisc/kernel/irq.c:456:		current->comm, sp, stack_start, stack_start + THREAD_SIZE);
linux-4.15.18+/arch/parisc/kernel/unaligned.c:462:		if (current->thread.flags & PARISC_UAC_SIGBUS) {
linux-4.15.18+/arch/parisc/kernel/unaligned.c:466:		if (!(current->thread.flags & PARISC_UAC_NOPRINT) &&
linux-4.15.18+/arch/parisc/kernel/unaligned.c:470:				current->comm, task_pid_nr(current), regs->ior, regs->iaoq[0]);
linux-4.15.18+/arch/cris/arch-v32/drivers/cryptocop.c:2721:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/cris/arch-v32/drivers/cryptocop.c:2730:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/cris/arch-v32/drivers/cryptocop.c:2742:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/cris/arch-v32/drivers/cryptocop.c:2750:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/cris/arch-v32/kernel/traps.c:18:	 * It's possible to use either the USP register or current->thread.usp.
linux-4.15.18+/arch/cris/arch-v32/kernel/traps.c:20:	 * function is called, and current->thread.usp isn't up to date for the
linux-4.15.18+/arch/cris/arch-v32/kernel/traps.c:56:	       current->comm, current->pid, (unsigned long)current);
linux-4.15.18+/arch/cris/arch-v32/kernel/ptrace.c:257:	if (!(current->ptrace & PT_PTRACED))
linux-4.15.18+/arch/cris/arch-v32/kernel/ptrace.c:262:	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
linux-4.15.18+/arch/cris/arch-v32/kernel/ptrace.c:269:	if (current->exit_code) {
linux-4.15.18+/arch/cris/arch-v32/kernel/ptrace.c:270:		send_sig(current->exit_code, current, 1);
linux-4.15.18+/arch/cris/arch-v32/kernel/ptrace.c:271:		current->exit_code = 0;
linux-4.15.18+/arch/cris/arch-v32/kernel/signal.c:63:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/cris/arch-v32/kernel/entry.S:123:	addoq	+TI_flags, $r0, $acr	; current->work
linux-4.15.18+/arch/cris/arch-v10/kernel/ptrace.c:188:	if (!(current->ptrace & PT_PTRACED))
linux-4.15.18+/arch/cris/arch-v10/kernel/ptrace.c:193:	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
linux-4.15.18+/arch/cris/arch-v10/kernel/ptrace.c:200:	if (current->exit_code) {
linux-4.15.18+/arch/cris/arch-v10/kernel/ptrace.c:201:		send_sig(current->exit_code, current, 1);
linux-4.15.18+/arch/cris/arch-v10/kernel/ptrace.c:202:		current->exit_code = 0;
linux-4.15.18+/arch/cris/arch-v10/kernel/entry.S:111:	move.d	[$r0+TI_flags], $r10	; current->work
linux-4.15.18+/arch/cris/arch-v10/kernel/entry.S:262:	bmi	_work_resched	; current->work.need_resched
linux-4.15.18+/arch/cris/arch-v10/kernel/entry.S:572:	move.d  [$r10+TASK_pid], $r10	; current->pid as arg1.
linux-4.15.18+/arch/cris/arch-v10/kernel/traps.c:23:	 * It's possible to use either the USP register or current->thread.usp.
linux-4.15.18+/arch/cris/arch-v10/kernel/traps.c:25:	 * function is called, and current->thread.usp isn't up to date for the
linux-4.15.18+/arch/cris/arch-v10/kernel/traps.c:48:	       current->comm, current->pid, (unsigned long)current);
linux-4.15.18+/arch/cris/arch-v10/kernel/signal.c:72:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/cris/include/asm/tlbflush.h:37:	flush_tlb_mm(current->mm);
linux-4.15.18+/arch/cris/include/asm/user.h:21: *  data: The data segment follows next.  We use current->end_text to
linux-4.15.18+/arch/cris/include/asm/user.h:22: *	current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/cris/include/asm/user.h:29: *	current->start_stack, so we round each of these in order to be able
linux-4.15.18+/arch/cris/kernel/ptrace.c:29: * - triggered by current->work.notify_resume
linux-4.15.18+/arch/cris/kernel/profile.c:23:		*(unsigned int*)sample_buffer_pos = current->pid;
linux-4.15.18+/arch/alpha/include/asm/tlbflush.h:85:	flush_tlb_current(current->active_mm);
linux-4.15.18+/arch/alpha/include/asm/tlbflush.h:110:	if (mm == current->active_mm)
linux-4.15.18+/arch/alpha/include/asm/tlbflush.h:122:	if (mm == current->active_mm)
linux-4.15.18+/arch/alpha/include/asm/cacheflush.h:56:		if (current->active_mm == mm)
linux-4.15.18+/arch/alpha/include/asm/a.out-core.h:29:	dump->start_code  = current->mm->start_code;
linux-4.15.18+/arch/alpha/include/asm/a.out-core.h:30:	dump->start_data  = current->mm->start_data;
linux-4.15.18+/arch/alpha/include/asm/a.out-core.h:32:	dump->u_tsize = ((current->mm->end_code - dump->start_code)
linux-4.15.18+/arch/alpha/include/asm/a.out-core.h:34:	dump->u_dsize = ((current->mm->brk + PAGE_SIZE-1 - dump->start_data)
linux-4.15.18+/arch/alpha/include/asm/a.out-core.h:36:	dump->u_ssize = (current->mm->start_stack - dump->start_stack
linux-4.15.18+/arch/alpha/include/asm/processor.h:25:  (current->personality & ADDR_LIMIT_32BIT ? 0x80000000 : 0x00120000000UL)
linux-4.15.18+/arch/alpha/include/asm/processor.h:33:  ((current->personality & ADDR_LIMIT_32BIT) ? 0x40000000 : TASK_SIZE / 2)
linux-4.15.18+/arch/alpha/include/asm/user.h:23: *  data: The data segment follows next.  We use current->end_text to
linux-4.15.18+/arch/alpha/include/asm/user.h:24: *	current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/alpha/include/asm/user.h:31: *	current->start_stack, so we round each of these in order to be able
linux-4.15.18+/arch/alpha/include/asm/mmu_context.h:194:		struct mm_struct * mm = current->active_mm;	\
linux-4.15.18+/arch/alpha/mm/fault.c:88:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/alpha/mm/fault.c:168:			current->maj_flt++;
linux-4.15.18+/arch/alpha/mm/fault.c:170:			current->min_flt++;
linux-4.15.18+/arch/alpha/mm/fault.c:251:		pgd = current->active_mm->pgd + index;
linux-4.15.18+/arch/alpha/kernel/signal.c:155:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/alpha/kernel/signal.c:379:		current->comm, current->pid, frame, regs->pc, regs->r26);
linux-4.15.18+/arch/alpha/kernel/signal.c:433:		current->comm, current->pid, frame, regs->pc, regs->r26);
linux-4.15.18+/arch/alpha/kernel/traps.c:184:	printk("%s(%d): %s %ld\n", current->comm, task_pid_nr(current), str, err);
linux-4.15.18+/arch/alpha/kernel/traps.c:634:	       current->comm, task_pid_nr(current));
linux-4.15.18+/arch/alpha/kernel/traps.c:770:			       current->comm, task_pid_nr(current),
linux-4.15.18+/arch/alpha/kernel/traps.c:993:		struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:75:	mm = current->mm;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:186:			current->comm, flags);
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:691:	unsigned long oss_sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:705:		if (current->sas_ss_sp && on_sig_stack(usp))
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:711:		current->sas_ss_sp = (unsigned long)ss_sp - SIGSTKSZ;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:712:		current->sas_ss_size = SIGSTKSZ;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1167:		r.ru_minflt = current->min_flt;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1168:		r.ru_majflt = current->maj_flt;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1171:		utime_jiffies = nsecs_to_jiffies(current->signal->cutime);
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1172:		stime_jiffies = nsecs_to_jiffies(current->signal->cstime);
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1175:		r.ru_minflt = current->signal->cmin_flt;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1176:		r.ru_majflt = current->signal->cmaj_flt;
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1315:	if (current->personality & ADDR_LIMIT_32BIT)
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1376:	if (unlikely(personality(current->personality) == PER_OSF4))
linux-4.15.18+/arch/alpha/kernel/osf_sys.c:1385:	if (unlikely(personality(current->personality) == PER_OSF4))
linux-4.15.18+/arch/alpha/kernel/smp.c:149:	current->active_mm = &init_mm;
linux-4.15.18+/arch/alpha/kernel/smp.c:169:	      cpuid, current, current->active_mm));
linux-4.15.18+/arch/alpha/kernel/smp.c:644:	if (mm == current->active_mm && !asn_locked())
linux-4.15.18+/arch/alpha/kernel/smp.c:655:	if (mm == current->active_mm) {
linux-4.15.18+/arch/alpha/kernel/smp.c:690:	if (mm == current->active_mm && !asn_locked())
linux-4.15.18+/arch/alpha/kernel/smp.c:704:	if (mm == current->active_mm) {
linux-4.15.18+/arch/alpha/kernel/smp.c:743:	if (mm == current->active_mm && !asn_locked())
linux-4.15.18+/arch/alpha/kernel/smp.c:760:	if (mm == current->active_mm) {
linux-4.15.18+/arch/alpha/kernel/pci-sysfs.c:50:		current->comm, sparse ? " sparse" : "", start, start + nr,
linux-4.15.18+/arch/alpha/kernel/pci-sysfs.c:266:		current->comm, sparse ? " sparse" : "", start, start + nr,
linux-4.15.18+/arch/h8300/include/asm/ptrace.h:27:#define signal_pt_regs() ((struct pt_regs *)current->thread.esp0)
linux-4.15.18+/arch/h8300/include/asm/processor.h:90:	(_regs)->er5 = current->mm->start_data;	/* GOT base */	\
linux-4.15.18+/arch/h8300/include/asm/processor.h:100:	(_regs)->er5 = current->mm->start_data;	/* GOT base */	\
linux-4.15.18+/arch/h8300/include/asm/user.h:21:   DATA: The data area is stored.  We use current->end_text to
linux-4.15.18+/arch/h8300/include/asm/user.h:22:   current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/h8300/include/asm/user.h:29:   current->start_stack, so we round each of these off in order to be able
linux-4.15.18+/arch/h8300/kernel/traps.c:48:	current->thread.esp0 = ssp;
linux-4.15.18+/arch/h8300/kernel/traps.c:62:	pr_info("COMM=%s PID=%d\n", current->comm, current->pid);
linux-4.15.18+/arch/h8300/kernel/traps.c:63:	if (current->mm) {
linux-4.15.18+/arch/h8300/kernel/traps.c:65:			(int) current->mm->start_code,
linux-4.15.18+/arch/h8300/kernel/traps.c:66:			(int) current->mm->end_code,
linux-4.15.18+/arch/h8300/kernel/traps.c:67:			(int) current->mm->start_data,
linux-4.15.18+/arch/h8300/kernel/traps.c:68:			(int) current->mm->end_data,
linux-4.15.18+/arch/h8300/kernel/traps.c:69:			(int) current->mm->end_data,
linux-4.15.18+/arch/h8300/kernel/traps.c:70:			(int) current->mm->brk);
linux-4.15.18+/arch/h8300/kernel/traps.c:72:			(int) current->mm->start_stack,
linux-4.15.18+/arch/h8300/kernel/ptrace_h.c:251:	if ((unsigned long)current->thread.breakinfo.addr == bp) {
linux-4.15.18+/arch/microblaze/pci/pci-common.c:415:				current->comm, current->pid);
linux-4.15.18+/arch/h8300/kernel/signal.c:83:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/h8300/kernel/signal.c:205:	regs->er5 = current->mm->start_data;	/* GOT base */
linux-4.15.18+/arch/h8300/kernel/signal.c:266:	current->thread.esp0 = (unsigned long) regs;
linux-4.15.18+/arch/microblaze/include/asm/mmu_context_mm.h:129: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/microblaze/include/asm/mmu_context_mm.h:135:	current->thread.pgdir = mm->pgd;
linux-4.15.18+/arch/microblaze/include/asm/elf.h:28:	set_personality(PER_LINUX_32BIT | (current->personality & (~PER_MASK)))
linux-4.15.18+/arch/microblaze/mm/pgtable.c:227:		mm = current->mm;
linux-4.15.18+/arch/microblaze/boot/dts/system.dts:301:			current-speed = <115200>;
linux-4.15.18+/arch/microblaze/mm/fault.c:90:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/microblaze/mm/fault.c:115:		   as is current->mm == NULL. */
linux-4.15.18+/arch/microblaze/mm/fault.c:174:		struct pt_regs *uregs = current->thread.regs;
linux-4.15.18+/arch/microblaze/mm/fault.c:236:			current->maj_flt++;
linux-4.15.18+/arch/microblaze/mm/fault.c:238:			current->min_flt++;
linux-4.15.18+/arch/microblaze/kernel/signal.c:92:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/microblaze/kernel/signal.c:199:			pgd_offset(current->mm, address),
linux-4.15.18+/arch/microblaze/kernel/signal.c:234:		current->comm, current->pid, frame, regs->pc);
linux-4.15.18+/arch/microblaze/kernel/entry.S:923:	/* update r31, the current-give me pointer to task which will be next */
linux-4.15.18+/arch/microblaze/kernel/ftrace.c:33:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/microblaze/kernel/ftrace.c:75:		current->curr_ret_stack--;
linux-4.15.18+/arch/score/include/asm/mmu_context.h:101: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/score/mm/tlb-score.c:116:			if (mm == current->active_mm)
linux-4.15.18+/arch/score/mm/tlb-score.c:221:	if (current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/score/kernel/ptrace.c:362: * - triggered by current->work.syscall_trace
linux-4.15.18+/arch/score/kernel/ptrace.c:366:	if (!(current->ptrace & PT_PTRACED))
linux-4.15.18+/arch/score/kernel/ptrace.c:374:	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD) ?
linux-4.15.18+/arch/score/kernel/ptrace.c:382:	if (current->exit_code) {
linux-4.15.18+/arch/score/kernel/ptrace.c:383:		send_sig(current->exit_code, current, 1);
linux-4.15.18+/arch/score/kernel/ptrace.c:384:		current->exit_code = 0;
linux-4.15.18+/arch/score/kernel/traps.c:152:		current->comm, current->pid, (unsigned long) current);
linux-4.15.18+/arch/score/kernel/traps.c:249:	if (current->thread.single_step == 1) {
linux-4.15.18+/arch/score/kernel/traps.c:250:		if ((epc == current->thread.addr1) ||
linux-4.15.18+/arch/score/kernel/traps.c:251:		    (epc == current->thread.addr2)) {
linux-4.15.18+/arch/score/kernel/traps.c:344:	current->active_mm = &init_mm;
linux-4.15.18+/arch/score/kernel/entry.S:254:	lw	r6, [r28, TI_FLAGS]	# current->work
linux-4.15.18+/arch/score/kernel/entry.S:294:	lw	r6, [r28, TI_FLAGS]		# current->work
linux-4.15.18+/arch/score/kernel/entry.S:451:	lw	r6, [r28, TI_FLAGS]	# current->work
linux-4.15.18+/arch/score/kernel/signal.c:131:		sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/score/kernel/signal.c:144:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/score/mm/fault.c:155:		current->thread.cp0_baduaddr = address;
linux-4.15.18+/arch/x86/power/cpu.c:180:	load_mm_ldt(current->active_mm);	/* This does lldt */
linux-4.15.18+/arch/x86/platform/uv/uv_nmi.c:684:		cpu, current->pid, current->comm, (void *)regs->ip);
linux-4.15.18+/arch/x86/platform/uv/uv_nmi.c:701:	if (current->pid != 0 || !uv_nmi_action_is("ips"))
linux-4.15.18+/arch/x86/entry/vsyscall/vsyscall_64.c:80:			   level, current->comm, task_pid_nr(current),
linux-4.15.18+/arch/x86/entry/vsyscall/vsyscall_64.c:108:		struct thread_struct *thread = &current->thread;
linux-4.15.18+/arch/x86/entry/vsyscall/vsyscall_64.c:232:	prev_sig_on_uaccess_err = current->thread.sig_on_uaccess_err;
linux-4.15.18+/arch/x86/entry/vsyscall/vsyscall_64.c:233:	current->thread.sig_on_uaccess_err = 1;
linux-4.15.18+/arch/x86/entry/vsyscall/vsyscall_64.c:254:	current->thread.sig_on_uaccess_err = prev_sig_on_uaccess_err;
linux-4.15.18+/arch/x86/entry/common.c:355:	unsigned long landing_pad = (unsigned long)current->mm->context.vdso +
linux-4.15.18+/arch/x86/entry/vdso/vma.c:63:			(unsigned long)current->mm->context.vdso;
linux-4.15.18+/arch/x86/entry/vdso/vma.c:76:	const struct vdso_image *image = current->mm->context.vdso_image;
linux-4.15.18+/arch/x86/entry/vdso/vma.c:82:	current->mm->context.vdso = (void __user *)new_vma->vm_start;
linux-4.15.18+/arch/x86/entry/vdso/vma.c:154:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/entry/vdso/vma.c:197:		current->mm->context.vdso = (void __user *)text_start;
linux-4.15.18+/arch/x86/entry/vdso/vma.c:198:		current->mm->context.vdso_image = image;
linux-4.15.18+/arch/x86/entry/vdso/vma.c:253:	unsigned long addr = vdso_addr(current->mm->start_stack, image->size-image->sym_vvar_start);
linux-4.15.18+/arch/x86/entry/vdso/vma.c:261:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/kvm/svm.c:1790:	wrmsrl(MSR_KERNEL_GS_BASE, current->thread.gsbase);
linux-4.15.18+/arch/x86/kvm/x86.c:2143:	vcpu->arch.st.steal.steal += current->sched_info.run_delay -
linux-4.15.18+/arch/x86/kvm/x86.c:2145:	vcpu->arch.st.last_steal = current->sched_info.run_delay;
linux-4.15.18+/arch/x86/kvm/x86.c:8305:	if (current->mm == kvm->mm) {
linux-4.15.18+/arch/x86/include/asm/tlbflush.h:170:	 * are on.  This means that it may not match current->active_mm,
linux-4.15.18+/arch/x86/include/asm/tlbflush.h:362:	/* If current->mm == NULL then the read_cr3() "borrows" an mm */
linux-4.15.18+/arch/x86/include/asm/uaccess.h:29:#define get_fs()	(current->thread.addr_limit)
linux-4.15.18+/arch/x86/include/asm/uaccess.h:32:	current->thread.addr_limit = fs;
linux-4.15.18+/arch/x86/include/asm/uaccess.h:39:#define user_addr_max() (current->thread.addr_limit.seg)
linux-4.15.18+/arch/x86/include/asm/uaccess.h:491:	current->thread.uaccess_err = 0;				\
linux-4.15.18+/arch/x86/include/asm/uaccess.h:496:	current->thread.uaccess_err = 0;				\
linux-4.15.18+/arch/x86/include/asm/uaccess.h:501:	(err) |= (current->thread.uaccess_err ? -EFAULT : 0);		\
linux-4.15.18+/arch/x86/include/asm/stackprotector.h:80:	current->stack_canary = canary;
linux-4.15.18+/arch/x86/include/asm/intel_rdt_sched.h:65:		if (current->closid)
linux-4.15.18+/arch/x86/include/asm/intel_rdt_sched.h:66:			closid = current->closid;
linux-4.15.18+/arch/x86/include/asm/intel_rdt_sched.h:70:		if (current->rmid)
linux-4.15.18+/arch/x86/include/asm/intel_rdt_sched.h:71:			rmid = current->rmid;
linux-4.15.18+/arch/x86/include/asm/fpu/internal.h:573:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/include/asm/a.out-core.h:33:	dump->u_tsize = ((unsigned long)current->mm->end_code) >> PAGE_SHIFT;
linux-4.15.18+/arch/x86/include/asm/a.out-core.h:34:	dump->u_dsize = ((unsigned long)(current->mm->brk + (PAGE_SIZE - 1)))
linux-4.15.18+/arch/x86/include/asm/processor.h:877:#define IA32_PAGE_OFFSET	((current->personality & ADDR_LIMIT_3GB) ? \
linux-4.15.18+/arch/x86/include/asm/page_types.h:40:	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
linux-4.15.18+/arch/x86/include/asm/mmu_context.h:316:	if (!current->mm)
linux-4.15.18+/arch/x86/include/asm/mmu_context.h:323:	if (current->mm != vma->vm_mm)
linux-4.15.18+/arch/x86/include/asm/elf.h:186:	elf_common_init(&current->thread, _r, 0)
linux-4.15.18+/arch/x86/include/asm/elf.h:189:	elf_common_init(&current->thread, regs, __USER_DS)
linux-4.15.18+/arch/x86/include/asm/elf.h:333:			    (unsigned long __force)current->mm->context.vdso); \
linux-4.15.18+/arch/x86/include/asm/elf.h:341:			    (unsigned long __force)current->mm->context.vdso); \
linux-4.15.18+/arch/x86/include/asm/elf.h:356:#define VDSO_CURRENT_BASE	((unsigned long)current->mm->context.vdso)
linux-4.15.18+/arch/x86/include/asm/elf.h:359:	((unsigned long)current->mm->context.vdso +			\
linux-4.15.18+/arch/x86/include/asm/user_32.h:20:   DATA: The data area is stored.  We use current->end_text to
linux-4.15.18+/arch/x86/include/asm/user_32.h:21:   current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/x86/include/asm/user_32.h:28:   current->start_stack, so we round each of these off in order to be able
linux-4.15.18+/arch/x86/include/asm/user_64.h:22:   DATA: The data area is stored.  We use current->end_text to
linux-4.15.18+/arch/x86/include/asm/user_64.h:23:   current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/x86/include/asm/user_64.h:30:   current->start_stack, so we round each of these off in order to be able
linux-4.15.18+/arch/x86/lib/insn-eval.c:583:		mutex_lock(&current->active_mm->context.lock);
linux-4.15.18+/arch/x86/lib/insn-eval.c:584:		ldt = current->active_mm->context.ldt;
linux-4.15.18+/arch/x86/lib/insn-eval.c:588:		mutex_unlock(&current->active_mm->context.lock);
linux-4.15.18+/arch/x86/mm/fault.c:757:		if (current->thread.sig_on_uaccess_err && signal) {
linux-4.15.18+/arch/x86/mm/fault.c:942:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/mm/hugetlbpage.c:148:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/mm/pat.c:632:			current->comm, current->pid, start, end - 1);
linux-4.15.18+/arch/x86/mm/pat.c:821:			current->comm, current->pid,
linux-4.15.18+/arch/x86/mm/pat.c:856:				current->comm, current->pid,
linux-4.15.18+/arch/x86/mm/pat.c:877:			       current->comm, current->pid,
linux-4.15.18+/arch/x86/mm/mpx.c:48:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/mm/mpx.c:227:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/mm/mpx.c:248:				current->comm, current->pid);
linux-4.15.18+/arch/x86/mm/mpx.c:262:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/mm/mpx.c:389:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/mm/mpx.c:420:	if (!kernel_managing_mpx_tables(current->mm))
linux-4.15.18+/arch/x86/mm/mpx.c:905:	if (!kernel_managing_mpx_tables(current->mm))
linux-4.15.18+/arch/x86/mm/mpx.c:932:	if (!kernel_managing_mpx_tables(current->mm))
linux-4.15.18+/arch/x86/mm/debug_pagetables.c:27:	if (current->mm->pgd) {
linux-4.15.18+/arch/x86/mm/debug_pagetables.c:28:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/x86/mm/debug_pagetables.c:29:		ptdump_walk_pgd_level_debugfs(m, current->mm->pgd, false);
linux-4.15.18+/arch/x86/mm/debug_pagetables.c:30:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/x86/mm/debug_pagetables.c:53:	if (current->mm->pgd) {
linux-4.15.18+/arch/x86/mm/debug_pagetables.c:54:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/x86/mm/debug_pagetables.c:55:		ptdump_walk_pgd_level_debugfs(m, current->mm->pgd, true);
linux-4.15.18+/arch/x86/mm/debug_pagetables.c:56:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/x86/mm/pkeys.c:47:	    current->thread.fpu.initialized &&
linux-4.15.18+/arch/x86/mm/mmap.c:55:	if (current->flags & PF_RANDOMIZE) {
linux-4.15.18+/arch/x86/mm/mmap.c:75:	if (current->personality & ADDR_COMPAT_LAYOUT)
linux-4.15.18+/arch/x86/mm/mmap.c:83:	if (!(current->flags & PF_RANDOMIZE))
linux-4.15.18+/arch/x86/mm/mmap.c:162:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/mm/extable.c:115:	current->thread.uaccess_err = 1;
linux-4.15.18+/arch/x86/mm/pat_rbtree.c:174:		current->comm, current->pid, start, end,
linux-4.15.18+/arch/x86/events/core.c:2374:		ldt = READ_ONCE(current->active_mm->context.ldt);
linux-4.15.18+/arch/x86/events/core.c:2462:	if (!current->mm)
linux-4.15.18+/arch/x86/events/intel/lbr.c:807:		if (!current->mm)
linux-4.15.18+/arch/x86/math-emu/fpu_system.h:30:	mutex_lock(&current->mm->context.lock);
linux-4.15.18+/arch/x86/math-emu/fpu_system.h:31:	if (current->mm->context.ldt && seg < current->mm->context.ldt->nr_entries)
linux-4.15.18+/arch/x86/math-emu/fpu_system.h:32:		ret = current->mm->context.ldt->entries[seg];
linux-4.15.18+/arch/x86/math-emu/fpu_system.h:33:	mutex_unlock(&current->mm->context.lock);
linux-4.15.18+/arch/x86/math-emu/fpu_system.h:76:#define I387			(&current->thread.fpu.state)
linux-4.15.18+/arch/x86/math-emu/fpu_entry.c:116:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/math-emu/fpu_entry.c:234:			current->thread.trap_nr = X86_TRAP_MF;
linux-4.15.18+/arch/x86/math-emu/fpu_entry.c:235:			current->thread.error_code = 0;
linux-4.15.18+/arch/x86/math-emu/fpu_entry.c:627:	current->thread.trap_nr = X86_TRAP_MF;
linux-4.15.18+/arch/x86/math-emu/fpu_entry.c:628:	current->thread.error_code = 0;
linux-4.15.18+/arch/x86/math-emu/fpu_aux.c:56:	fpstate_init_soft(&current->thread.fpu.state.soft);
linux-4.15.18+/arch/x86/um/syscalls_64.c:38:		ret = restore_registers(pid, &current->thread.regs.regs);
linux-4.15.18+/arch/x86/um/syscalls_64.c:61:		current->thread.arch.fs = (unsigned long) ptr;
linux-4.15.18+/arch/x86/um/syscalls_64.c:62:		ret = save_registers(pid, &current->thread.regs.regs);
linux-4.15.18+/arch/x86/um/syscalls_64.c:65:		ret = save_registers(pid, &current->thread.regs.regs);
linux-4.15.18+/arch/x86/um/signal.c:160:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/x86/um/signal.c:241:	struct faultinfo * fi = &current->thread.arch.faultinfo;
linux-4.15.18+/arch/x86/um/signal.c:333:	err |= copy_sc_to_user(&uc->uc_mcontext, fp, &current->thread.regs, 0);
linux-4.15.18+/arch/x86/um/signal.c:454:	unsigned long sp = PT_REGS_SP(&current->thread.regs);
linux-4.15.18+/arch/x86/um/signal.c:466:	if (copy_sc_from_user(&current->thread.regs, sc))
linux-4.15.18+/arch/x86/um/signal.c:470:	PT_REGS_SYSCALL_NR(&current->thread.regs) = -1;
linux-4.15.18+/arch/x86/um/signal.c:471:	return PT_REGS_SYSCALL_RET(&current->thread.regs);
linux-4.15.18+/arch/x86/um/signal.c:561:	unsigned long sp = PT_REGS_SP(&current->thread.regs);
linux-4.15.18+/arch/x86/um/signal.c:572:	if (copy_sc_from_user(&current->thread.regs, &uc->uc_mcontext))
linux-4.15.18+/arch/x86/um/signal.c:576:	PT_REGS_SYSCALL_NR(&current->thread.regs) = -1;
linux-4.15.18+/arch/x86/um/signal.c:577:	return PT_REGS_SYSCALL_RET(&current->thread.regs);
linux-4.15.18+/arch/x86/um/ldt.c:58:	uml_ldt_t *ldt = &current->mm->context.arch.ldt;
linux-4.15.18+/arch/x86/um/ldt.c:123:	uml_ldt_t *ldt = &current->mm->context.arch.ldt;
linux-4.15.18+/arch/x86/um/ldt.c:124:	struct mm_id * mm_idp = &current->mm->context.id;
linux-4.15.18+/arch/x86/um/vdso/vma.c:59:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/um/asm/vm-flags.h:14:	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
linux-4.15.18+/arch/x86/um/asm/processor.h:19:       (address + 65536 + 32 * sizeof(unsigned long) >= UPT_SP(&current->thread.regs.regs))
linux-4.15.18+/arch/x86/um/sysrq_64.c:21:		current->comm, print_tainted(), init_utsname()->release);
linux-4.15.18+/arch/x86/um/asm/elf.h:172:	(pr_reg)[21] = current->thread.arch.fs;			\
linux-4.15.18+/arch/x86/um/tls_32.c:264:				"without flushed TLS.", current->pid);
linux-4.15.18+/arch/x86/kernel/ptrace.c:515:	struct thread_struct *thread = &(current->thread);
linux-4.15.18+/arch/x86/kernel/hw_breakpoint.c:381:	struct thread_struct *thread = &current->thread;
linux-4.15.18+/arch/x86/kernel/hw_breakpoint.c:397:	dump->u_debugreg[6] = current->thread.debugreg6;
linux-4.15.18+/arch/x86/kernel/hw_breakpoint.c:426:	set_debugreg(current->thread.debugreg6, 6);
linux-4.15.18+/arch/x86/kernel/hw_breakpoint.c:474:	current->thread.debugreg6 &= ~DR_TRAP_BITS;
linux-4.15.18+/arch/x86/kernel/hw_breakpoint.c:521:	if ((current->thread.debugreg6 & DR_TRAP_BITS) ||
linux-4.15.18+/arch/x86/kernel/process.c:569:	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
linux-4.15.18+/arch/x86/kernel/traps.c:328:		 (void *)fault_address, current->stack,
linux-4.15.18+/arch/x86/kernel/traps.c:329:		 (char *)current->stack + THREAD_SIZE - 1);
linux-4.15.18+/arch/x86/kernel/ioport.c:28:	struct thread_struct *t = &current->thread;
linux-4.15.18+/arch/x86/kernel/ioport.c:112:	struct thread_struct *t = &current->thread;
linux-4.15.18+/arch/x86/kernel/signal.c:106:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/x86/kernel/signal.c:192:		put_user_ex(current->thread.trap_nr, &sc->trapno);
linux-4.15.18+/arch/x86/kernel/signal.c:193:		put_user_ex(current->thread.error_code, &sc->err);
linux-4.15.18+/arch/x86/kernel/signal.c:212:		put_user_ex(current->thread.cr2, &sc->cr2);
linux-4.15.18+/arch/x86/kernel/signal.c:248:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/kernel/signal.c:257:			sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/x86/kernel/signal.c:339:	if (current->mm->context.vdso)
linux-4.15.18+/arch/x86/kernel/signal.c:340:		restorer = current->mm->context.vdso +
linux-4.15.18+/arch/x86/kernel/signal.c:404:		restorer = current->mm->context.vdso +
linux-4.15.18+/arch/x86/kernel/signal.c:707:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/kernel/dumpstack.c:322:			current->thread.trap_nr, SIGSEGV) == NOTIFY_STOP)
linux-4.15.18+/arch/x86/kernel/vm86_32.c:87:#define VFLAGS	(*(unsigned short *)&(current->thread.vm86->veflags))
linux-4.15.18+/arch/x86/kernel/vm86_32.c:88:#define VEFLAGS	(current->thread.vm86->veflags)
linux-4.15.18+/arch/x86/kernel/vm86_32.c:100:	struct vm86 *vm86 = current->thread.vm86;
linux-4.15.18+/arch/x86/kernel/vm86_32.c:268:			     current->comm, task_pid_nr(current),
linux-4.15.18+/arch/x86/kernel/vm86_32.c:422:	set_flags(VEFLAGS, flags, current->thread.vm86->veflags_mask);
linux-4.15.18+/arch/x86/kernel/vm86_32.c:432:	set_flags(VFLAGS, flags, current->thread.vm86->veflags_mask);
linux-4.15.18+/arch/x86/kernel/vm86_32.c:447:	return flags | (VEFLAGS & current->thread.vm86->veflags_mask);
linux-4.15.18+/arch/x86/kernel/vm86_32.c:542:	struct vm86 *vm86 = current->thread.vm86;
linux-4.15.18+/arch/x86/kernel/vm86_32.c:572:	struct vm86 *vm86 = current->thread.vm86;
linux-4.15.18+/arch/x86/kernel/vm86_32.c:584:	current->thread.trap_nr = trapno;
linux-4.15.18+/arch/x86/kernel/vm86_32.c:585:	current->thread.error_code = error_code;
linux-4.15.18+/arch/x86/kernel/vm86_32.c:597:	struct vm86plus_info_struct *vmpi = &current->thread.vm86->vm86plus;
linux-4.15.18+/arch/x86/kernel/ftrace.c:1016:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/x86/kernel/ftrace.c:1050:	trace.depth = current->curr_ret_stack + 1;
linux-4.15.18+/arch/x86/kernel/ldt.c:305:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/kernel/ldt.c:359:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/kernel/sys_x86_64.c:36:	if (!(current->flags & PF_RANDOMIZE))
linux-4.15.18+/arch/x86/kernel/sys_x86_64.c:118:		if (current->flags & PF_RANDOMIZE) {
linux-4.15.18+/arch/x86/kernel/sys_x86_64.c:135:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/kernel/sys_x86_64.c:179:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/x86/kernel/fpu/init.c:37:		fpstate_init_soft(&current->thread.fpu.state.soft);
linux-4.15.18+/arch/x86/kernel/fpu/init.c:243:	WARN_ON_FPU(current->thread.fpu.initialized);
linux-4.15.18+/arch/x86/kernel/fpu/core.c:97:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/kernel/fpu/core.c:117:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/kernel/fpu/core.c:147:	WARN_ON_FPU(fpu != &current->thread.fpu);
linux-4.15.18+/arch/x86/kernel/fpu/core.c:197:	WARN_ON_FPU(src_fpu != &current->thread.fpu);
linux-4.15.18+/arch/x86/kernel/fpu/core.c:229:	WARN_ON_FPU(fpu != &current->thread.fpu);
linux-4.15.18+/arch/x86/kernel/fpu/core.c:259:	if (fpu == &current->thread.fpu) {
linux-4.15.18+/arch/x86/kernel/fpu/core.c:292:	WARN_ON_FPU(fpu == &current->thread.fpu);
linux-4.15.18+/arch/x86/kernel/fpu/core.c:344:	if (fpu == &current->thread.fpu) {
linux-4.15.18+/arch/x86/kernel/fpu/core.c:386:	WARN_ON_FPU(fpu != &current->thread.fpu); /* Almost certainly an anomaly */
linux-4.15.18+/arch/x86/kernel/fpu/signal.c:159:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/kernel/fpu/xstate.c:895:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c:86: * + We can simply set "current->closid" to assign a task to a resource
linux-4.15.18+/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c:451:		current->closid = 0;
linux-4.15.18+/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c:452:		current->rmid = 0;
linux-4.15.18+/arch/x86/kernel/irq_64.c:61:		current->comm, curbase, regs->sp,
linux-4.15.18+/arch/x86/kernel/tls.c:22:	struct thread_struct *t = &current->thread;
linux-4.15.18+/arch/x86/kernel/tls.c:104:	if (t == &current->thread)
linux-4.15.18+/arch/x86/kernel/process_64.c:533:	if (current->mm)
linux-4.15.18+/arch/x86/kernel/process_64.c:534:		current->mm->context.ia32_compat = 0;
linux-4.15.18+/arch/x86/kernel/process_64.c:540:	current->personality &= ~READ_IMPLIES_EXEC;
linux-4.15.18+/arch/x86/kernel/process_64.c:548:	if (current->mm)
linux-4.15.18+/arch/x86/kernel/process_64.c:549:		current->mm->context.ia32_compat = TIF_X32;
linux-4.15.18+/arch/x86/kernel/process_64.c:550:	current->personality &= ~READ_IMPLIES_EXEC;
linux-4.15.18+/arch/x86/kernel/process_64.c:569:	if (current->mm)
linux-4.15.18+/arch/x86/kernel/process_64.c:570:		current->mm->context.ia32_compat = TIF_IA32;
linux-4.15.18+/arch/x86/kernel/process_64.c:571:	current->personality |= force_personality32;
linux-4.15.18+/arch/x86/kernel/uprobes.c:481:		struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/x86/kernel/uprobes.c:492:		struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/x86/kernel/uprobes.c:561:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/x86/kernel/uprobes.c:820:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/x86/kernel/uprobes.c:829:	utask->autask.saved_trap_nr = current->thread.trap_nr;
linux-4.15.18+/arch/x86/kernel/uprobes.c:830:	current->thread.trap_nr = UPROBE_TRAP_NR;
linux-4.15.18+/arch/x86/kernel/uprobes.c:867:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/x86/kernel/uprobes.c:871:	WARN_ON_ONCE(current->thread.trap_nr != UPROBE_TRAP_NR);
linux-4.15.18+/arch/x86/kernel/uprobes.c:872:	current->thread.trap_nr = utask->autask.saved_trap_nr;
linux-4.15.18+/arch/x86/kernel/uprobes.c:938:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/x86/kernel/uprobes.c:943:	current->thread.trap_nr = utask->autask.saved_trap_nr;
linux-4.15.18+/arch/x86/kernel/uprobes.c:984:			"%%ip=%#lx\n", current->pid, regs->sp, regs->ip);
linux-4.15.18+/arch/x86/kernel/stacktrace.c:238:	if (current->mm) {
linux-4.15.18+/arch/x86/ia32/ia32_signal.c:80:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/x86/ia32/ia32_signal.c:195:		put_user_ex(current->thread.trap_nr, &sc->trapno);
linux-4.15.18+/arch/x86/ia32/ia32_signal.c:196:		put_user_ex(current->thread.error_code, &sc->err);
linux-4.15.18+/arch/x86/ia32/ia32_signal.c:207:		put_user_ex(current->thread.cr2, &sc->cr2);
linux-4.15.18+/arch/x86/ia32/ia32_signal.c:220:	struct fpu *fpu = &current->thread.fpu;
linux-4.15.18+/arch/x86/ia32/ia32_signal.c:292:		if (current->mm->context.vdso)
linux-4.15.18+/arch/x86/ia32/ia32_signal.c:293:			restorer = current->mm->context.vdso +
linux-4.15.18+/arch/x86/ia32/ia32_signal.c:372:			restorer = current->mm->context.vdso +
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:47:	struct perf_event *bp = current->thread.ptrace_bps[n];
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:63:	dump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:65:			 (current->mm->brk + (PAGE_SIZE-1))) >> PAGE_SHIFT;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:71:	dump->u_debugreg[6] = current->thread.debugreg6;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:72:	dump->u_debugreg[7] = current->thread.ptrace_dr7;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:88:	dump->regs.ds = current->thread.ds;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:89:	dump->regs.es = current->thread.es;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:145: * changed due to the set[u|g]id. It's enforced by the "current->mm->dumpable"
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:160:	strncpy(dump.u_comm, current->comm, sizeof(current->comm));
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:233:	current->mm->arg_start = (unsigned long) p;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:243:	current->mm->arg_end = current->mm->env_start = (unsigned long) p;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:253:	current->mm->env_end = (unsigned long) p;
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:304:	current->mm->end_code = ex.a_text +
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:305:		(current->mm->start_code = N_TXTADDR(ex));
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:306:	current->mm->end_data = ex.a_data +
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:307:		(current->mm->start_data = N_DATADDR(ex));
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:308:	current->mm->brk = ex.a_bss +
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:309:		(current->mm->start_brk = N_BSSADDR(ex));
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:381:	error = set_brk(current->mm->start_brk, current->mm->brk);
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:387:	current->mm->start_stack =
linux-4.15.18+/arch/x86/ia32/ia32_aout.c:395:	(regs)->sp = current->mm->start_stack;
linux-4.15.18+/arch/openrisc/include/asm/tlbflush.h:59:	flush_tlb_mm(current->mm);
linux-4.15.18+/arch/openrisc/kernel/ptrace.c:175: * - triggered by current->work.syscall_trace
linux-4.15.18+/arch/openrisc/kernel/signal.c:49:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/openrisc/kernel/traps.c:105:	       current->comm, current->pid, (unsigned long)current);
linux-4.15.18+/arch/openrisc/kernel/smp.c:117:	current->active_mm = mm;
linux-4.15.18+/arch/c6x/include/asm/switch_to.h:26:		current->thread.wchan = (u_long) __builtin_return_address(0); \
linux-4.15.18+/arch/c6x/include/asm/switch_to.h:30:		current->thread.wchan = 0;			\
linux-4.15.18+/arch/c6x/include/asm/page.h:7:	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
linux-4.15.18+/arch/c6x/kernel/process.c:105:	current->thread.usp = usp;
linux-4.15.18+/arch/c6x/kernel/signal.c:71:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/c6x/kernel/signal.c:313: * - triggered by current->work.notify_resume
linux-4.15.18+/arch/c6x/kernel/traps.c:79:	       current->comm, current->pid, (PAGE_SIZE +
linux-4.15.18+/arch/c6x/kernel/sys_c6x.c:34:		 current->pid, addr, size);
linux-4.15.18+/arch/arm/probes/uprobes/core.c:138:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/arm/probes/uprobes/core.c:143:	utask->autask.saved_trap_no = current->thread.trap_no;
linux-4.15.18+/arch/arm/probes/uprobes/core.c:144:	current->thread.trap_no = UPROBE_TRAP_NR;
linux-4.15.18+/arch/arm/probes/uprobes/core.c:152:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/arm/probes/uprobes/core.c:154:	WARN_ON_ONCE(current->thread.trap_no != UPROBE_TRAP_NR);
linux-4.15.18+/arch/arm/probes/uprobes/core.c:156:	current->thread.trap_no = utask->autask.saved_trap_no;
linux-4.15.18+/arch/arm/probes/uprobes/core.c:175:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/arm/probes/uprobes/core.c:177:	current->thread.trap_no = utask->autask.saved_trap_no;
linux-4.15.18+/arch/arm/include/asm/stackprotector.h:35:	current->stack_canary = canary;
linux-4.15.18+/arch/arm/include/asm/stackprotector.h:36:	__stack_chk_guard = current->stack_canary;
linux-4.15.18+/arch/arm/include/asm/processor.h:28:#define STACK_TOP	((current->personality & ADDR_LIMIT_32BIT) ? \
linux-4.15.18+/arch/arm/include/asm/processor.h:61:	    current->personality & FDPIC_FUNCPTRS) {			\
linux-4.15.18+/arch/arm/include/asm/processor.h:65:		regs->ARM_r10 = current->mm->start_data;		\
linux-4.15.18+/arch/arm/include/asm/processor.h:67:		regs->ARM_r10 = current->mm->start_data;		\
linux-4.15.18+/arch/arm/include/asm/processor.h:68:	if (current->personality & ADDR_LIMIT_32BIT)			\
linux-4.15.18+/arch/arm/include/asm/user.h:21:   DATA: The data area is stored.  We use current->end_text to
linux-4.15.18+/arch/arm/include/asm/user.h:22:   current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/arm/include/asm/user.h:29:   current->start_stack, so we round each of these off in order to be able
linux-4.15.18+/arch/arm/include/asm/page.h:168:	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
linux-4.15.18+/arch/arm/include/asm/elf.h:144:		    (elf_addr_t)current->mm->context.vdso);	\
linux-4.15.18+/arch/arm/include/asm/mmu_context.h:77:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:35:	pgd = pgd_offset(current->mm, addr);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:58:		ptl = &current->mm->page_table_lock;
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:74:	pte = pte_offset_map_lock(current->mm, pmd, addr, &ptl);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:102:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:110:				up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:114:				down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:134:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:170:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:177:			up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:180:			down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/lib/uaccess_with_memcpy.c:198:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/boot/dts/qcom-msm8974-sony-xperia-honami.dts:422:			qcom,fast-charge-current-limit = <1500000>;
linux-4.15.18+/arch/arm/boot/dts/qcom-msm8974-sony-xperia-honami.dts:423:			qcom,dc-current-limit = <1800000>;
linux-4.15.18+/arch/arm/boot/dts/qcom-msm8974-sony-xperia-honami.dts:453:			qcom,current-limit = <20>;
linux-4.15.18+/arch/arm/boot/dts/qcom-msm8974-sony-xperia-honami.dts:454:			qcom,current-boost-limit = <805>;
linux-4.15.18+/arch/arm/boot/dts/qcom-pm8941.dtsi:202:				regulator-over-current-protection;
linux-4.15.18+/arch/arm/boot/dts/omap-zoom-common.dtsi:26:		current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/omap-zoom-common.dtsi:62:		current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/omap-zoom-common.dtsi:73:		current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/omap-zoom-common.dtsi:84:		current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/keystone-k2g.dtsi:112:			current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/ox820.dtsi:209:			       current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/ox820.dtsi:223:			       current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/tegra114-dalmore.dts:836:				ti,enable-low-current-chrg;
linux-4.15.18+/arch/arm/boot/dts/exynos4412-trats2.dts:205:				maxim,battery-overcurrent-microamp = <3500000>;
linux-4.15.18+/arch/arm/boot/dts/da850-lego-ev3.dts:146:		over-current-gpios = <&gpio 99 GPIO_ACTIVE_LOW>;
linux-4.15.18+/arch/arm/boot/dts/ox810se.dtsi:244:			       current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/ox810se.dtsi:258:			       current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/ox810se.dtsi:272:			       current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/ox810se.dtsi:286:			       current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/qcom-msm8974-sony-xperia-castor.dts:589:			qcom,fast-charge-current-limit = <1500000>;
linux-4.15.18+/arch/arm/boot/dts/qcom-msm8974-sony-xperia-castor.dts:590:			qcom,dc-current-limit = <1800000>;
linux-4.15.18+/arch/arm/boot/dts/omap3-n900.dts:700:		ti,current-limit = <100>;
linux-4.15.18+/arch/arm/boot/dts/keystone.dtsi:107:			current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/keystone.dtsi:117:			current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/exynos5250-snow-common.dtsi:134:						ti,overcurrent-wait = <3>;
linux-4.15.18+/arch/arm/boot/dts/exynos5250-snow-common.dtsi:139:						ti,overcurrent-wait = <3>;
linux-4.15.18+/arch/arm/boot/dts/exynos5250-snow-common.dtsi:144:						ti,overcurrent-wait = <3>;
linux-4.15.18+/arch/arm/boot/dts/exynos5250-snow-common.dtsi:148:						ti,overcurrent-wait = <3>;
linux-4.15.18+/arch/arm/boot/dts/exynos5250-snow-common.dtsi:153:						ti,overcurrent-wait = <3>;
linux-4.15.18+/arch/arm/boot/dts/exynos5250-snow-common.dtsi:157:						ti,overcurrent-wait = <3>;
linux-4.15.18+/arch/arm/boot/dts/exynos5250-snow-common.dtsi:162:						ti,overcurrent-wait = <3>;
linux-4.15.18+/arch/arm/boot/dts/omap5-board-common.dtsi:431:			ti,channel0-current-microamp = <5>;
linux-4.15.18+/arch/arm/boot/dts/omap5-board-common.dtsi:432:			ti,channel3-current-microamp = <10>;
linux-4.15.18+/arch/arm/boot/dts/keystone-k2l.dtsi:48:			current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/keystone-k2l.dtsi:58:			current-speed = <115200>;
linux-4.15.18+/arch/arm/boot/dts/armada-388-clearfog.dtsi:198:			line-name = "usb3-current-limit";
linux-4.15.18+/arch/arm/mach-rpc/ecard.c:250:	struct mm_struct *active_mm = current->active_mm;
linux-4.15.18+/arch/arm/mach-rpc/ecard.c:255:	current->mm = mm;
linux-4.15.18+/arch/arm/mach-rpc/ecard.c:256:	current->active_mm = mm;
linux-4.15.18+/arch/arm/vfp/vfpmodule.c:231:	current->thread.error_code = 0;
linux-4.15.18+/arch/arm/vfp/vfpmodule.c:232:	current->thread.trap_no = 6;
linux-4.15.18+/arch/arm/mm/alignment.c:941:		       "Address=0x%08lx FSR 0x%03x\n", current->comm,
linux-4.15.18+/arch/arm/mm/ioremap.c:180:	if (current->active_mm->context.vmalloc_seq != init_mm.context.vmalloc_seq)
linux-4.15.18+/arch/arm/mm/ioremap.c:181:		__check_vmalloc_seq(current->active_mm);
linux-4.15.18+/arch/arm/mm/proc-macros.S:30: * act_mm - get current->active_mm
linux-4.15.18+/arch/arm/mm/fault.c:559:	show_pte(current->mm, addr);
linux-4.15.18+/arch/arm/mm/tlb-v4wbi.S:34:	act_mm	r3				@ get current->active_mm
linux-4.15.18+/arch/arm/mm/mmap.c:26:	if (current->personality & ADDR_COMPAT_LAYOUT)
linux-4.15.18+/arch/arm/mm/mmap.c:60:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arm/mm/mmap.c:113:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arm/mm/mmap.c:187:	if (current->flags & PF_RANDOMIZE)
linux-4.15.18+/arch/arm/mm/tlb-fa.S:39:	act_mm	r3				@ get current->active_mm
linux-4.15.18+/arch/arm/mm/init.c:717:	set_section_perms(perms, n, true, current->active_mm);
linux-4.15.18+/arch/arm/mm/init.c:746:				current->active_mm);
linux-4.15.18+/arch/arm/mm/init.c:752:				current->active_mm);
linux-4.15.18+/arch/arm/mm/flush.c:243:	struct mm_struct *mm = current->active_mm;
linux-4.15.18+/arch/arm/mm/tlb-v4.S:35:	act_mm	r3				@ get current->active_mm
linux-4.15.18+/arch/arm/mm/tlb-v4wb.S:35:	act_mm	r3				@ get current->active_mm
linux-4.15.18+/arch/arm/nwfpe/entry.S:35:	strb	r8, [r10, #TSK_USED_MATH]	@ set current->used_math
linux-4.15.18+/arch/arm/nwfpe/fpmodule.c:151:		       current->comm, current->pid, flags,
linux-4.15.18+/arch/arm/kernel/process.c:410:	current->mm->context.sigpage = new_vma->vm_start;
linux-4.15.18+/arch/arm/kernel/process.c:422:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arm/kernel/ptrace.c:396:		if (current->thread.debug.hbp[i] == bp)
linux-4.15.18+/arch/arm/kernel/traps.c:370:		current->thread.error_code = err;
linux-4.15.18+/arch/arm/kernel/traps.c:371:		current->thread.trap_no = trap;
linux-4.15.18+/arch/arm/kernel/traps.c:480:			current->comm, task_pid_nr(current), pc);
linux-4.15.18+/arch/arm/kernel/traps.c:540:	if ((current->personality & PER_MASK) != PER_LINUX) {
linux-4.15.18+/arch/arm/kernel/traps.c:548:			task_pid_nr(current), current->comm, n);
linux-4.15.18+/arch/arm/kernel/traps.c:677:		       task_pid_nr(current), current->comm, no);
linux-4.15.18+/arch/arm/kernel/traps.c:746:		       task_pid_nr(current), current->comm, code, instr);
linux-4.15.18+/arch/arm/kernel/traps.c:748:		show_pte(current->mm, addr);
linux-4.15.18+/arch/arm/kernel/signal.c:229:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/arm/kernel/signal.c:259:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/arm/kernel/signal.c:311:	__put_user_error(current->thread.trap_no, &sf->uc.uc_mcontext.trap_no, err);
linux-4.15.18+/arch/arm/kernel/signal.c:312:	__put_user_error(current->thread.error_code, &sf->uc.uc_mcontext.error_code, err);
linux-4.15.18+/arch/arm/kernel/signal.c:313:	__put_user_error(current->thread.address, &sf->uc.uc_mcontext.fault_address, err);
linux-4.15.18+/arch/arm/kernel/signal.c:366:		     (current->personality & FDPIC_FUNCPTRS);
linux-4.15.18+/arch/arm/kernel/signal.c:448:			struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arm/kernel/vdso.c:69:	current->mm->context.vdso = new_vma->vm_start;
linux-4.15.18+/arch/arm/kernel/ftrace.c:234:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/arm/kernel/ftrace.c:241:	trace.depth = current->curr_ret_stack + 1;
linux-4.15.18+/arch/arm/kernel/suspend.c:21:	struct mm_struct *mm = current->active_mm;
linux-4.15.18+/arch/arm/kernel/smp.c:377:	current->active_mm = mm;
linux-4.15.18+/arch/arm/kernel/perf_callchain.c:74:	if (!current->mm)
linux-4.15.18+/arch/arm/kernel/swp_emulate.c:115:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/kernel/swp_emulate.c:116:	if (find_vma(current->mm, addr) == NULL)
linux-4.15.18+/arch/arm/kernel/swp_emulate.c:120:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm/kernel/swp_emulate.c:197:	if (current->pid != previous_pid) {
linux-4.15.18+/arch/arm/kernel/swp_emulate.c:199:			 current->comm, (unsigned long)current->pid);
linux-4.15.18+/arch/arm/kernel/swp_emulate.c:200:		previous_pid = current->pid;
linux-4.15.18+/arch/arm/kernel/elf.c:46:	unsigned int personality = current->personality & ~PER_MASK;
linux-4.15.18+/arch/metag/include/asm/tlbflush.h:49:	if (mm == current->active_mm)
linux-4.15.18+/arch/metag/include/asm/cacheflush.h:43:	if (mm == current->mm)
linux-4.15.18+/arch/metag/include/asm/processor.h:115:	current->thread.int_depth = 1;					   \
linux-4.15.18+/arch/metag/mm/hugetlbpage.c:34:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/metag/mm/hugetlbpage.c:127:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/metag/kernel/process.c:338:	set_gateway_tls(current->thread.tls_ptr);
linux-4.15.18+/arch/metag/kernel/process.c:345:	clear_fpu(&current->thread);
linux-4.15.18+/arch/metag/kernel/process.c:346:	clear_dsp(&current->thread);
linux-4.15.18+/arch/metag/kernel/process.c:438:		list_add(&tcm->list, &current->mm->context.tcm);
linux-4.15.18+/arch/metag/kernel/signal.c:53:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/metag/kernel/signal.c:199:		 current->comm, current->pid, frame, regs->REG_PC,
linux-4.15.18+/arch/metag/kernel/sys_metag.c:97:	current->thread.tls_ptr = ptr;
linux-4.15.18+/arch/metag/kernel/sys_metag.c:105:	return (__force void *)current->thread.tls_ptr;
linux-4.15.18+/arch/metag/kernel/traps.c:110:	pr_err("Process: %s (pid: %d, stack limit = %p)\n", current->comm,
linux-4.15.18+/arch/metag/kernel/traps.c:218:		dsp_ctx = current->thread.dsp_context;
linux-4.15.18+/arch/metag/kernel/traps.c:224:			current->thread.dsp_context = dsp_ctx;
linux-4.15.18+/arch/metag/kernel/traps.c:227:		current->thread.user_flags |= (D0_8 & 0xffff0000);
linux-4.15.18+/arch/metag/kernel/traps.c:244:		current->thread.user_flags = savemask;
linux-4.15.18+/arch/metag/kernel/traps.c:285:		BUG_ON(current->thread.int_depth > HARDIRQ_BITS);
linux-4.15.18+/arch/metag/kernel/traps.c:287:		depth = current->thread.int_depth++;
linux-4.15.18+/arch/metag/kernel/traps.c:293:			current->thread.txdefr_failure &= ~(1 << depth);
linux-4.15.18+/arch/metag/kernel/traps.c:295:			current->thread.txdefr_failure |= (1 << depth);
linux-4.15.18+/arch/metag/kernel/traps.c:331:		if (current->thread.fpu_context &&
linux-4.15.18+/arch/metag/kernel/traps.c:332:		    current->thread.fpu_context->needs_restore) {
linux-4.15.18+/arch/metag/kernel/traps.c:333:			__TBICtxFPURestore(State, current->thread.fpu_context);
linux-4.15.18+/arch/metag/kernel/traps.c:339:			current->thread.fpu_context->needs_restore = false;
linux-4.15.18+/arch/metag/kernel/traps.c:357:		struct meta_ext_context *dsp_ctx = current->thread.dsp_context;
linux-4.15.18+/arch/metag/kernel/traps.c:360:		BUG_ON(current->thread.int_depth != 1);
linux-4.15.18+/arch/metag/kernel/traps.c:370:		__TBICtxRestore(State, current->thread.dsp_context);
linux-4.15.18+/arch/metag/kernel/traps.c:372:		D0_8 |= current->thread.user_flags & 0xffff0000;
linux-4.15.18+/arch/metag/kernel/traps.c:393:		depth = --current->thread.int_depth;
linux-4.15.18+/arch/metag/kernel/traps.c:402:		if (current->thread.txdefr_failure & (1 << depth))
linux-4.15.18+/arch/metag/kernel/traps.c:508:				current->pid, regs->ctx.CurrPC, addr,
linux-4.15.18+/arch/metag/kernel/traps.c:911:	set_gateway_tls(current->thread.tls_ptr);
linux-4.15.18+/arch/metag/kernel/smp.c:351:	current->active_mm = mm;
linux-4.15.18+/arch/sparc/power/hibernate.c:37:	struct mm_struct *mm = current->active_mm;
linux-4.15.18+/arch/sparc/include/asm/cacheflush_64.h:22:	do { if ((__mm) == current->mm) flushw_user(); } while(0)
linux-4.15.18+/arch/sparc/include/asm/pgtable_64.h:991:			flush_dcache_page_all(current->mm,		\
linux-4.15.18+/arch/sparc/include/asm/sfp-machine_32.h:185:#define FP_ROUNDMODE	((current->thread.fsr >> 30) & 0x3)
linux-4.15.18+/arch/sparc/include/asm/sfp-machine_32.h:201:#define FP_INHIBIT_RESULTS ((current->thread.fsr >> 23) & _fex)
linux-4.15.18+/arch/sparc/include/asm/sfp-machine_32.h:207:#define FP_TRAPPING_EXCEPTIONS ((current->thread.fsr >> 23) & 0x1f)
linux-4.15.18+/arch/sparc/include/asm/elf_64.h:209:	if (personality(current->personality) != PER_LINUX32)	\
linux-4.15.18+/arch/sparc/include/asm/elf_64.h:211:			(current->personality & (~PER_MASK)));	\
linux-4.15.18+/arch/sparc/include/asm/elf_64.h:220:			    (unsigned long)current->mm->context.vdso);	\
linux-4.15.18+/arch/sparc/include/asm/uaccess_32.h:29:#define get_fs()	(current->thread.current_ds)
linux-4.15.18+/arch/sparc/include/asm/uaccess_32.h:30:#define set_fs(val)	((current->thread.current_ds) = (val))
linux-4.15.18+/arch/sparc/mm/srmmu.c:1667:			if (atomic_read(&mm->mm_users) == 1 && current->active_mm == mm)
linux-4.15.18+/arch/sparc/mm/gup.c:198:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/mm/gup.c:228:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/mm/hugetlbpage.c:65:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/mm/hugetlbpage.c:102:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/mm/fault_64.c:96:	pgd_t *pgdp = pgd_offset(current->mm, tpc);
linux-4.15.18+/arch/sparc/mm/fault_64.c:276:		       current->comm, current->pid,
linux-4.15.18+/arch/sparc/mm/fault_64.c:284:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/mm/fault_64.c:458:			current->maj_flt++;
linux-4.15.18+/arch/sparc/mm/fault_64.c:462:			current->min_flt++;
linux-4.15.18+/arch/sparc/mm/tsb.c:268:		       current->comm, current->pid, tsb_bytes);
linux-4.15.18+/arch/sparc/mm/fault_32.c:262:			current->maj_flt++;
linux-4.15.18+/arch/sparc/mm/fault_32.c:266:			current->min_flt++;
linux-4.15.18+/arch/sparc/vdso/vma.c:177:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/vdso/vma.c:188:	if (current->flags & PF_RANDOMIZE) {
linux-4.15.18+/arch/sparc/vdso/vma.c:206:	current->mm->context.vdso = (void __user *)text_start;
linux-4.15.18+/arch/sparc/vdso/vma.c:236:		current->mm->context.vdso = NULL;
linux-4.15.18+/arch/sparc/mm/init_64.c:3011:	if (mm == current->mm)
linux-4.15.18+/arch/sparc/mm/init_64.c:3017:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/kernel/unaligned_64.c:278:		printk(KERN_ALERT "current->{active_,}mm->context = %016lx\n",
linux-4.15.18+/arch/sparc/kernel/unaligned_64.c:279:			(current->mm ? CTX_HWBITS(current->mm->context) :
linux-4.15.18+/arch/sparc/kernel/unaligned_64.c:280:			CTX_HWBITS(current->active_mm->context)));
linux-4.15.18+/arch/sparc/kernel/unaligned_64.c:281:		printk(KERN_ALERT "current->{active_,}mm->pgd = %016lx\n",
linux-4.15.18+/arch/sparc/kernel/unaligned_64.c:282:			(current->mm ? (unsigned long) current->mm->pgd :
linux-4.15.18+/arch/sparc/kernel/unaligned_64.c:283:			(unsigned long) current->active_mm->pgd));
linux-4.15.18+/arch/sparc/kernel/signal_64.c:178:		err |= __put_user(current->blocked.sig[0],
linux-4.15.18+/arch/sparc/kernel/signal_64.c:181:		err |= __copy_to_user(&ucp->uc_sigmask, &current->blocked,
linux-4.15.18+/arch/sparc/kernel/signal_64.c:269:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/sparc/kernel/process_32.c:213:		fpsave(&current->thread.float_regs[0], &current->thread.fsr,
linux-4.15.18+/arch/sparc/kernel/process_32.c:214:		       &current->thread.fpqueue[0], &current->thread.fpqdepth);
linux-4.15.18+/arch/sparc/kernel/process_32.c:223:	if (current->thread.flags & SPARC_FLAG_KTHREAD) {
linux-4.15.18+/arch/sparc/kernel/process_32.c:224:		current->thread.flags &= ~SPARC_FLAG_KTHREAD;
linux-4.15.18+/arch/sparc/kernel/process_32.c:228:		current->thread.kregs = (struct pt_regs *)
linux-4.15.18+/arch/sparc/kernel/process_32.c:360:	ti->kpsr = current->thread.fork_kpsr | PSR_PIL;
linux-4.15.18+/arch/sparc/kernel/process_32.c:361:	ti->kwim = current->thread.fork_kwim;
linux-4.15.18+/arch/sparc/kernel/process_32.c:400:	childregs->u_regs[UREG_I0] = current->pid;
linux-4.15.18+/arch/sparc/kernel/process_32.c:425:		fpsave(&current->thread.float_regs[0], &current->thread.fsr,
linux-4.15.18+/arch/sparc/kernel/process_32.c:426:		       &current->thread.fpqueue[0], &current->thread.fpqdepth);
linux-4.15.18+/arch/sparc/kernel/process_32.c:435:		fpsave(&current->thread.float_regs[0], &current->thread.fsr,
linux-4.15.18+/arch/sparc/kernel/process_32.c:436:		       &current->thread.fpqueue[0], &current->thread.fpqdepth);
linux-4.15.18+/arch/sparc/kernel/process_32.c:444:	       &current->thread.float_regs[0],
linux-4.15.18+/arch/sparc/kernel/process_32.c:446:	fpregs->pr_fsr = current->thread.fsr;
linux-4.15.18+/arch/sparc/kernel/process_32.c:447:	fpregs->pr_qcnt = current->thread.fpqdepth;
linux-4.15.18+/arch/sparc/kernel/process_32.c:452:		       &current->thread.fpqueue[0],
linux-4.15.18+/arch/sparc/kernel/sys_sparc_64.c:91:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/kernel/sys_sparc_64.c:152:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sparc/kernel/sys_sparc_64.c:223:	get_area = current->mm->get_unmapped_area;
linux-4.15.18+/arch/sparc/kernel/sys_sparc_64.c:269:	if (current->flags & PF_RANDOMIZE) {
linux-4.15.18+/arch/sparc/kernel/sys_sparc_64.c:290:	    (current->personality & ADDR_COMPAT_LAYOUT) ||
linux-4.15.18+/arch/sparc/kernel/sys_sparc_64.c:421:	if (personality(current->personality) == PER_LINUX32 &&
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:21:		fpsave(&current->thread.float_regs[0], &current->thread.fsr,
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:22:		       &current->thread.fpqueue[0], &current->thread.fpqdepth);
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:29:		fpsave(&current->thread.float_regs[0], &current->thread.fsr,
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:30:		       &current->thread.fpqueue[0], &current->thread.fpqdepth);
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:36:			      &current->thread.float_regs[0],
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:38:	err |= __put_user(current->thread.fsr, &fpu->si_fsr);
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:39:	err |= __put_user(current->thread.fpqdepth, &fpu->si_fpqdepth);
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:40:	if (current->thread.fpqdepth != 0)
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:42:				      &current->thread.fpqueue[0],
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:71:	err = __copy_from_user(&current->thread.float_regs[0], &fpu->si_float_regs[0],
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:73:	err |= __get_user(current->thread.fsr, &fpu->si_fsr);
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:74:	err |= __get_user(current->thread.fpqdepth, &fpu->si_fpqdepth);
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:75:	if (current->thread.fpqdepth != 0)
linux-4.15.18+/arch/sparc/kernel/sigutil_32.c:76:		err |= __copy_from_user(&current->thread.fpqueue[0],
linux-4.15.18+/arch/sparc/kernel/sun4m_smp.c:64:	current->active_mm = &init_mm;
linux-4.15.18+/arch/sparc/kernel/sun4d_smp.c:98:	current->active_mm = &init_mm;
linux-4.15.18+/arch/sparc/kernel/signal32.c:166:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/sparc/kernel/signal32.c:255:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/sparc/kernel/signal32.c:387:	pgdp = pgd_offset(current->mm, address);
linux-4.15.18+/arch/sparc/kernel/signal32.c:773:		if (put_user(current->sas_ss_sp + current->sas_ss_size,
linux-4.15.18+/arch/sparc/kernel/signal32.c:790:		if (current->sas_ss_sp && on_sig_stack(sp))
linux-4.15.18+/arch/sparc/kernel/signal32.c:797:		current->sas_ss_sp = (unsigned long)ss_sp - SIGSTKSZ;
linux-4.15.18+/arch/sparc/kernel/signal32.c:798:		current->sas_ss_size = SIGSTKSZ;
linux-4.15.18+/arch/sparc/kernel/uprobes.c:197: * current->utask->xol_vaddr points to an allocated XOL slot properly
linux-4.15.18+/arch/sparc/kernel/uprobes.c:205:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/sparc/kernel/uprobes.c:206:	struct arch_uprobe_task *autask = &current->utask->autask;
linux-4.15.18+/arch/sparc/kernel/uprobes.c:231:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/sparc/kernel/uprobes.c:308:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/sparc/kernel/ptrace_32.c:344:	unsigned long addr2 = current->thread.kregs->u_regs[UREG_I4];
linux-4.15.18+/arch/sparc/kernel/traps_64.c:2520:	printk("%s(%d): %s [#%d]\n", current->comm, task_pid_nr(current), str, ++die_counter);
linux-4.15.18+/arch/sparc/kernel/traps_64.c:2894:	current->active_mm = &init_mm;
linux-4.15.18+/arch/sparc/kernel/ftrace.c:131:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/sparc/kernel/ftrace.c:135:	trace.depth = current->curr_ret_stack + 1;
linux-4.15.18+/arch/sparc/kernel/signal_32.c:86:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/sparc/kernel/signal_32.c:317:		flush_sig_insns(current->mm, (unsigned long) &(sf->insns[0]));
linux-4.15.18+/arch/sparc/kernel/signal_32.c:414:		flush_sig_insns(current->mm, (unsigned long) &(sf->insns[0]));
linux-4.15.18+/arch/sparc/kernel/signal_32.c:541:		if (put_user(current->sas_ss_sp + current->sas_ss_size,
linux-4.15.18+/arch/sparc/kernel/signal_32.c:556:		if (current->sas_ss_sp && on_sig_stack(sp))
linux-4.15.18+/arch/sparc/kernel/signal_32.c:562:		current->sas_ss_sp = (unsigned long)ss_sp - SIGSTKSZ;
linux-4.15.18+/arch/sparc/kernel/signal_32.c:563:		current->sas_ss_size = SIGSTKSZ;
linux-4.15.18+/arch/sparc/kernel/process_64.c:661:	t->kregs->u_regs[UREG_I0] = current->pid;
linux-4.15.18+/arch/sparc/kernel/smp_64.c:131:	current->active_mm = &init_mm;
linux-4.15.18+/arch/sparc/kernel/smp_64.c:895:	/* It is not valid to test "current->active_mm == mm" here.
linux-4.15.18+/arch/sparc/kernel/smp_64.c:1062: *    processor's in current->mm->cpu_vm_mask and performing the
linux-4.15.18+/arch/sparc/kernel/smp_64.c:1123:	if (mm == current->mm && atomic_read(&mm->mm_users) == 1)
linux-4.15.18+/arch/sparc/kernel/smp_64.c:1139:	if (mm == current->mm && atomic_read(&mm->mm_users) == 1)
linux-4.15.18+/arch/sparc/kernel/leon_smp.c:98:	current->active_mm = &init_mm;
linux-4.15.18+/arch/sparc/kernel/unaligned_32.c:60:		die_if_kernel("Byte sized unaligned access?!?!", current->thread.kregs);
linux-4.15.18+/arch/sparc/kernel/unaligned_32.c:226:		printk(KERN_ALERT "current->{mm,active_mm}->context = %08lx\n",
linux-4.15.18+/arch/sparc/kernel/unaligned_32.c:227:			(current->mm ? current->mm->context :
linux-4.15.18+/arch/sparc/kernel/unaligned_32.c:228:			current->active_mm->context));
linux-4.15.18+/arch/sparc/kernel/unaligned_32.c:229:		printk(KERN_ALERT "current->{mm,active_mm}->pgd = %08lx\n",
linux-4.15.18+/arch/sparc/kernel/unaligned_32.c:230:			(current->mm ? (unsigned long) current->mm->pgd :
linux-4.15.18+/arch/sparc/kernel/unaligned_32.c:231:			(unsigned long) current->active_mm->pgd));
linux-4.15.18+/arch/sparc/kernel/unaligned_32.c:328:	if(!(current->thread.flags & SPARC_FLAG_UNALIGNED) ||
linux-4.15.18+/arch/sparc/kernel/traps_32.c:62:	printk("%s(%d): %s [#%d]\n", current->comm, task_pid_nr(current), str, ++die_counter);
linux-4.15.18+/arch/sparc/kernel/traps_32.c:203:		fpload(&current->thread.float_regs[0], &current->thread.fsr);
linux-4.15.18+/arch/sparc/kernel/traps_32.c:214:		fpload(&current->thread.float_regs[0], &current->thread.fsr);
linux-4.15.18+/arch/sparc/kernel/traps_32.c:282:		fpload(&current->thread.float_regs[0], &current->thread.fsr);
linux-4.15.18+/arch/sparc/kernel/traps_32.c:455:	current->active_mm = &init_mm;
linux-4.15.18+/arch/sparc/kernel/sys_sparc_32.c:139:		current->comm, task_pid_nr(current), (int)regs->u_regs[1]);
linux-4.15.18+/arch/sparc/kernel/perf_event.c:1752:			int index = current->curr_ret_stack;
linux-4.15.18+/arch/sparc/kernel/perf_event.c:1753:			if (current->ret_stack && index >= graph) {
linux-4.15.18+/arch/sparc/kernel/perf_event.c:1754:				pc = current->ret_stack[index - graph].ret;
linux-4.15.18+/arch/sparc/kernel/perf_event.c:1838:	if (!current->mm)
linux-4.15.18+/arch/m32r/include/asm/uaccess.h:64: * (u33)addr + (u33)size >= (u33)current->addr_limit.seg
linux-4.15.18+/arch/m32r/include/asm/user.h:21: * DATA: The data area is stored.  We use current->end_text to
linux-4.15.18+/arch/m32r/include/asm/user.h:22: *	current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/m32r/include/asm/user.h:29: *	current->start_stack, so we round each of these off in order to be
linux-4.15.18+/arch/m32r/include/asm/mmu_context.h:115: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/m32r/mm/fault.c:359:	if (vma && current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/m32r/mm/fault.c:489:			if (mm == current->mm)
linux-4.15.18+/arch/m32r/mm/fault.c:522:		if (mm == current->mm)
linux-4.15.18+/arch/m32r/kernel/process.c:102:	DPRINTK("pid = %d\n", current->pid);
linux-4.15.18+/arch/m32r/kernel/process.c:103:	memset(&current->thread.debug_trap, 0, sizeof(struct debug_trap));
linux-4.15.18+/arch/m32r/kernel/traps.c:201:		current->comm, task_pid_nr(current), 0xffff & i, 4096+(unsigned long)current);
linux-4.15.18+/arch/m32r/kernel/traps.c:305:		current->thread.error_code = error_code;
linux-4.15.18+/arch/m32r/kernel/traps.c:306:		current->thread.trap_no = 0x17;
linux-4.15.18+/arch/m32r/kernel/traps.c:321:			"access\n", current->comm);
linux-4.15.18+/arch/m32r/kernel/ptrace.c:686: * - triggered by current->work.syscall_trace
linux-4.15.18+/arch/m32r/kernel/ptrace.c:692:	if (!(current->ptrace & PT_PTRACED))
linux-4.15.18+/arch/m32r/kernel/ptrace.c:696:	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
linux-4.15.18+/arch/m32r/kernel/ptrace.c:704:	if (current->exit_code) {
linux-4.15.18+/arch/m32r/kernel/ptrace.c:705:		send_sig(current->exit_code, current, 1);
linux-4.15.18+/arch/m32r/kernel/ptrace.c:706:		current->exit_code = 0;
linux-4.15.18+/arch/m32r/kernel/signal.c:52:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/m32r/kernel/signal.c:214:		current->comm, current->pid, frame, regs->pc);
linux-4.15.18+/arch/m32r/kernel/signal.c:320: * - triggered by current->work.notify_resume
linux-4.15.18+/arch/m32r/kernel/entry.S:217:	and3	r4, r9, #_TIF_ALLWORK_MASK	; current->work
linux-4.15.18+/arch/m32r/kernel/setup.c:408:	current->active_mm = &init_mm;
linux-4.15.18+/arch/m32r/kernel/setup.c:409:	if (current->mm)
linux-4.15.18+/arch/m32r/kernel/smp.c:263:		if (mm == current->mm)
linux-4.15.18+/arch/m32r/kernel/smp.c:459:		if (flush_mm == current->active_mm)
linux-4.15.18+/arch/s390/pci/pci_mmio.c:21:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/pci/pci_mmio.c:23:	vma = find_vma(current->mm, user_addr);
linux-4.15.18+/arch/s390/pci/pci_mmio.c:31:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/intercept.c:122:		  current->pid, vcpu->kvm);
linux-4.15.18+/arch/s390/kvm/intercept.c:219:	if (current->thread.per_flags & PER_FLAG_NO_TE)
linux-4.15.18+/arch/s390/kvm/priv.c:60:		current->thread.gs_cb = (struct gs_cb *)&vcpu->run->s.regs.gscb;
linux-4.15.18+/arch/s390/kvm/priv.c:61:		restore_gs_cb(current->thread.gs_cb);
linux-4.15.18+/arch/s390/kvm/priv.c:262:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/priv.c:263:	rc = get_guest_storage_key(current->mm, addr, &key);
linux-4.15.18+/arch/s390/kvm/priv.c:264:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/priv.c:294:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/priv.c:295:	rc = reset_guest_reference_bit(current->mm, addr);
linux-4.15.18+/arch/s390/kvm/priv.c:296:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/priv.c:349:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/priv.c:350:		rc = cond_set_guest_storage_key(current->mm, addr, key, &oldkey,
linux-4.15.18+/arch/s390/kvm/priv.c:353:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/priv.c:936:			down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/priv.c:937:			rc = cond_set_guest_storage_key(current->mm, useraddr,
linux-4.15.18+/arch/s390/kvm/priv.c:939:			up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/interrupt.c:442:		save_gs_cb(current->thread.gs_cb);
linux-4.15.18+/arch/s390/kvm/interrupt.c:503:	rc |= put_guest_lc(vcpu, current->thread.fpu.fpc,
linux-4.15.18+/arch/s390/kvm/vsie.c:718:	if (current->thread.gmap_int_code == PGM_PROTECTION)
linux-4.15.18+/arch/s390/kvm/vsie.c:721:				    current->thread.gmap_addr, 1);
linux-4.15.18+/arch/s390/kvm/vsie.c:724:				   current->thread.gmap_addr);
linux-4.15.18+/arch/s390/kvm/vsie.c:727:				  current->thread.gmap_addr,
linux-4.15.18+/arch/s390/kvm/vsie.c:728:				  current->thread.gmap_write_flag);
linux-4.15.18+/arch/s390/kvm/vsie.c:730:			vsie_page->fault_addr = current->thread.gmap_addr;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:712:			struct gmap *new = gmap_create(current->mm, new_limit);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1428:	if (!mm_use_skey(current->mm))
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1439:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1448:		r = get_guest_storage_key(current->mm, hva, &keys[i]);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1453:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1495:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1510:		r = set_guest_storage_key(current->mm, hva, keys[i], 0);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1515:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1932:	sprintf(debug_name, "kvm-%u", current->pid);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:1995:		kvm->arch.gmap = gmap_create(current->mm, kvm->arch.mem_limit - 1);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:2008:	KVM_EVENT(3, "vm 0x%pK created by pid %u", kvm, current->pid);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:2086:	vcpu->arch.gmap = gmap_create(current->mm, -1UL);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:2373:	current->thread.fpu.fpc = 0;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3089:	hva = gfn_to_hva(vcpu->kvm, gpa_to_gfn(current->thread.gmap_addr));
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3090:	hva += current->thread.gmap_addr & ~PAGE_MASK;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3094:	rc = kvm_setup_async_pf(vcpu, current->thread.gmap_addr, hva, &arch);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3217:						current->thread.gmap_addr;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3220:	} else if (current->thread.gmap_pfault) {
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3222:		current->thread.gmap_pfault = 0;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3225:		return kvm_arch_fault_in_page(vcpu, current->thread.gmap_addr, 1);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3332:	vcpu->arch.host_fpregs.fpc = current->thread.fpu.fpc;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3333:	vcpu->arch.host_fpregs.regs = current->thread.fpu.regs;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3335:		current->thread.fpu.regs = vcpu->run->s.regs.vrs;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3337:		current->thread.fpu.regs = vcpu->run->s.regs.fprs;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3338:	current->thread.fpu.fpc = vcpu->run->s.regs.fpc;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3339:	if (test_fp_ctl(current->thread.fpu.fpc))
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3341:		current->thread.fpu.fpc = 0;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3345:		if (current->thread.gs_cb) {
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3346:			vcpu->arch.host_gscb = current->thread.gs_cb;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3350:			current->thread.gs_cb = (struct gs_cb *)
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3352:			restore_gs_cb(current->thread.gs_cb);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3379:	vcpu->run->s.regs.fpc = current->thread.fpu.fpc;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3381:	current->thread.fpu.fpc = vcpu->arch.host_fpregs.fpc;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3382:	current->thread.fpu.regs = vcpu->arch.host_fpregs.regs;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3386:			save_gs_cb(current->thread.gs_cb);
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3388:		current->thread.gs_cb = vcpu->arch.host_gscb;
linux-4.15.18+/arch/s390/kvm/kvm-s390.c:3516:	vcpu->run->s.regs.fpc = current->thread.fpu.fpc;
linux-4.15.18+/arch/s390/include/asm/uaccess.h:35:#define get_fs()        (current->thread.mm_segment)
linux-4.15.18+/arch/s390/include/asm/processor.h:204:	crst_table_downgrade(current->mm);				\
linux-4.15.18+/arch/s390/include/asm/user.h:27:   DATA: The data area is stored.  We use current->end_text to
linux-4.15.18+/arch/s390/include/asm/user.h:28:   current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/s390/include/asm/user.h:35:   current->start_stack, so we round each of these off in order to be able
linux-4.15.18+/arch/s390/include/asm/mmu_context.h:31:		(current->mm && current->mm->context.alloc_pgste);
linux-4.15.18+/arch/s390/include/asm/mmu_context.h:125:	set_fs(current->thread.mm_segment);
linux-4.15.18+/arch/s390/include/asm/elf.h:172:	    !current->mm->context.alloc_pgste) {		\
linux-4.15.18+/arch/s390/include/asm/elf.h:231:		(current->personality & (~PER_MASK)));		\
linux-4.15.18+/arch/s390/include/asm/elf.h:232:	current->thread.sys_call_table =			\
linux-4.15.18+/arch/s390/include/asm/elf.h:238:	if (personality(current->personality) != PER_LINUX32)	\
linux-4.15.18+/arch/s390/include/asm/elf.h:240:			(current->personality & ~PER_MASK));	\
linux-4.15.18+/arch/s390/include/asm/elf.h:243:		current->thread.sys_call_table =		\
linux-4.15.18+/arch/s390/include/asm/elf.h:247:		current->thread.sys_call_table =		\
linux-4.15.18+/arch/s390/include/asm/elf.h:269:			    (unsigned long)current->mm->context.vdso_base); \
linux-4.15.18+/arch/s390/lib/uaccess.c:45:	current->thread.mm_segment = fs;
linux-4.15.18+/arch/s390/lib/uaccess.c:68:	old_fs = current->thread.mm_segment;
linux-4.15.18+/arch/s390/lib/uaccess.c:71:	current->thread.mm_segment |= 1;
linux-4.15.18+/arch/s390/lib/uaccess.c:92:	current->thread.mm_segment = old_fs;
linux-4.15.18+/arch/s390/mm/fault.c:122:		if (current->thread.mm_segment == USER_DS)
linux-4.15.18+/arch/s390/mm/fault.c:128:		if (current->thread.mm_segment & 1) {
linux-4.15.18+/arch/s390/mm/fault.c:129:			if (current->thread.mm_segment == USER_DS_SACF)
linux-4.15.18+/arch/s390/mm/fault.c:470:		current->thread.gmap_addr = address;
linux-4.15.18+/arch/s390/mm/fault.c:471:		current->thread.gmap_write_flag = !!(flags & FAULT_FLAG_WRITE);
linux-4.15.18+/arch/s390/mm/fault.c:472:		current->thread.gmap_int_code = regs->int_code & 0xffff;
linux-4.15.18+/arch/s390/mm/fault.c:539:				current->thread.gmap_pfault = 1;
linux-4.15.18+/arch/s390/mm/fault.c:553:		address =  __gmap_link(gmap, current->thread.gmap_addr,
linux-4.15.18+/arch/s390/mm/gmap.c:2157:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/s390/mm/gmap.c:2190:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/s390/mm/gup.c:227:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/s390/mm/mmap.c:25:	if (!(current->flags & PF_RANDOMIZE))
linux-4.15.18+/arch/s390/mm/mmap.c:27:	if (current->personality & ADDR_NO_RANDOMIZE)
linux-4.15.18+/arch/s390/mm/mmap.c:42:	if (current->personality & ADDR_COMPAT_LAYOUT)
linux-4.15.18+/arch/s390/mm/mmap.c:75:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/s390/mm/mmap.c:108:	if (addr + len > current->mm->context.asce_limit &&
linux-4.15.18+/arch/s390/mm/mmap.c:124:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/s390/mm/mmap.c:173:	if (addr + len > current->mm->context.asce_limit &&
linux-4.15.18+/arch/s390/mm/mmap.c:191:	if (current->flags & PF_RANDOMIZE)
linux-4.15.18+/arch/s390/mm/pgalloc.c:74:	if (current->active_mm == mm)
linux-4.15.18+/arch/s390/mm/pgalloc.c:126:	if (current->active_mm == mm) {
linux-4.15.18+/arch/s390/mm/pgalloc.c:138:	if (current->active_mm == mm)
linux-4.15.18+/arch/s390/mm/pgtable.c:808:		rc = get_guest_storage_key(current->mm, addr, &tmp);
linux-4.15.18+/arch/s390/mm/pgtable.c:820:	rc = set_guest_storage_key(current->mm, addr, key, nq);
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:25:	if (!current->thread.gs_cb) {
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:33:		current->thread.gs_cb = gs_cb;
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:41:	if (current->thread.gs_cb) {
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:43:		kfree(current->thread.gs_cb);
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:44:		current->thread.gs_cb = NULL;
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:55:	gs_cb = current->thread.gs_bc_cb;
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:60:		current->thread.gs_bc_cb = gs_cb;
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:71:	gs_cb = current->thread.gs_bc_cb;
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:72:	current->thread.gs_bc_cb = NULL;
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:83:	gs_cb = current->thread.gs_bc_cb;
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:85:		kfree(current->thread.gs_cb);
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:86:		current->thread.gs_bc_cb = NULL;
linux-4.15.18+/arch/s390/kernel/guarded_storage.c:89:		current->thread.gs_cb = gs_cb;
linux-4.15.18+/arch/s390/kernel/process.c:146:	current->thread.fpu.fpc = 0;
linux-4.15.18+/arch/s390/kernel/process.c:156:	fpregs->fpc = current->thread.fpu.fpc;
linux-4.15.18+/arch/s390/kernel/process.c:160:				 current->thread.fpu.vxrs);
linux-4.15.18+/arch/s390/kernel/process.c:162:		memcpy(&fpregs->fprs, current->thread.fpu.fprs,
linux-4.15.18+/arch/s390/kernel/process.c:194:	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
linux-4.15.18+/arch/s390/kernel/early.c:84:	/* Check current-configuration-level */
linux-4.15.18+/arch/s390/kernel/traps.c:34:		address = *(unsigned long *)(current->thread.trap_tdb + 24);
linux-4.15.18+/arch/s390/kernel/traps.c:87:	if (!current->ptrace)
linux-4.15.18+/arch/s390/kernel/traps.c:93:		(void __force __user *) current->thread.per_event.address;
linux-4.15.18+/arch/s390/kernel/traps.c:180:			if (current->ptrace) {
linux-4.15.18+/arch/s390/kernel/traps.c:224:	vic = (current->thread.fpu.fpc & 0xf00) >> 8;
linux-4.15.18+/arch/s390/kernel/traps.c:252:	if (current->thread.fpu.fpc & FPC_DXC_MASK)
linux-4.15.18+/arch/s390/kernel/traps.c:257:		do_fp_trap(regs, current->thread.fpu.fpc);
linux-4.15.18+/arch/s390/kernel/processor.c:82:	current->active_mm = &init_mm;
linux-4.15.18+/arch/s390/kernel/processor.c:83:	BUG_ON(current->mm);
linux-4.15.18+/arch/s390/kernel/vdso.c:87:	if (WARN_ON_ONCE(current->mm != vma->vm_mm))
linux-4.15.18+/arch/s390/kernel/vdso.c:90:	current->mm->context.vdso_base = vma->vm_start;
linux-4.15.18+/arch/s390/kernel/vdso.c:211:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/s390/kernel/vdso.c:269:	current->mm->context.vdso_base = vdso_base;
linux-4.15.18+/arch/s390/kernel/vtime.c:202:	S390_lowcore.user_timer = current->thread.user_timer;
linux-4.15.18+/arch/s390/kernel/vtime.c:203:	S390_lowcore.guest_timer = current->thread.guest_timer;
linux-4.15.18+/arch/s390/kernel/vtime.c:204:	S390_lowcore.system_timer = current->thread.system_timer;
linux-4.15.18+/arch/s390/kernel/vtime.c:205:	S390_lowcore.hardirq_timer = current->thread.hardirq_timer;
linux-4.15.18+/arch/s390/kernel/vtime.c:206:	S390_lowcore.softirq_timer = current->thread.softirq_timer;
linux-4.15.18+/arch/s390/kernel/signal.c:109:	save_access_regs(current->thread.acrs);
linux-4.15.18+/arch/s390/kernel/signal.c:116:	restore_access_regs(current->thread.acrs);
linux-4.15.18+/arch/s390/kernel/signal.c:130:	memcpy(&user_sregs.regs.acrs, current->thread.acrs,
linux-4.15.18+/arch/s390/kernel/signal.c:132:	fpregs_store(&user_sregs.fpregs, &current->thread.fpu);
linux-4.15.18+/arch/s390/kernel/signal.c:143:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/s390/kernel/signal.c:167:	memcpy(&current->thread.acrs, &user_sregs.regs.acrs,
linux-4.15.18+/arch/s390/kernel/signal.c:168:	       sizeof(current->thread.acrs));
linux-4.15.18+/arch/s390/kernel/signal.c:170:	fpregs_load(&user_sregs.fpregs, &current->thread.fpu);
linux-4.15.18+/arch/s390/kernel/signal.c:186:			vxrs[i] = *((__u64 *)(current->thread.fpu.vxrs + i) + 1);
linux-4.15.18+/arch/s390/kernel/signal.c:190:				   current->thread.fpu.vxrs + __NUM_VXRS_LOW,
linux-4.15.18+/arch/s390/kernel/signal.c:207:		    __copy_from_user(current->thread.fpu.vxrs + __NUM_VXRS_LOW,
linux-4.15.18+/arch/s390/kernel/signal.c:212:			*((__u64 *)(current->thread.fpu.vxrs + i) + 1) = vxrs[i];
linux-4.15.18+/arch/s390/kernel/signal.c:281:			sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/s390/kernel/signal.c:364:		regs->gprs[6] = current->thread.last_break;
linux-4.15.18+/arch/s390/kernel/signal.c:435:	regs->gprs[5] = current->thread.last_break;
linux-4.15.18+/arch/s390/kernel/signal.c:472:	current->thread.system_call =
linux-4.15.18+/arch/s390/kernel/signal.c:477:		if (current->thread.system_call) {
linux-4.15.18+/arch/s390/kernel/signal.c:478:			regs->int_code = current->thread.system_call;
linux-4.15.18+/arch/s390/kernel/signal.c:511:	if (current->thread.system_call) {
linux-4.15.18+/arch/s390/kernel/signal.c:512:		regs->int_code = current->thread.system_call;
linux-4.15.18+/arch/s390/kernel/sys_s390.c:84:	if (personality(current->personality) == PER_LINUX32 &&
linux-4.15.18+/arch/s390/kernel/perf_regs.c:26:		fp = MACHINE_HAS_VX ? *(freg_t *)(current->thread.fpu.vxrs + idx)
linux-4.15.18+/arch/s390/kernel/perf_regs.c:27:				    : current->thread.fpu.fprs[idx];
linux-4.15.18+/arch/s390/kernel/ftrace.c:210:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/s390/kernel/ftrace.c:214:	trace.depth = current->curr_ret_stack + 1;
linux-4.15.18+/arch/s390/kernel/runtime_instr.c:77:	if (!current->thread.ri_cb) {
linux-4.15.18+/arch/s390/kernel/runtime_instr.c:82:		cb = current->thread.ri_cb;
linux-4.15.18+/arch/s390/kernel/runtime_instr.c:90:	current->thread.ri_cb = cb;
linux-4.15.18+/arch/s390/kernel/uprobes.c:39:	regs->psw.addr = current->utask->xol_vaddr;
linux-4.15.18+/arch/s390/kernel/uprobes.c:71:		    regs->psw.addr >= current->thread.per_user.start &&
linux-4.15.18+/arch/s390/kernel/uprobes.c:72:		    regs->psw.addr <= current->thread.per_user.end)
linux-4.15.18+/arch/s390/kernel/uprobes.c:81:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/s390/kernel/uprobes.c:101:	if (check_per_event(current->thread.per_event.cause,
linux-4.15.18+/arch/s390/kernel/uprobes.c:102:			    current->thread.per_user.control, regs)) {
linux-4.15.18+/arch/s390/kernel/uprobes.c:104:		current->thread.per_event.address = utask->vaddr;
linux-4.15.18+/arch/s390/kernel/uprobes.c:139:	regs->psw.addr = current->utask->vaddr;
linux-4.15.18+/arch/s390/kernel/uprobes.c:140:	current->thread.per_event.address = current->utask->vaddr;
linux-4.15.18+/arch/s390/kernel/uprobes.c:245:	if (!(current->thread.per_user.control & PER_EVENT_STORE))
linux-4.15.18+/arch/s390/kernel/uprobes.c:247:	if ((void *)current->thread.per_user.start > (addr + len))
linux-4.15.18+/arch/s390/kernel/uprobes.c:249:	if ((void *)current->thread.per_user.end < addr)
linux-4.15.18+/arch/s390/kernel/uprobes.c:251:	current->thread.per_event.address = regs->psw.addr;
linux-4.15.18+/arch/s390/kernel/uprobes.c:252:	current->thread.per_event.cause = PER_EVENT_STORE >> 16;
linux-4.15.18+/arch/s390/kernel/compat_signal.c:156:	save_access_regs(current->thread.acrs);
linux-4.15.18+/arch/s390/kernel/compat_signal.c:163:	restore_access_regs(current->thread.acrs);
linux-4.15.18+/arch/s390/kernel/compat_signal.c:178:	memcpy(&user_sregs.regs.acrs, current->thread.acrs,
linux-4.15.18+/arch/s390/kernel/compat_signal.c:180:	fpregs_store((_s390_fp_regs *) &user_sregs.fpregs, &current->thread.fpu);
linux-4.15.18+/arch/s390/kernel/compat_signal.c:192:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/s390/kernel/compat_signal.c:216:	memcpy(&current->thread.acrs, &user_sregs.regs.acrs,
linux-4.15.18+/arch/s390/kernel/compat_signal.c:217:	       sizeof(current->thread.acrs));
linux-4.15.18+/arch/s390/kernel/compat_signal.c:218:	fpregs_load((_s390_fp_regs *) &user_sregs.fpregs, &current->thread.fpu);
linux-4.15.18+/arch/s390/kernel/compat_signal.c:241:			vxrs[i] = *((__u64 *)(current->thread.fpu.vxrs + i) + 1);
linux-4.15.18+/arch/s390/kernel/compat_signal.c:245:				   current->thread.fpu.vxrs + __NUM_VXRS_LOW,
linux-4.15.18+/arch/s390/kernel/compat_signal.c:270:		    __copy_from_user(current->thread.fpu.vxrs + __NUM_VXRS_LOW,
linux-4.15.18+/arch/s390/kernel/compat_signal.c:275:			*((__u64 *)(current->thread.fpu.vxrs + i) + 1) = vxrs[i];
linux-4.15.18+/arch/s390/kernel/compat_signal.c:347:			sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/s390/kernel/compat_signal.c:432:		regs->gprs[6] = current->thread.last_break;
linux-4.15.18+/arch/s390/kernel/compat_signal.c:507:	regs->gprs[5] = current->thread.last_break;
linux-4.15.18+/arch/s390/kernel/nmi.c:181:		       current->comm, current->pid);
linux-4.15.18+/arch/xtensa/include/asm/uaccess.h:36:#define get_fs()	(current->thread.current_ds)
linux-4.15.18+/arch/xtensa/include/asm/uaccess.h:37:#define set_fs(val)	(current->thread.current_ds = (val))
linux-4.15.18+/arch/xtensa/include/asm/asm-uaccess.h:38: * get_fs reads current->thread.current_ds into a register.
linux-4.15.18+/arch/xtensa/include/asm/asm-uaccess.h:43: * 	<ad>	contains current->thread.current_ds
linux-4.15.18+/arch/xtensa/include/asm/asm-uaccess.h:56: * set_fs sets current->thread.current_ds to some value.
linux-4.15.18+/arch/xtensa/include/asm/asm-uaccess.h:87: * 	<at>		destroyed (actually, current->thread.current_ds)
linux-4.15.18+/arch/xtensa/include/asm/elf.h:194:	set_personality(PER_LINUX_32BIT | (current->personality & (~PER_MASK)))
linux-4.15.18+/arch/xtensa/mm/fault.c:41:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/xtensa/mm/fault.c:72:	printk("[%s:%d:%08x:%d:%08x:%s%s]\n", current->comm, current->pid,
linux-4.15.18+/arch/xtensa/mm/fault.c:129:			current->maj_flt++;
linux-4.15.18+/arch/xtensa/mm/fault.c:131:			current->min_flt++;
linux-4.15.18+/arch/xtensa/mm/fault.c:160:		current->thread.bad_vaddr = address;
linux-4.15.18+/arch/xtensa/mm/fault.c:161:		current->thread.error_code = is_write;
linux-4.15.18+/arch/xtensa/mm/fault.c:190:	current->thread.bad_vaddr = address;
linux-4.15.18+/arch/xtensa/mm/fault.c:207:		struct mm_struct *act_mm = current->active_mm;
linux-4.15.18+/arch/xtensa/mm/fault.c:252:				current->comm, regs->pc, entry->fixup);
linux-4.15.18+/arch/xtensa/mm/fault.c:254:		current->thread.bad_uaddr = address;
linux-4.15.18+/arch/xtensa/mm/tlb.c:67:	if (mm == current->active_mm) {
linux-4.15.18+/arch/xtensa/kernel/ptrace.c:286:			if (current->thread.ptrace_bp[i] == bp)
linux-4.15.18+/arch/xtensa/kernel/ptrace.c:291:			if (current->thread.ptrace_wp[i] == bp)
linux-4.15.18+/arch/xtensa/kernel/traps.c:187:	       current->comm, task_pid_nr(current), regs->pc, exccause);
linux-4.15.18+/arch/xtensa/kernel/traps.c:309:	    current->comm, task_pid_nr(current), regs->pc);
linux-4.15.18+/arch/xtensa/kernel/traps.c:330:	current->thread.bad_vaddr = regs->excvaddr;
linux-4.15.18+/arch/xtensa/kernel/traps.c:331:	current->thread.error_code = -3;
linux-4.15.18+/arch/xtensa/kernel/traps.c:334:	       regs->excvaddr, current->comm, task_pid_nr(current), regs->pc);
linux-4.15.18+/arch/xtensa/kernel/signal.c:249:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/xtensa/kernel/signal.c:345:		sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/xtensa/kernel/signal.c:404:		current->comm, current->pid, sig, frame, regs->pc);
linux-4.15.18+/arch/xtensa/kernel/signal.c:462:		if (current->ptrace & PT_SINGLESTEP)
linux-4.15.18+/arch/xtensa/kernel/signal.c:488:	if (current->ptrace & PT_SINGLESTEP)
linux-4.15.18+/arch/xtensa/kernel/syscall.c:87:	for (vmm = find_vma(current->mm, addr); ; vmm = vmm->vm_next) {
linux-4.15.18+/arch/xtensa/kernel/smp.c:143:	current->active_mm = mm;
linux-4.15.18+/arch/tile/include/asm/switch_to.h:60:		(current->pid << _SIM_CONTROL_OPERATOR_BITS));            \
linux-4.15.18+/arch/tile/include/asm/switch_to.h:61:	if (current->mm == NULL && !kstack_hash &&                        \
linux-4.15.18+/arch/tile/include/asm/processor.h:173:#define VDSO_BASE	((unsigned long)current->active_mm->context.vdso_base)
linux-4.15.18+/arch/tile/include/asm/elf.h:167:	set_personality(PER_LINUX | (current->personality & (~PER_MASK))); \
linux-4.15.18+/arch/tile/include/asm/elf.h:172:	set_personality(PER_LINUX | (current->personality & (~PER_MASK))); \
linux-4.15.18+/arch/tile/include/asm/mmu_context.h:88:	if (current->thread.tile_dma_state.enabled)
linux-4.15.18+/arch/tile/mm/mmap.c:38:	if (current->flags & PF_RANDOMIZE)
linux-4.15.18+/arch/tile/mm/mmap.c:68:	if (current->flags & PF_RANDOMIZE) {
linux-4.15.18+/arch/tile/mm/fault.c:526:				current->uid);
linux-4.15.18+/arch/tile/mm/fault.c:753:				 current->comm, current->pid, pc, address);
linux-4.15.18+/arch/tile/mm/fault.c:814:			async = &current->thread.dma_async_tlb;
linux-4.15.18+/arch/tile/mm/fault.c:860:	struct async_tlb *async = &current->thread.dma_async_tlb;
linux-4.15.18+/arch/tile/mm/hugetlbpage.c:193:	info.high_limit = current->mm->mmap_base;
linux-4.15.18+/arch/tile/mm/hugetlbpage.c:219:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/tile/mm/hugetlbpage.c:240:	if (current->mm->get_unmapped_area == arch_get_unmapped_area)
linux-4.15.18+/arch/tile/mm/elf.c:64:	for (vma = current->mm->mmap; ; vma = vma->vm_next) {
linux-4.15.18+/arch/tile/mm/elf.c:120:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/tile/kernel/smpboot.c:69:	rc = sched_setaffinity(current->pid, cpumask_of(boot_cpu));
linux-4.15.18+/arch/tile/kernel/smpboot.c:129:	long rc = sched_setaffinity(current->pid, &init_affinity);
linux-4.15.18+/arch/tile/kernel/smpboot.c:165:	current->active_mm = &init_mm;
linux-4.15.18+/arch/tile/kernel/smpboot.c:166:	if (current->mm)
linux-4.15.18+/arch/tile/kernel/smpboot.c:266:	rc = sched_setaffinity(current->pid, cpumask_of(cpu));
linux-4.15.18+/arch/tile/kernel/machine_kexec.c:253:		pgd_t *pgd = pgd_offset(current->mm, vaddr);
linux-4.15.18+/arch/tile/kernel/vdso.c:128:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/tile/kernel/traps.c:94:		       current->pid, current->comm);
linux-4.15.18+/arch/tile/kernel/traps.c:95:		BUG_ON(current->thread.tile_dma_state.enabled);
linux-4.15.18+/arch/tile/kernel/traps.c:96:		current->thread.tile_dma_state.enabled = 1;
linux-4.15.18+/arch/tile/kernel/process.c:131:	p->thread.creator_pid = current->pid;
linux-4.15.18+/arch/tile/kernel/process.c:417:	struct tile_dma_state *dma = &current->thread.tile_dma_state;
linux-4.15.18+/arch/tile/kernel/signal.c:53:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/tile/kernel/signal.c:138:			sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/tile/kernel/tlb.c:50:	flush_tlb_mm(current->mm);
linux-4.15.18+/arch/tile/kernel/single_step.c:226:			current->pid, current->comm, regs->pc,
linux-4.15.18+/arch/tile/kernel/ftrace.c:180:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/tile/kernel/ftrace.c:197:		current->curr_ret_stack--;
linux-4.15.18+/arch/tile/kernel/compat_signal.c:177:			sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/tile/kernel/sys.c:47:		flush_remote(0, HV_FLUSH_EVICT_L1I, mm_cpumask(current->mm),
linux-4.15.18+/arch/tile/kernel/stack.c:530:	if (current->mm)
linux-4.15.18+/arch/tile/kernel/hardwall.c:476:		current->thread.hardwall[HARDWALL_IPI].info;
linux-4.15.18+/arch/tile/kernel/hardwall.c:1011:		if (current->thread.hardwall[hwt->index].info != info)
linux-4.15.18+/arch/tile/kernel/unaligned.c:975:				current->comm, current->pid, regs->regs[ra]);
linux-4.15.18+/arch/tile/kernel/unaligned.c:1375:				current->comm, current->pid,
linux-4.15.18+/arch/tile/kernel/unaligned.c:1406:				current->pid, current->comm,
linux-4.15.18+/arch/tile/kernel/unaligned.c:1566:				(current->pid << PAGE_SHIFT);
linux-4.15.18+/arch/tile/kernel/unaligned.c:1589:				raw_smp_processor_id(), current->pid,
linux-4.15.18+/arch/powerpc/perf/callchain.c:126:	pgdir = current->mm->pgd;
linux-4.15.18+/arch/powerpc/perf/callchain.c:213:	if (vdso64_rt_sigtramp && current->mm->context.vdso_base &&
linux-4.15.18+/arch/powerpc/perf/callchain.c:214:	    nip == current->mm->context.vdso_base + vdso64_rt_sigtramp)
linux-4.15.18+/arch/powerpc/perf/callchain.c:372:	if (vdso32_sigtramp && current->mm->context.vdso_base &&
linux-4.15.18+/arch/powerpc/perf/callchain.c:373:	    nip == current->mm->context.vdso_base + vdso32_sigtramp)
linux-4.15.18+/arch/powerpc/perf/callchain.c:383:	if (vdso32_rt_sigtramp && current->mm->context.vdso_base &&
linux-4.15.18+/arch/powerpc/perf/callchain.c:384:	    nip == current->mm->context.vdso_base + vdso32_rt_sigtramp)
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:552:	if (!is_ebb_event(event) || current->thread.used_ebb)
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:561:	current->thread.used_ebb = 1;
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:562:	current->thread.mmcr0 |= MMCR0_PMXE;
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:570:	current->thread.siar  = mfspr(SPRN_SIAR);
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:571:	current->thread.sier  = mfspr(SPRN_SIER);
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:572:	current->thread.sdar  = mfspr(SPRN_SDAR);
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:573:	current->thread.mmcr0 = mmcr0 & MMCR0_USER_MASK;
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:574:	current->thread.mmcr2 = mfspr(SPRN_MMCR2) & MMCR2_USER_MASK;
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:592:	mmcr0 |= current->thread.mmcr0;
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:599:	if (!(current->thread.mmcr0 & MMCR0_PMXE))
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:602:	mtspr(SPRN_SIAR, current->thread.siar);
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:603:	mtspr(SPRN_SIER, current->thread.sier);
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:604:	mtspr(SPRN_SDAR, current->thread.sdar);
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:613:	mtspr(SPRN_MMCR2, cpuhw->mmcr[3] | current->thread.mmcr2);
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:658:	if ((current->thread.mmcr0 & (MMCR0_PMAO | MMCR0_PMAO_SYNC)) != MMCR0_PMAO)
linux-4.15.18+/arch/powerpc/perf/core-book3s.c:662:	if (ebb && !(current->thread.bescr & BESCR_GE))
linux-4.15.18+/arch/powerpc/platforms/powernv/npu-dma.c:662:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/platforms/powernv/smp.c:165:	current->active_mm = NULL; /* for sanity */
linux-4.15.18+/arch/powerpc/platforms/chrp/nvram.c:34:		       current->comm, addr, nvram_size);
linux-4.15.18+/arch/powerpc/platforms/chrp/nvram.c:55:		       current->comm, addr, nvram_size);
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/fault.c:152:		ret = copro_handle_mm_fault(current->mm, ea, dsisr, &flt);
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/file.c:350:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/file.c:354:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/file.c:1466:	if (ctx->owner != current->mm)
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/coredump.c:99:	int n = iterate_fd(current->files, *fd, match_context, NULL);
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/sched.c:122:	ctx->tid = current->pid;
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/sched.c:130:	if (rt_prio(current->prio))
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/sched.c:131:		ctx->prio = current->prio;
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/sched.c:133:		ctx->prio = current->static_prio;
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/sched.c:134:	ctx->policy = current->policy;
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/sched.c:144:	cpumask_copy(&ctx->cpus_allowed, &current->cpus_allowed);
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/sched.c:242:	spu->pid = current->pid;
linux-4.15.18+/arch/powerpc/platforms/cell/spufs/sched.c:243:	spu->tgid = current->tgid;
linux-4.15.18+/arch/powerpc/platforms/pseries/ras.c:463:		       "%s:%d\n", current->comm, current->pid);
linux-4.15.18+/arch/powerpc/kvm/book3s_32_sr.S:136:	/* 'current->mm' needs to be in r4 */
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_hv.c:309:				current->mm->pgd, false, pte_idx_ret);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_hv.c:587:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_hv.c:588:		vma = find_vma(current->mm, hva);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_hv.c:597:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_hv.c:616:			ptep = find_current_mm_pte(current->mm->pgd,
linux-4.15.18+/arch/powerpc/kvm/booke_emulate.c:384:		current->thread.debug = vcpu->arch.dbg_reg;
linux-4.15.18+/arch/powerpc/kvm/e500_mmu_host.c:361:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/e500_mmu_host.c:363:		vma = find_vma(current->mm, hva);
linux-4.15.18+/arch/powerpc/kvm/e500_mmu_host.c:447:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_pr.c:112:	current->thread.kvm_shadow_vcpu = vcpu->arch.shadow_vcpu;
linux-4.15.18+/arch/powerpc/kvm/book3s_pr.c:656:	struct thread_struct *t = &current->thread;
linux-4.15.18+/arch/powerpc/kvm/book3s_pr.c:686:		if (current->thread.regs->msr & MSR_VEC)
linux-4.15.18+/arch/powerpc/kvm/book3s_pr.c:708:		mtspr(SPRN_TAR, current->thread.tar);
linux-4.15.18+/arch/powerpc/kvm/book3s_pr.c:719:	struct thread_struct *t = &current->thread;
linux-4.15.18+/arch/powerpc/kvm/book3s_pr.c:791:	lost_ext = vcpu->arch.guest_owned_ext & ~current->thread.regs->msr;
linux-4.15.18+/arch/powerpc/kvm/book3s_pr.c:811:	current->thread.regs->msr |= lost_ext;
linux-4.15.18+/arch/powerpc/kvm/book3s_pr.c:869:		current->thread.tar = mfspr(SPRN_TAR);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:64:	if (!current || !current->mm)
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:67:	down_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:72:		locked = current->mm->locked_vm + stt_pages;
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:77:			current->mm->locked_vm += stt_pages;
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:79:		if (WARN_ON_ONCE(stt_pages > current->mm->locked_vm))
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:80:			stt_pages = current->mm->locked_vm;
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:82:		current->mm->locked_vm -= stt_pages;
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:85:	pr_debug("[%d] RLIMIT_MEMLOCK KVM %c%ld %ld/%ld%s\n", current->pid,
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:88:			current->mm->locked_vm << PAGE_SHIFT,
linux-4.15.18+/arch/powerpc/kvm/book3s_64_vio.c:92:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/booke.c:144:	if (!(current->thread.regs->msr & MSR_FP)) {
linux-4.15.18+/arch/powerpc/kvm/booke.c:148:		current->thread.fp_save_area = &vcpu->arch.fp;
linux-4.15.18+/arch/powerpc/kvm/booke.c:149:		current->thread.regs->msr |= MSR_FP;
linux-4.15.18+/arch/powerpc/kvm/booke.c:161:	if (current->thread.regs->msr & MSR_FP)
linux-4.15.18+/arch/powerpc/kvm/booke.c:163:	current->thread.fp_save_area = NULL;
linux-4.15.18+/arch/powerpc/kvm/booke.c:186:		if (!(current->thread.regs->msr & MSR_VEC)) {
linux-4.15.18+/arch/powerpc/kvm/booke.c:190:			current->thread.vr_save_area = &vcpu->arch.vr;
linux-4.15.18+/arch/powerpc/kvm/booke.c:191:			current->thread.regs->msr |= MSR_VEC;
linux-4.15.18+/arch/powerpc/kvm/booke.c:205:		if (current->thread.regs->msr & MSR_VEC)
linux-4.15.18+/arch/powerpc/kvm/booke.c:207:		current->thread.vr_save_area = NULL;
linux-4.15.18+/arch/powerpc/kvm/booke.c:776:	debug = current->thread.debug;
linux-4.15.18+/arch/powerpc/kvm/booke.c:777:	current->thread.debug = vcpu->arch.dbg_reg;
linux-4.15.18+/arch/powerpc/kvm/booke.c:779:	vcpu->arch.pgdir = current->mm->pgd;
linux-4.15.18+/arch/powerpc/kvm/booke.c:789:	current->thread.debug = debug;
linux-4.15.18+/arch/powerpc/kvm/booke.c:2068:	current->thread.kvm_vcpu = vcpu;
linux-4.15.18+/arch/powerpc/kvm/booke.c:2073:	current->thread.kvm_vcpu = NULL;
linux-4.15.18+/arch/powerpc/kvm/timing.c:225:		 current->pid, id);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3314:	if (cpu_has_feature(CPU_FTR_TM) && current->thread.regs &&
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3315:	    (current->thread.regs->msr & MSR_TM)) {
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3316:		if (MSR_TM_ACTIVE(current->thread.regs->msr)) {
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3323:		current->thread.tm_tfhar = mfspr(SPRN_TFHAR);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3324:		current->thread.tm_tfiar = mfspr(SPRN_TFIAR);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3325:		current->thread.tm_texasr = mfspr(SPRN_TEXASR);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3326:		current->thread.regs->msr &= ~MSR_TM;
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3355:	vcpu->arch.pgdir = current->mm->pgd;
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3386:		mtspr(SPRN_FSCR, current->thread.fscr);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3652:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3653:	vma = find_vma(current->mm, hva);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3660:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3690:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_hv.c:3925:	snprintf(buf, sizeof(buf), "vm%d", current->pid);
linux-4.15.18+/arch/powerpc/kvm/trace_hv.h:404:		__entry->tgid		= current->tgid;
linux-4.15.18+/arch/powerpc/kvm/trace_hv.h:428:		__entry->tgid	     = current->tgid;
linux-4.15.18+/arch/powerpc/kvm/trace_hv.h:450:		__entry->tgid   = current->tgid;
linux-4.15.18+/arch/powerpc/kvm/trace_hv.h:470:		__entry->tgid	  = current->tgid;
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_radix.c:363:		ptep = find_current_mm_pte(current->mm->pgd, hva, NULL, NULL);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_radix.c:401:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_radix.c:402:		vma = find_vma(current->mm, hva);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_radix.c:409:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/kvm/book3s_64_mmu_radix.c:434:			ptep = find_current_mm_pte(current->mm->pgd,
linux-4.15.18+/arch/powerpc/kvm/mpic.c:117:	struct kvm_vcpu *vcpu = current->thread.kvm_vcpu;
linux-4.15.18+/arch/powerpc/xmon/xmon.c:1630:		       current->pid, current->comm);
linux-4.15.18+/arch/powerpc/include/asm/compat.h:208:	struct pt_regs *regs = current->thread.regs;
linux-4.15.18+/arch/powerpc/include/asm/sfp-machine.h:108:#define __FPU_FPSCR	(current->thread.spefscr)
linux-4.15.18+/arch/powerpc/include/asm/sfp-machine.h:128:#define __FPU_FPSCR	(current->thread.fp_state.fpscr)
linux-4.15.18+/arch/powerpc/include/asm/uaccess.h:33:#define get_fs()	(current->thread.fs)
linux-4.15.18+/arch/powerpc/include/asm/uaccess.h:34:#define set_fs(val)	(current->thread.fs = (val))
linux-4.15.18+/arch/powerpc/include/asm/user.h:22: *  data: The data segment follows next.  We use current->end_text to
linux-4.15.18+/arch/powerpc/include/asm/user.h:23: *	current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/powerpc/include/asm/user.h:30: *	current->start_stack, so we round each of these in order to be able
linux-4.15.18+/arch/powerpc/include/asm/elf.h:99:	if (personality(current->personality) != PER_LINUX32)	\
linux-4.15.18+/arch/powerpc/include/asm/elf.h:101:			(current->personality & (~PER_MASK)));	\
linux-4.15.18+/arch/powerpc/include/asm/elf.h:178:	VDSO_AUX_ENT(AT_SYSINFO_EHDR, current->mm->context.vdso_base);	\
linux-4.15.18+/arch/powerpc/include/asm/page.h:246:	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
linux-4.15.18+/arch/powerpc/include/asm/mmu_context.h:153: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/powerpc/include/asm/pte-walk.h:30:	VM_WARN(pgdir != current->mm->pgd,
linux-4.15.18+/arch/powerpc/lib/sstep.c:499:		current->thread.TS_FPR(rn) = u.l[0];
linux-4.15.18+/arch/powerpc/lib/sstep.c:506:			current->thread.TS_FPR(rn) = u.l[1];
linux-4.15.18+/arch/powerpc/lib/sstep.c:533:		u.l[0] = current->thread.TS_FPR(rn);
linux-4.15.18+/arch/powerpc/lib/sstep.c:545:			u.l[1] = current->thread.TS_FPR(rn);
linux-4.15.18+/arch/powerpc/lib/sstep.c:583:		current->thread.vr_state.vr[rn] = u.v;
linux-4.15.18+/arch/powerpc/lib/sstep.c:606:		u.v = current->thread.vr_state.vr[rn];
linux-4.15.18+/arch/powerpc/lib/sstep.c:839:			current->thread.fp_state.fpr[reg][0] = buf.d[0];
linux-4.15.18+/arch/powerpc/lib/sstep.c:840:			current->thread.fp_state.fpr[reg][1] = buf.d[1];
linux-4.15.18+/arch/powerpc/lib/sstep.c:846:			current->thread.vr_state.vr[reg - 32] = buf.v;
linux-4.15.18+/arch/powerpc/lib/sstep.c:870:			buf.d[0] = current->thread.fp_state.fpr[reg][0];
linux-4.15.18+/arch/powerpc/lib/sstep.c:871:			buf.d[1] = current->thread.fp_state.fpr[reg][1];
linux-4.15.18+/arch/powerpc/lib/sstep.c:877:			buf.v = current->thread.vr_state.vr[reg - 32];
linux-4.15.18+/arch/powerpc/lib/sstep.c:2592:	if (ea - STACK_INT_FRAME_SIZE <= current->thread.ksp_limit) {
linux-4.15.18+/arch/powerpc/boot/dts/ep405.dts:101:				current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/ep405.dts:112:				current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/tqm8548.dts:306:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/tqm8548.dts:317:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/taishan.dts:227:				current-speed = <115200>; /* 115200 */
linux-4.15.18+/arch/powerpc/boot/dts/taishan.dts:238:				current-speed = <115200>; /* 115200 */
linux-4.15.18+/arch/powerpc/boot/dts/akebono.dts:214:				current-speed = <38400>;
linux-4.15.18+/arch/powerpc/boot/dts/c2k.dts:149:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/c2k.dts:157:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/bamboo.dts:151:		   		current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/bamboo.dts:162:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/bamboo.dts:173:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/bamboo.dts:184:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/mgcoge.dts:147:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/xpedite5200_xmon.dts:343:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/xpedite5200_xmon.dts:354:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/bluestone.dts:258:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/bluestone.dts:269:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/fsp2.dts:580:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/eiger.dts:242:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/eiger.dts:253:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/iss4xx.dts:97:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/currituck.dts:101:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/hotfoot.dts:103:				current-speed = <0x9600>;
linux-4.15.18+/arch/powerpc/boot/dts/hotfoot.dts:114:				current-speed = <0x9600>;
linux-4.15.18+/arch/powerpc/boot/dts/obs600.dts:201:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/obs600.dts:212:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/kilauea.dts:216:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/kilauea.dts:227:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/haleakala.dts:172:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/haleakala.dts:183:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/amigaone.dts:135:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/amigaone.dts:144:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/mvme5100.dts:60:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/mvme5100.dts:71:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/iss4xx-mpic.dts:136:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/makalu.dts:173:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/makalu.dts:184:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/holly.dts:111:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/holly.dts:122:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/rainier.dts:195:		   		current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/rainier.dts:206:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/rainier.dts:217:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/rainier.dts:228:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/warp.dts:219:		   		current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/kuroboxHG.dts:90:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/kuroboxHG.dts:101:			current-speed = <57600>;
linux-4.15.18+/arch/powerpc/boot/dts/walnut.dts:101:				current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/walnut.dts:112:				current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/redwood.dts:200:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/storcenter.dts:80:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/storcenter.dts:91:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/xpedite5200.dts:339:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/xpedite5200.dts:350:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/sequoia.dts:244:		   		current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/sequoia.dts:255:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/sequoia.dts:266:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/sequoia.dts:277:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/katmai.dts:212:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/katmai.dts:223:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/katmai.dts:235:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/fsl/t1024rdb.dts:150:			current-sensor@40 {
linux-4.15.18+/arch/powerpc/boot/dts/fsl/mpc8560ads.dts:260:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/fsl/mpc8560ads.dts:272:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/fsl/t1023rdb.dts:131:			current-sensor@40 {
linux-4.15.18+/arch/powerpc/boot/dts/fsl/t1023rdb.dts:137:			current-sensor@41 {
linux-4.15.18+/arch/powerpc/boot/dts/kuroboxHD.dts:90:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/kuroboxHD.dts:101:			current-speed = <57600>;
linux-4.15.18+/arch/powerpc/boot/dts/ksi8560.dts:257:				current-speed = <0x1c200>;
linux-4.15.18+/arch/powerpc/boot/dts/ksi8560.dts:269:				current-speed = <0x1c200>;
linux-4.15.18+/arch/powerpc/boot/dts/yosemite.dts:185:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/yosemite.dts:196:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/yosemite.dts:207:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/yosemite.dts:219:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/adder875-redboot.dts:175:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/adder875-uboot.dts:174:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/arches.dts:229:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/tqm8560.dts:275:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/tqm8560.dts:287:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/icon.dts:215:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/icon.dts:226:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/icon.dts:238:				current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/sam440ep.dts:152:		   		current-speed = <0x1c200>;
linux-4.15.18+/arch/powerpc/boot/dts/sam440ep.dts:163:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/sam440ep.dts:174:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/sam440ep.dts:185:		   		current-speed = <0>;
linux-4.15.18+/arch/powerpc/boot/dts/acadia.dts:97:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/acadia.dts:107:				current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/canyonlands.dts:298:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/canyonlands.dts:309:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/virtex440-ml507.dts:351:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/glacier.dts:244:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/glacier.dts:255:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/glacier.dts:266:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/glacier.dts:277:				current-speed = <0>; /* Filled in by U-Boot */
linux-4.15.18+/arch/powerpc/boot/dts/ebony.dts:203:				current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/ebony.dts:214:				current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/virtex440-ml510.dts:304:			current-speed = <9600>;
linux-4.15.18+/arch/powerpc/boot/dts/tqm8548-bigflash.dts:306:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/dts/tqm8548-bigflash.dts:317:			current-speed = <115200>;
linux-4.15.18+/arch/powerpc/boot/cuboot-acadia.c:126:	if (getprop(np, "current-speed", &baud, sizeof(baud)) != sizeof(baud))
linux-4.15.18+/arch/powerpc/boot/cuboot-acadia.c:127:		fatal("no current-speed property\n\r");
linux-4.15.18+/arch/powerpc/boot/virtex.c:46:	n = getprop(devp, "current-speed", (void *)&spd, sizeof(spd));
linux-4.15.18+/arch/powerpc/sysdev/mv64x60_dev.c:147:	prop = of_get_property(brg, "current-speed", NULL);
linux-4.15.18+/arch/powerpc/sysdev/fsl_soc.c:149:		of_property_read_u32(node, "current-speed", &fs_baudrate);
linux-4.15.18+/arch/powerpc/mm/mmu_context_iommu.c:59:			current ? current->pid : 0,
linux-4.15.18+/arch/powerpc/mm/slice.c:195:	if (mm != current->active_mm)
linux-4.15.18+/arch/powerpc/mm/slice.c:198:	copy_mm_to_paca(current->active_mm);
linux-4.15.18+/arch/powerpc/mm/slice.c:425:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/slice.c:615:				       current->mm->context.user_psize, 0);
linux-4.15.18+/arch/powerpc/mm/slice.c:625:				       current->mm->context.user_psize, 1);
linux-4.15.18+/arch/powerpc/mm/pgtable.c:36:	return current->thread.regs && TRAP(current->thread.regs) == 0x400;
linux-4.15.18+/arch/powerpc/mm/fault.c:132:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/fault.c:162:	current->thread.trap_nr = BUS_ADRERR;
linux-4.15.18+/arch/powerpc/mm/fault.c:170:			current->comm, current->pid, address);
linux-4.15.18+/arch/powerpc/mm/fault.c:243:		struct pt_regs *uregs = current->thread.regs;
linux-4.15.18+/arch/powerpc/mm/fault.c:387:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/fault.c:532:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/powerpc/mm/fault.c:541:		current->maj_flt++;
linux-4.15.18+/arch/powerpc/mm/fault.c:545:		current->min_flt++;
linux-4.15.18+/arch/powerpc/mm/copro_fault.c:93:		current->maj_flt++;
linux-4.15.18+/arch/powerpc/mm/copro_fault.c:95:		current->min_flt++;
linux-4.15.18+/arch/powerpc/mm/mmap.c:44:	if (current->personality & ADDR_COMPAT_LAYOUT)
linux-4.15.18+/arch/powerpc/mm/mmap.c:69:	if (!(current->flags & PF_RANDOMIZE))
linux-4.15.18+/arch/powerpc/mm/mmap.c:107:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/mmap.c:151:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/mmap.c:222:	if (current->flags & PF_RANDOMIZE)
linux-4.15.18+/arch/powerpc/mm/subpage-prot.c:95:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/subpage-prot.c:190:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/hugetlbpage-radix.c:49:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/mem.c:534:	trap = current->thread.regs ? TRAP(current->thread.regs) : 0UL;
linux-4.15.18+/arch/powerpc/mm/hash_utils_64.c:1133:	if ((get_paca_psize(addr) != MMU_PAGE_4K) && (current->mm == mm)) {
linux-4.15.18+/arch/powerpc/mm/hash_utils_64.c:1197:		ea, access, current->comm);
linux-4.15.18+/arch/powerpc/mm/hash_utils_64.c:1338:		if (current->mm == mm)
linux-4.15.18+/arch/powerpc/mm/hash_utils_64.c:1381:	if (current->mm == mm)
linux-4.15.18+/arch/powerpc/mm/hash_utils_64.c:1423:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/hash_utils_64.c:1440:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/mm/hash_utils_64.c:1583:	if (local && cpu_has_feature(CPU_FTR_TM) && current->thread.regs &&
linux-4.15.18+/arch/powerpc/mm/hash_utils_64.c:1584:	    MSR_TM_ACTIVE(current->thread.regs->msr)) {
linux-4.15.18+/arch/powerpc/math-emu/math.c:332:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:333:		op1 = (void *)&current->thread.TS_FPR((insn >> 16) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:334:		op2 = (void *)&current->thread.TS_FPR((insn >> 11) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:338:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:339:		op1 = (void *)&current->thread.TS_FPR((insn >> 16) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:340:		op2 = (void *)&current->thread.TS_FPR((insn >>  6) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:344:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:345:		op1 = (void *)&current->thread.TS_FPR((insn >> 16) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:346:		op2 = (void *)&current->thread.TS_FPR((insn >> 11) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:347:		op3 = (void *)&current->thread.TS_FPR((insn >>  6) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:353:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:363:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:368:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:372:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:373:		op1 = (void *)&current->thread.TS_FPR((insn >> 16) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:377:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:378:		op1 = (void *)&current->thread.TS_FPR((insn >> 11) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:383:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:392:		op0 = (void *)&current->thread.TS_FPR((insn >> 21) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:400:		op2 = (void *)&current->thread.TS_FPR((insn >> 16) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:401:		op3 = (void *)&current->thread.TS_FPR((insn >> 11) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math.c:421:		op1 = (void *)&current->thread.TS_FPR((insn >> 11) & 0x1f);
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:203:	vc.wp[0] = current->thread.evr[fc];
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:205:	va.wp[0] = current->thread.evr[fa];
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:207:	vb.wp[0] = current->thread.evr[fb];
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:680:	  &= ~(FP_EX_INVALID | FP_EX_UNDERFLOW) | current->thread.spefscr_last;
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:683:	current->thread.spefscr_last = __FPU_FPSCR;
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:685:	current->thread.evr[fc] = vc.wp[0];
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:695:	if (current->thread.fpexc_mode & PR_FP_EXC_SW_ENABLE) {
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:697:		    && (current->thread.fpexc_mode & PR_FP_EXC_DIV))
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:700:		    && (current->thread.fpexc_mode & PR_FP_EXC_OVF))
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:703:		    && (current->thread.fpexc_mode & PR_FP_EXC_UND))
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:706:		    && (current->thread.fpexc_mode & PR_FP_EXC_RES))
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:709:		    && (current->thread.fpexc_mode & PR_FP_EXC_INV))
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:756:	s_hi = current->thread.evr[fc] & SIGN_BIT_S;
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:757:	fgpr.wp[0] = current->thread.evr[fc];
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:802:			s_hi = current->thread.evr[fb] & SIGN_BIT_S;
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:811:			s_hi = current->thread.evr[fb] & SIGN_BIT_S;
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:883:	current->thread.evr[fc] = fgpr.wp[0];
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:888:	if (current->thread.fpexc_mode & PR_FP_EXC_SW_ENABLE)
linux-4.15.18+/arch/powerpc/math-emu/math_efp.c:889:		return (current->thread.fpexc_mode & PR_FP_EXC_RES) ? 1 : 0;
linux-4.15.18+/arch/powerpc/kernel/vecemu.c:275:	vrs = current->thread.vr_state.vr;
linux-4.15.18+/arch/powerpc/kernel/vecemu.c:324:					&current->thread.vr_state.vscr.u[3]);
linux-4.15.18+/arch/powerpc/kernel/vecemu.c:329:					&current->thread.vr_state.vscr.u[3]);
linux-4.15.18+/arch/powerpc/kernel/pci-common.c:661:			       current->comm, current->pid, pci_domain_nr(bus), bus->number);
linux-4.15.18+/arch/powerpc/kernel/process.c:238:	if (current->thread.regs && (current->thread.regs->msr & MSR_FP)) {
linux-4.15.18+/arch/powerpc/kernel/process.c:247:		if(!msr_tm_active(cpumsr) && msr_tm_active(current->thread.regs->msr))
linux-4.15.18+/arch/powerpc/kernel/process.c:257:		load_fp_state(&current->thread.fp_state);
linux-4.15.18+/arch/powerpc/kernel/process.c:258:		current->thread.load_fp++;
linux-4.15.18+/arch/powerpc/kernel/process.c:302:	if (current->thread.regs && (current->thread.regs->msr & MSR_VEC)) {
linux-4.15.18+/arch/powerpc/kernel/process.c:311:		if(!msr_tm_active(cpumsr) && msr_tm_active(current->thread.regs->msr))
linux-4.15.18+/arch/powerpc/kernel/process.c:387:	if (current->thread.regs &&
linux-4.15.18+/arch/powerpc/kernel/process.c:388:	    (current->thread.regs->msr & (MSR_VSX|MSR_VEC|MSR_FP))) {
linux-4.15.18+/arch/powerpc/kernel/process.c:397:		if(!msr_tm_active(cpumsr) && msr_tm_active(current->thread.regs->msr))
linux-4.15.18+/arch/powerpc/kernel/process.c:447:	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
linux-4.15.18+/arch/powerpc/kernel/process.c:531:		!current->thread.load_fp && !loadvec(current->thread))
linux-4.15.18+/arch/powerpc/kernel/process.c:542:		msr |= MSR_FP | current->thread.fpexc_mode;
linux-4.15.18+/arch/powerpc/kernel/process.c:608:	current->thread.trap_nr = signal_code;
linux-4.15.18+/arch/powerpc/kernel/process.c:626:	current->thread.trap_nr = TRAP_HWBKPT;
linux-4.15.18+/arch/powerpc/kernel/process.c:713:	if ((current->thread.debug.dbcr0 & DBCR0_IDM)
linux-4.15.18+/arch/powerpc/kernel/process.c:904:	tm_reclaim_thread(&current->thread, current_thread_info(), cause);
linux-4.15.18+/arch/powerpc/kernel/process.c:1059:	msr_diff = current->thread.ckpt_regs.msr & ~regs->msr;
linux-4.15.18+/arch/powerpc/kernel/process.c:1064:		current->thread.load_fp = 1;
linux-4.15.18+/arch/powerpc/kernel/process.c:1067:		current->thread.load_vec = 1;
linux-4.15.18+/arch/powerpc/kernel/process.c:1161:	old_thread = &current->thread;
linux-4.15.18+/arch/powerpc/kernel/process.c:1454:	set_debug_reg_defaults(&current->thread);
linux-4.15.18+/arch/powerpc/kernel/process.c:1464:	current->thread.used_vas = 1;
linux-4.15.18+/arch/powerpc/kernel/process.c:1739:		p->thread.dscr_inherit = current->thread.dscr_inherit;
linux-4.15.18+/arch/powerpc/kernel/process.c:1764:	if (!current->thread.regs) {
linux-4.15.18+/arch/powerpc/kernel/process.c:1766:		current->thread.regs = regs - 1;
linux-4.15.18+/arch/powerpc/kernel/process.c:1846:	current->thread.used_vsr = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1848:	current->thread.load_fp = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1849:	memset(&current->thread.fp_state, 0, sizeof(current->thread.fp_state));
linux-4.15.18+/arch/powerpc/kernel/process.c:1850:	current->thread.fp_save_area = NULL;
linux-4.15.18+/arch/powerpc/kernel/process.c:1852:	memset(&current->thread.vr_state, 0, sizeof(current->thread.vr_state));
linux-4.15.18+/arch/powerpc/kernel/process.c:1853:	current->thread.vr_state.vscr.u[3] = 0x00010000; /* Java mode disabled */
linux-4.15.18+/arch/powerpc/kernel/process.c:1854:	current->thread.vr_save_area = NULL;
linux-4.15.18+/arch/powerpc/kernel/process.c:1855:	current->thread.vrsave = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1856:	current->thread.used_vr = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1857:	current->thread.load_vec = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1860:	memset(current->thread.evr, 0, sizeof(current->thread.evr));
linux-4.15.18+/arch/powerpc/kernel/process.c:1861:	current->thread.acc = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1862:	current->thread.spefscr = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1863:	current->thread.used_spe = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1866:	current->thread.tm_tfhar = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1867:	current->thread.tm_texasr = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1868:	current->thread.tm_tfiar = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:1869:	current->thread.load_tm = 0;
linux-4.15.18+/arch/powerpc/kernel/process.c:2084:	int curr_frame = current->curr_ret_stack;
linux-4.15.18+/arch/powerpc/kernel/process.c:2113:				       (void *)current->ret_stack[curr_frame].ret);
linux-4.15.18+/arch/powerpc/kernel/process.c:2190:	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
linux-4.15.18+/arch/powerpc/kernel/hw_breakpoint.c:74:	if (current->thread.last_hit_ubp != bp)
linux-4.15.18+/arch/powerpc/kernel/hw_breakpoint.c:265:		current->thread.last_hit_ubp = bp;
linux-4.15.18+/arch/powerpc/kernel/hw_breakpoint.c:310:	bp = current->thread.last_hit_ubp;
linux-4.15.18+/arch/powerpc/kernel/hw_breakpoint.c:328:	current->thread.last_hit_ubp = NULL;
linux-4.15.18+/arch/powerpc/kernel/signal_64.c:520:		current->thread.used_vr = true;
linux-4.15.18+/arch/powerpc/kernel/signal_64.c:627:	BUG_ON(regs != current->thread.regs);
linux-4.15.18+/arch/powerpc/kernel/signal_64.c:654:				      &current->blocked, sizeof(sigset_t)))
linux-4.15.18+/arch/powerpc/kernel/signal_64.c:702:	BUG_ON(current->thread.regs != regs);
linux-4.15.18+/arch/powerpc/kernel/signal_64.c:705:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/powerpc/kernel/signal_64.c:754:				   current->comm, current->pid, "rt_sigreturn",
linux-4.15.18+/arch/powerpc/kernel/traps.c:134:			!current->pid || is_global_init(current))
linux-4.15.18+/arch/powerpc/kernel/traps.c:200:	if (in_interrupt() || panic_on_oops || !current->pid ||
linux-4.15.18+/arch/powerpc/kernel/traps.c:284:				   current->comm, current->pid, signr,
linux-4.15.18+/arch/powerpc/kernel/traps.c:291:	current->thread.trap_nr = code;
linux-4.15.18+/arch/powerpc/kernel/traps.c:420:#define single_stepping(regs)	(current->thread.debug.dbcr0 & DBCR0_IC)
linux-4.15.18+/arch/powerpc/kernel/traps.c:421:#define clear_single_step(regs)	(current->thread.debug.dbcr0 &= ~DBCR0_IC)
linux-4.15.18+/arch/powerpc/kernel/traps.c:724:			 smp_processor_id(), current->comm, current->pid,
linux-4.15.18+/arch/powerpc/kernel/traps.c:745:		vdst = (u8 *)&current->thread.vr_state.vr[t];
linux-4.15.18+/arch/powerpc/kernel/traps.c:747:		vdst = (u8 *)&current->thread.fp_state.fpr[t][0];
linux-4.15.18+/arch/powerpc/kernel/traps.c:759:			 smp_processor_id(), current->comm, current->pid,
linux-4.15.18+/arch/powerpc/kernel/traps.c:774:			 smp_processor_id(), current->comm, current->pid,
linux-4.15.18+/arch/powerpc/kernel/traps.c:781:		 smp_processor_id(), current->comm, current->pid, regs->nip,
linux-4.15.18+/arch/powerpc/kernel/traps.c:800:			 smp_processor_id(), current->comm, current->pid,
linux-4.15.18+/arch/powerpc/kernel/traps.c:1012:	code = __parse_fpscr(current->thread.fp_state.fpscr);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1241:		current->thread.dscr = regs->gpr[rd];
linux-4.15.18+/arch/powerpc/kernel/traps.c:1242:		current->thread.dscr_inherit = 1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1243:		mtspr(SPRN_DSCR, current->thread.dscr);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1272:			code = __parse_fpscr(current->thread.fp_state.fpscr);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1431:	if (!(current->thread.align_ctl & PR_UNALIGN_SIGBUS))
linux-4.15.18+/arch/powerpc/kernel/traps.c:1535:		current->thread.load_tm++;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1538:		tm_restore_sprs(&current->thread);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1600:			current->thread.dscr = regs->gpr[rd];
linux-4.15.18+/arch/powerpc/kernel/traps.c:1601:			current->thread.dscr_inherit = 1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1602:			current->thread.fscr |= FSCR_DSCR;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1603:			mtspr(SPRN_FSCR, current->thread.fscr);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1682:	current->thread.load_fp = 1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1690:	tm_recheckpoint(&current->thread);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1703:	current->thread.load_vec = 1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1704:	tm_recheckpoint(&current->thread);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1705:	current->thread.used_vr = 1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1721:	current->thread.used_vsr = 1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1726:	current->thread.load_vec = 1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1727:	current->thread.load_fp = 1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1729:	tm_recheckpoint(&current->thread);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1751:		current->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1762:		current->thread.debug.dbcr0 &= ~DBCR0_IAC1;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1768:		current->thread.debug.dbcr0 &= ~DBCR0_IAC2;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1773:		current->thread.debug.dbcr0 &= ~DBCR0_IAC3;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1779:		current->thread.debug.dbcr0 &= ~DBCR0_IAC4;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1789:	if (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,
linux-4.15.18+/arch/powerpc/kernel/traps.c:1790:			       current->thread.debug.dbcr1))
linux-4.15.18+/arch/powerpc/kernel/traps.c:1794:		current->thread.debug.dbcr0 &= ~DBCR0_IDM;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1797:		mtspr(SPRN_DBCR0, current->thread.debug.dbcr0);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1802:	current->thread.debug.dbsr = debug_status;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1819:			current->thread.debug.dbcr0 &= ~DBCR0_BT;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1820:			current->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1854:			current->thread.debug.dbcr0 &= ~DBCR0_IC;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1855:			if (DBCR_ACTIVE_EVENTS(current->thread.debug.dbcr0,
linux-4.15.18+/arch/powerpc/kernel/traps.c:1856:					       current->thread.debug.dbcr1))
linux-4.15.18+/arch/powerpc/kernel/traps.c:1860:				current->thread.debug.dbcr0 &= ~DBCR0_IDM;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1906:				   "in %s at %lx\n", current->comm, regs->nip);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1907:		current->thread.vr_state.vscr.u[3] |= 0x10000;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1937:	spefscr = current->thread.spefscr;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1938:	fpexc_mode = current->thread.fpexc_mode;
linux-4.15.18+/arch/powerpc/kernel/traps.c:1967:		       "in %s at %lx\n", current->comm, regs->nip);
linux-4.15.18+/arch/powerpc/kernel/traps.c:1999:		       "in %s at %lx\n", current->comm, regs->nip);
linux-4.15.18+/arch/powerpc/kernel/traps.c:2098:	pr_warn_ratelimited("%s used emulated %s instruction\n", current->comm,
linux-4.15.18+/arch/powerpc/kernel/signal.c:157:		BUG_ON(regs != current->thread.regs);
linux-4.15.18+/arch/powerpc/kernel/vdso.c:153:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/powerpc/kernel/vdso.c:183:	current->mm->context.vdso_base = 0;
linux-4.15.18+/arch/powerpc/kernel/vdso.c:218:	current->mm->context.vdso_base = vdso_base;
linux-4.15.18+/arch/powerpc/kernel/vdso.c:235:		current->mm->context.vdso_base = 0;
linux-4.15.18+/arch/powerpc/kernel/sysfs.c:530:	if (!current->thread.dscr_inherit) {
linux-4.15.18+/arch/powerpc/kernel/sysfs.c:531:		current->thread.dscr = *(unsigned long *)val;
linux-4.15.18+/arch/powerpc/kernel/syscalls.c:109:	if (personality(current->personality) == PER_LINUX32
linux-4.15.18+/arch/powerpc/kernel/syscalls.c:130:	current->thread.regs->msr ^= MSR_LE;
linux-4.15.18+/arch/powerpc/kernel/mce.c:392:			evt->srr0, current->pid, current->comm);
linux-4.15.18+/arch/powerpc/kernel/kgdb.c:363:			memcpy(mem, &current->thread.evr[regno-32],
linux-4.15.18+/arch/powerpc/kernel/kgdb.c:388:		memcpy(&current->thread.evr[regno-32], mem,
linux-4.15.18+/arch/powerpc/kernel/smp.c:968:	current->active_mm = &init_mm;
linux-4.15.18+/arch/powerpc/kernel/legacy_serial.c:89:	spd = of_get_property(np, "current-speed", NULL);
linux-4.15.18+/arch/powerpc/kernel/legacy_serial.c:614:	spd = of_get_property(prom_stdout, "current-speed", NULL);
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:66:	struct arch_uprobe_task *autask = &current->utask->autask;
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:68:	autask->saved_trap_nr = current->thread.trap_nr;
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:69:	current->thread.trap_nr = UPROBE_TRAP_NR;
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:70:	regs->nip = current->utask->xol_vaddr;
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:114:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:116:	WARN_ON_ONCE(current->thread.trap_nr != UPROBE_TRAP_NR);
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:118:	current->thread.trap_nr = utask->autask.saved_trap_nr;
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:169:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/powerpc/kernel/uprobes.c:171:	current->thread.trap_nr = utask->autask.saved_trap_nr;
linux-4.15.18+/arch/powerpc/kernel/trace/ftrace.c:584:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/powerpc/kernel/trace/ftrace.c:590:	trace.depth = current->curr_ret_stack + 1;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:397:	if (current->thread.used_vr) {
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:399:		if (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:415:		current->thread.vrsave = mfspr(SPRN_VRSAVE);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:416:	if (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:434:	if (current->thread.used_vsr && ctx_has_vsx_region) {
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:443:	if (current->thread.used_spe) {
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:445:		if (__copy_to_user(&frame->mc_vregs, current->thread.evr,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:455:	if (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:505:	if (save_general_regs(&current->thread.ckpt_regs, frame)
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:520:	if (current->thread.used_vr) {
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:521:		if (__copy_to_user(&frame->mc_vregs, &current->thread.ckvr_state,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:526:					   &current->thread.vr_state,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:531:					   &current->thread.ckvr_state,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:548:		current->thread.ckvrsave = mfspr(SPRN_VRSAVE);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:549:	if (__put_user(current->thread.ckvrsave,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:553:		if (__put_user(current->thread.vrsave,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:557:		if (__put_user(current->thread.ckvrsave,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:580:	if (current->thread.used_vsr) {
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:599:	if (current->thread.used_spe) {
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:601:		if (__copy_to_user(&frame->mc_vregs, current->thread.evr,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:610:	if (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:664:	 * current->thread when it next does altivec instructions
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:669:		if (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:672:		current->thread.used_vr = true;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:673:	} else if (current->thread.used_vr)
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:674:		memset(&current->thread.vr_state, 0,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:678:	if (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:681:		mtspr(SPRN_VRSAVE, current->thread.vrsave);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:689:	 * current->thread when it next does VSX instruction.
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:699:		current->thread.used_vsr = true;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:700:	} else if (current->thread.used_vsr)
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:702:			current->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:706:	 * current->thread when it next does FP instructions
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:712:	   current->thread when it next does spe instructions */
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:716:		if (__copy_from_user(current->thread.evr, &sr->mc_vregs,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:719:		current->thread.used_spe = true;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:720:	} else if (current->thread.used_spe)
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:721:		memset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:724:	if (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:757:	err |= restore_general_regs(&current->thread.ckpt_regs, sr);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:759:	err |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:772:		if (__copy_from_user(&current->thread.ckvr_state, &sr->mc_vregs,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:774:		    __copy_from_user(&current->thread.vr_state,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:778:		current->thread.used_vr = true;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:779:	} else if (current->thread.used_vr) {
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:780:		memset(&current->thread.vr_state, 0,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:782:		memset(&current->thread.ckvr_state, 0,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:787:	if (__get_user(current->thread.ckvrsave,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:789:	    __get_user(current->thread.vrsave,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:793:		mtspr(SPRN_VRSAVE, current->thread.ckvrsave);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:812:		current->thread.used_vsr = true;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:813:	} else if (current->thread.used_vsr)
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:815:			current->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:816:			current->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = 0;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:826:		if (__copy_from_user(current->thread.evr, &sr->mc_vregs,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:829:		current->thread.used_spe = true;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:830:	} else if (current->thread.used_spe)
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:831:		memset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:834:	if (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:854:	current->thread.tm_texasr |= TEXASR_FS;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:856:	tm_recheckpoint(&current->thread);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:861:		load_fp_state(&current->thread.fp_state);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:862:		regs->msr |= (MSR_FP | current->thread.fpexc_mode);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:866:		load_vr_state(&current->thread.vr_state);
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1164:		    || put_sigset_t(&old_ctx->uc_sigmask, &current->blocked)
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1204:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1277:				   current->comm, current->pid,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1295:	unsigned long new_dbcr0 = current->thread.debug.dbcr0;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1310:						current->thread.debug.dbcr1)) {
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1345:	current->thread.debug.dbcr0 = new_dbcr0;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1369:					   current->comm, current->pid,
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1495:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/powerpc/kernel/signal_32.c:1543:				   current->comm, current->pid,
linux-4.15.18+/arch/powerpc/kernel/mce_power.c:46:		mm = current->mm;
linux-4.15.18+/arch/powerpc/kernel/mce_power.c:51:	if (mm == current->mm)
linux-4.15.18+/arch/powerpc/kernel/swsusp.c:35:	switch_mmu_context(current->active_mm, current->active_mm, NULL);
linux-4.15.18+/arch/powerpc/kernel/align.c:121:	unsigned long *evr = &current->thread.evr[reg];
linux-4.15.18+/arch/sh/include/asm/stackprotector.h:25:	current->stack_canary = canary;
linux-4.15.18+/arch/sh/include/asm/stackprotector.h:26:	__stack_chk_guard = current->stack_canary;
linux-4.15.18+/arch/sh/include/asm/user.h:19: *  data: The data segment follows next.  We use current->end_text to
linux-4.15.18+/arch/sh/include/asm/user.h:20: *	current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/sh/include/asm/user.h:27: *	current->start_stack, so we round each of these in order to be able
linux-4.15.18+/arch/sh/include/asm/elf.h:188:	set_personality(PER_LINUX_32BIT | (current->personality & (~PER_MASK)))
linux-4.15.18+/arch/sh/include/asm/elf.h:200:#define VDSO_BASE		((unsigned long)current->mm->context.vdso)
linux-4.15.18+/arch/sh/include/asm/mmu_context.h:112: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/sh/boot/dts/j2_mimas_v2.dts:90:			current-speed = <19200>;
linux-4.15.18+/arch/sh/mm/tlbflush_32.c:28:		if (vma->vm_mm != current->mm) {
linux-4.15.18+/arch/sh/mm/tlbflush_32.c:53:			if (mm == current->mm)
linux-4.15.18+/arch/sh/mm/tlbflush_32.c:63:			if (mm != current->mm) {
linux-4.15.18+/arch/sh/mm/tlbflush_32.c:117:		if (mm == current->mm)
linux-4.15.18+/arch/sh/mm/tlbflush_64.c:139:	if (mm == current->mm)
linux-4.15.18+/arch/sh/mm/tlb-sh3.c:36:	if (vma && current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/sh/mm/cache-sh4.c:235:	if ((vma->vm_mm == current->active_mm))
linux-4.15.18+/arch/sh/mm/alignment.c:72:	if (current->thread.flags & SH_THREAD_UAC_SIGBUS) {
linux-4.15.18+/arch/sh/mm/alignment.c:77:	if (current->thread.flags & SH_THREAD_UAC_NOPRINT)
linux-4.15.18+/arch/sh/mm/fault.c:282:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sh/mm/fault.c:331:			up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/sh/mm/fault.c:343:			up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/sh/mm/fault.c:347:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/sh/mm/tlbex_32.c:39:		if (unlikely(address >= TASK_SIZE || !current->mm))
linux-4.15.18+/arch/sh/mm/tlbex_32.c:42:		pgd = pgd_offset(current->mm, address);
linux-4.15.18+/arch/sh/mm/mmap.c:37:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sh/mm/mmap.c:86:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sh/mm/gup.c:167:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sh/mm/gup.c:221:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sh/mm/tlb-sh4.c:24:	if (vma && current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/sh/mm/tlb-pteaex.c:25:	if (vma && current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/sh/mm/tlbex_64.c:55:		if (unlikely(address >= TASK_SIZE || !current->mm))
linux-4.15.18+/arch/sh/mm/tlbex_64.c:58:		pgd = pgd_offset(current->mm, address);
linux-4.15.18+/arch/sh/kernel/vsyscall/vsyscall.c:63:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/sh/kernel/vsyscall/vsyscall.c:83:	current->mm->context.vdso = (void *)addr;
linux-4.15.18+/arch/sh/kernel/sys_sh.c:72:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/sh/kernel/sys_sh.c:73:	vma = find_vma (current->mm, addr);
linux-4.15.18+/arch/sh/kernel/sys_sh.c:75:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/sh/kernel/sys_sh.c:94:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/sh/kernel/traps.c:37:	printk("Process: %s (pid: %d, stack limit = %p)\n", current->comm,
linux-4.15.18+/arch/sh/kernel/signal_64.c:160:	err |= __copy_from_user(&current->thread.xstate->hardfpu, &sc->sc_fpregs[0],
linux-4.15.18+/arch/sh/kernel/signal_64.c:185:	err |= __copy_to_user(&sc->sc_fpregs[0], &current->thread.xstate->hardfpu,
linux-4.15.18+/arch/sh/kernel/signal_64.c:263:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/sh/kernel/signal_64.c:297:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/sh/kernel/signal_64.c:369:		sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/sh/kernel/signal_64.c:456:		 sig, current->comm, current->pid, frame,
linux-4.15.18+/arch/sh/kernel/signal_64.c:536:		 sig, current->comm, current->pid, frame,
linux-4.15.18+/arch/sh/kernel/traps_64.c:356:			current->thread.xstate->hardfpu.fp_regs[destreg] = buflo;
linux-4.15.18+/arch/sh/kernel/traps_64.c:360:				current->thread.xstate->hardfpu.fp_regs[destreg] = buflo;
linux-4.15.18+/arch/sh/kernel/traps_64.c:361:				current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi;
linux-4.15.18+/arch/sh/kernel/traps_64.c:364:				current->thread.xstate->hardfpu.fp_regs[destreg] = bufhi;
linux-4.15.18+/arch/sh/kernel/traps_64.c:365:				current->thread.xstate->hardfpu.fp_regs[destreg+1] = buflo;
linux-4.15.18+/arch/sh/kernel/traps_64.c:367:				current->thread.xstate->hardfpu.fp_regs[destreg] = buflo;
linux-4.15.18+/arch/sh/kernel/traps_64.c:368:				current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi;
linux-4.15.18+/arch/sh/kernel/traps_64.c:423:			buflo = current->thread.xstate->hardfpu.fp_regs[srcreg];
linux-4.15.18+/arch/sh/kernel/traps_64.c:427:				buflo = current->thread.xstate->hardfpu.fp_regs[srcreg];
linux-4.15.18+/arch/sh/kernel/traps_64.c:428:				bufhi = current->thread.xstate->hardfpu.fp_regs[srcreg+1];
linux-4.15.18+/arch/sh/kernel/traps_64.c:431:				bufhi = current->thread.xstate->hardfpu.fp_regs[srcreg];
linux-4.15.18+/arch/sh/kernel/traps_64.c:432:				buflo = current->thread.xstate->hardfpu.fp_regs[srcreg+1];
linux-4.15.18+/arch/sh/kernel/traps_64.c:434:				buflo = current->thread.xstate->hardfpu.fp_regs[srcreg];
linux-4.15.18+/arch/sh/kernel/traps_64.c:435:				bufhi = current->thread.xstate->hardfpu.fp_regs[srcreg+1];
linux-4.15.18+/arch/sh/kernel/smp.c:184:	current->active_mm = mm;
linux-4.15.18+/arch/sh/kernel/smp.c:367:	if ((atomic_read(&mm->mm_users) != 1) || (current->mm != mm)) {
linux-4.15.18+/arch/sh/kernel/smp.c:399:	if ((atomic_read(&mm->mm_users) != 1) || (current->mm != mm)) {
linux-4.15.18+/arch/sh/kernel/smp.c:443:	    (current->mm != vma->vm_mm)) {
linux-4.15.18+/arch/sh/kernel/ftrace.c:331:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/sh/kernel/ftrace.c:378:		current->curr_ret_stack--;
linux-4.15.18+/arch/sh/kernel/process_64.c:334:	if(current->thread.kregs==&fake_swapper_regs) {
linux-4.15.18+/arch/sh/kernel/process_64.c:335:          current->thread.kregs =
linux-4.15.18+/arch/sh/kernel/process_64.c:337:	  current->thread.uregs = current->thread.kregs;
linux-4.15.18+/arch/sh/kernel/signal_32.c:161:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/sh/kernel/signal_32.c:191:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/sh/kernel/signal_32.c:256:			sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/sh/kernel/signal_32.c:289:	} else if (likely(current->mm->context.vdso)) {
linux-4.15.18+/arch/sh/kernel/signal_32.c:315:	if (current->personality & FDPIC_FUNCPTRS) {
linux-4.15.18+/arch/sh/kernel/signal_32.c:328:		 current->comm, task_pid_nr(current), frame, regs->pc, regs->pr);
linux-4.15.18+/arch/sh/kernel/signal_32.c:359:	} else if (likely(current->mm->context.vdso)) {
linux-4.15.18+/arch/sh/kernel/signal_32.c:385:	if (current->personality & FDPIC_FUNCPTRS) {
linux-4.15.18+/arch/sh/kernel/signal_32.c:398:		 current->comm, task_pid_nr(current), frame, regs->pc, regs->pr);
linux-4.15.18+/arch/sh/kernel/traps_32.c:537:		       "access (PC %lx PR %lx)\n", current->comm, regs->pc,
linux-4.15.18+/arch/sh/kernel/dwarf.c:611:		int index = current->curr_ret_stack;
linux-4.15.18+/arch/sh/kernel/dwarf.c:621:		pc = current->ret_stack[index].ret;
linux-4.15.18+/arch/arc/boot/dts/nsim_hs_idu.dts:58:			current-speed = <115200>;
linux-4.15.18+/arch/arc/boot/dts/nsim_700.dts:52:			current-speed = <115200>;
linux-4.15.18+/arch/arc/boot/dts/nsim_hs.dts:60:			current-speed = <115200>;
linux-4.15.18+/arch/arc/mm/fault.c:38:	pgd = pgd_offset_fast(current->active_mm, address);
linux-4.15.18+/arch/arc/mm/mmap.c:35:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arc/mm/tlb.c:315:	if (current->mm == mm)
linux-4.15.18+/arch/arc/mm/tlb.c:526:	 * create_tlb() assumes that current->mm == vma->mm, since
linux-4.15.18+/arch/arc/mm/tlb.c:536:	 * Lets see the use cases when current->mm != vma->mm and we land here
linux-4.15.18+/arch/arc/mm/tlb.c:539:	 *     current->mm still points to pre-execve mm (hence the condition).
linux-4.15.18+/arch/arc/mm/tlb.c:550:	if (current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/arc/kernel/signal.c:161:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/arc/kernel/kgdb.c:63:		current->thread.callee_reg);
linux-4.15.18+/arch/arc/kernel/kgdb.c:69:		current->thread.callee_reg);
linux-4.15.18+/arch/arc/kernel/kgdb.c:117:		current->thread.callee_reg,
linux-4.15.18+/arch/arc/kernel/smp.c:149:	current->active_mm = mm;
linux-4.15.18+/arch/arc/kernel/troubleshoot.c:91:	struct mm_struct *active_mm = current->active_mm;
linux-4.15.18+/arch/arc/kernel/troubleshoot.c:129:	address = current->thread.fault_address;
linux-4.15.18+/arch/arc/kernel/troubleshoot.c:194:		current->thread.fault_address,
linux-4.15.18+/arch/arc/kernel/troubleshoot.c:227:	cregs = (struct callee_regs *)current->thread.callee_reg;
linux-4.15.18+/arch/arc/kernel/troubleshoot.c:237:	current->thread.fault_address = address;
linux-4.15.18+/arch/arc/kernel/kprobes.c:174:			(struct callee_regs *) current->thread.callee_reg,
linux-4.15.18+/arch/hexagon/include/asm/pgalloc.h:126:	current->active_mm->context.generation = kmap_generation;
linux-4.15.18+/arch/hexagon/include/asm/pgalloc.h:136:	ppmd = (pmd_t *)current->active_mm->pgd + pmdindex;
linux-4.15.18+/arch/hexagon/mm/vm_fault.c:52:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/hexagon/mm/vm_fault.c:114:				current->maj_flt++;
linux-4.15.18+/arch/hexagon/mm/vm_fault.c:116:				current->min_flt++;
linux-4.15.18+/arch/hexagon/mm/vm_tlb.c:43:	if (mm->context.ptbase == current->active_mm->context.ptbase)
linux-4.15.18+/arch/hexagon/mm/vm_tlb.c:72:	if (current->active_mm->context.ptbase == mm->context.ptbase)
linux-4.15.18+/arch/hexagon/mm/vm_tlb.c:83:	if (mm->context.ptbase  == current->active_mm->context.ptbase)
linux-4.15.18+/arch/hexagon/kernel/vdso.c:66:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/hexagon/kernel/signal.c:114:	struct hexagon_vdso *vdso = current->mm->context.vdso;
linux-4.15.18+/arch/hexagon/kernel/signal.c:244:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/hexagon/kernel/smp.c:167:	current->active_mm = &init_mm;
linux-4.15.18+/arch/m68k/sun3/mmu_emu.c:363:	if(current->mm == NULL) {
linux-4.15.18+/arch/m68k/sun3/mmu_emu.c:367:		context = current->mm->context;
linux-4.15.18+/arch/m68k/sun3/mmu_emu.c:371:			crp = current->mm->pgd;
linux-4.15.18+/arch/m68k/include/asm/tlbflush.h:81:	if (mm == current->active_mm)
linux-4.15.18+/arch/m68k/include/asm/tlbflush.h:87:	if (vma->vm_mm == current->active_mm) {
linux-4.15.18+/arch/m68k/include/asm/tlbflush.h:98:	if (vma->vm_mm == current->active_mm)
linux-4.15.18+/arch/m68k/include/asm/math-emu.h:128:#define FPDATA		((struct fp_data *)current->thread.fp)
linux-4.15.18+/arch/m68k/include/asm/a.out-core.h:32:	dump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;
linux-4.15.18+/arch/m68k/include/asm/a.out-core.h:33:	dump->u_dsize = ((unsigned long) (current->mm->brk +
linux-4.15.18+/arch/m68k/include/asm/cacheflush_mm.h:198:	if (mm == current->mm)
linux-4.15.18+/arch/m68k/include/asm/cacheflush_mm.h:210:	if (vma->vm_mm == current->mm)
linux-4.15.18+/arch/m68k/include/asm/cacheflush_mm.h:216:	if (vma->vm_mm == current->mm)
linux-4.15.18+/arch/m68k/include/asm/flat.h:41:		if (current->mm) \
linux-4.15.18+/arch/m68k/include/asm/flat.h:42:			(regs)->d5 = current->mm->start_data; \
linux-4.15.18+/arch/m68k/include/asm/user.h:19:   DATA: The data area is stored.  We use current->end_text to
linux-4.15.18+/arch/m68k/include/asm/user.h:20:   current->brk to pick up all of the user variables, plus any memory
linux-4.15.18+/arch/m68k/include/asm/user.h:27:   current->start_stack, so we round each of these off in order to be able
linux-4.15.18+/arch/m68k/include/asm/mmu_context.h:83: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/m68k/coldfire/sltimers.c:48:	if (current->pid)
linux-4.15.18+/arch/m68k/coldfire/timers.c:166:	if (current->pid)
linux-4.15.18+/arch/m68k/mm/sun3mmu.c:83:	current->mm = NULL;
linux-4.15.18+/arch/m68k/mm/fault.c:26:	siginfo.si_signo = current->thread.signo;
linux-4.15.18+/arch/m68k/mm/fault.c:27:	siginfo.si_code = current->thread.code;
linux-4.15.18+/arch/m68k/mm/fault.c:28:	siginfo.si_addr = (void *)current->thread.faddr;
linux-4.15.18+/arch/m68k/mm/fault.c:73:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/m68k/mm/fault.c:163:			current->maj_flt++;
linux-4.15.18+/arch/m68k/mm/fault.c:165:			current->min_flt++;
linux-4.15.18+/arch/m68k/mm/fault.c:197:	current->thread.signo = SIGBUS;
linux-4.15.18+/arch/m68k/mm/fault.c:198:	current->thread.faddr = address;
linux-4.15.18+/arch/m68k/mm/fault.c:202:	current->thread.signo = SIGBUS;
linux-4.15.18+/arch/m68k/mm/fault.c:203:	current->thread.code = BUS_ADRERR;
linux-4.15.18+/arch/m68k/mm/fault.c:204:	current->thread.faddr = address;
linux-4.15.18+/arch/m68k/mm/fault.c:208:	current->thread.signo = SIGSEGV;
linux-4.15.18+/arch/m68k/mm/fault.c:209:	current->thread.code = SEGV_MAPERR;
linux-4.15.18+/arch/m68k/mm/fault.c:210:	current->thread.faddr = address;
linux-4.15.18+/arch/m68k/mm/fault.c:214:	current->thread.signo = SIGSEGV;
linux-4.15.18+/arch/m68k/mm/fault.c:215:	current->thread.code = SEGV_ACCERR;
linux-4.15.18+/arch/m68k/mm/fault.c:216:	current->thread.faddr = address;
linux-4.15.18+/arch/m68k/mm/mcfmmu.c:77:	current->mm = NULL;
linux-4.15.18+/arch/m68k/mm/mcfmmu.c:99:	mm = (!user_mode(regs) && KMAPAREA(mmuar)) ? &init_mm : current->mm;
linux-4.15.18+/arch/m68k/kernel/ptrace.c:277:	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
linux-4.15.18+/arch/m68k/kernel/ptrace.c:284:	if (current->exit_code) {
linux-4.15.18+/arch/m68k/kernel/ptrace.c:285:		send_sig(current->exit_code, current, 1);
linux-4.15.18+/arch/m68k/kernel/ptrace.c:286:		current->exit_code = 0;
linux-4.15.18+/arch/m68k/kernel/process.c:95:	current->thread.fs = __USER_DS;
linux-4.15.18+/arch/m68k/kernel/process.c:201:		memcpy(fpu->fpcntl, current->thread.fpcntl, 12);
linux-4.15.18+/arch/m68k/kernel/process.c:202:		memcpy(fpu->fpregs, current->thread.fp, 96);
linux-4.15.18+/arch/m68k/kernel/signal.c:262:	    memcpy(current->thread.fpcntl, sc->sc_fpcntl, 12);
linux-4.15.18+/arch/m68k/kernel/signal.c:263:	    memcpy(current->thread.fp, sc->sc_fpregs, 24);
linux-4.15.18+/arch/m68k/kernel/signal.c:341:		if (__copy_from_user(current->thread.fpcntl,
linux-4.15.18+/arch/m68k/kernel/signal.c:345:		if (__copy_from_user(current->thread.fp,
linux-4.15.18+/arch/m68k/kernel/signal.c:434:		memcpy(sc->sc_fpcntl, current->thread.fpcntl, 12);
linux-4.15.18+/arch/m68k/kernel/signal.c:435:		memcpy(sc->sc_fpregs, current->thread.fp, 24);
linux-4.15.18+/arch/m68k/kernel/signal.c:492:				current->thread.fpcntl, 12);
linux-4.15.18+/arch/m68k/kernel/signal.c:495:				current->thread.fp, 96);
linux-4.15.18+/arch/m68k/kernel/signal.c:639:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/m68k/kernel/signal.c:677:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/m68k/kernel/signal.c:1052:	current->thread.esp0 = (unsigned long) regs;
linux-4.15.18+/arch/m68k/kernel/traps.c:239:	if (wba != current->thread.faddr)
linux-4.15.18+/arch/m68k/kernel/traps.c:357:		current->thread.signo = SIGBUS;
linux-4.15.18+/arch/m68k/kernel/traps.c:358:		current->thread.faddr = fp->un.fmt7.faddr;
linux-4.15.18+/arch/m68k/kernel/traps.c:511:	pr_debug("pid = %x  ", current->pid);
linux-4.15.18+/arch/m68k/kernel/traps.c:761:		current->thread.esp0 = (unsigned long) fp;
linux-4.15.18+/arch/m68k/kernel/traps.c:863:		current->comm, task_pid_nr(current), current);
linux-4.15.18+/arch/m68k/kernel/traps.c:1149:	current->thread.esp0 = ssp;
linux-4.15.18+/arch/m68k/kernel/sys_m68k.c:402:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/m68k/kernel/sys_m68k.c:403:		vma = find_vma(current->mm, addr);
linux-4.15.18+/arch/m68k/kernel/sys_m68k.c:453:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/m68k/kernel/sys_m68k.c:466:		struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/m68k/kernel/sys_m68k.c:537:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arm64/include/asm/efi.h:121:		if (mm != current->active_mm) {
linux-4.15.18+/arch/arm64/include/asm/efi.h:139:			update_saved_ttbr0(current, current->active_mm);
linux-4.15.18+/arch/arm64/include/asm/stackprotector.h:36:	current->stack_canary = canary;
linux-4.15.18+/arch/arm64/include/asm/stackprotector.h:37:	__stack_chk_guard = current->stack_canary;
linux-4.15.18+/arch/arm64/include/asm/uaccess.h:73: * (u65)addr + (u65)size <= (u65)current->addr_limit + 1
linux-4.15.18+/arch/arm64/include/asm/pgtable.h:249:	   (mm == current->active_mm || atomic_read(&mm->mm_users) > 1)) {
linux-4.15.18+/arch/arm64/include/asm/page.h:49:	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
linux-4.15.18+/arch/arm64/include/asm/mmu_context.h:112:	struct mm_struct *mm = current->active_mm;
linux-4.15.18+/arch/arm64/include/asm/elf.h:143:	current->personality &= ~READ_IMPLIES_EXEC;			\
linux-4.15.18+/arch/arm64/include/asm/elf.h:150:		    (elf_addr_t)current->mm->context.vdso);		\
linux-4.15.18+/arch/arm64/boot/dts/hisilicon/hip07.dtsi:1097:			current-speed = <115200>;
linux-4.15.18+/arch/arm64/mm/mmap.c:43:	if (current->personality & ADDR_COMPAT_LAYOUT)
linux-4.15.18+/arch/arm64/mm/mmap.c:90:	if (current->flags & PF_RANDOMIZE)
linux-4.15.18+/arch/arm64/mm/fault.c:137:		mm = current->active_mm;
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:254:			       &current->thread.fpsimd_state.fpsr,
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:255:			       sve_vq_from_vl(current->thread.sve_vl) - 1);
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:257:		fpsimd_load_state(&current->thread.fpsimd_state);
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:282:			if (WARN_ON(sve_get_vl() != current->thread.sve_vl)) {
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:294:				       &current->thread.fpsimd_state.fpsr);
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:296:			fpsimd_save_state(&current->thread.fpsimd_state);
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:638:		ret = current->thread.sve_vl_onexec;
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:640:		ret = current->thread.sve_vl;
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:900:	if (current->mm)
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:930:	memset(&current->thread.fpsimd_state, 0, sizeof(struct fpsimd_state));
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:948:		vl = current->thread.sve_vl_onexec ?
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:949:			current->thread.sve_vl_onexec : sve_default_vl;
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:958:		current->thread.sve_vl = vl;
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:965:			current->thread.sve_vl_onexec = 0;
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:989: * current->thread.fpsimd_state is updated so that it can be copied to
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:1007:	struct fpsimd_state *st = &current->thread.fpsimd_state;
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:1046:	current->thread.fpsimd_state.user_fpsimd = state->user_fpsimd;
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:1123:	if (current->mm) {
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:1248:		if (current->mm)
linux-4.15.18+/arch/arm64/kernel/fpsimd.c:1253:		if (current->mm)
linux-4.15.18+/arch/arm64/kernel/ptrace.c:197:		if (current->thread.debug.hbp_break[i] == bp) {
linux-4.15.18+/arch/arm64/kernel/ptrace.c:204:		if (current->thread.debug.hbp_watch[i] == bp) {
linux-4.15.18+/arch/arm64/kernel/cpuinfo.c:122:	bool compat = personality(current->personality) == PER_LINUX32;
linux-4.15.18+/arch/arm64/kernel/vdso.c:89:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arm64/kernel/vdso.c:100:	current->mm->context.vdso = (void *)addr;
linux-4.15.18+/arch/arm64/kernel/vdso.c:122:	current->mm->context.vdso = (void *)new_vma->vm_start;
linux-4.15.18+/arch/arm64/kernel/vdso.c:178:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/arm64/kernel/process.c:261:		current->thread.tp_value = 0;
linux-4.15.18+/arch/arm64/kernel/process.c:301:	if (current->mm)
linux-4.15.18+/arch/arm64/kernel/process.c:477:	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
linux-4.15.18+/arch/arm64/kernel/process.c:495:	current->mm->context.flags = is_compat_task() ? MMCF_AARCH32 : 0;
linux-4.15.18+/arch/arm64/kernel/probes/uprobes.c:67:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/arm64/kernel/probes/uprobes.c:70:	current->thread.fault_code = UPROBE_INV_FAULT_CODE;
linux-4.15.18+/arch/arm64/kernel/probes/uprobes.c:82:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/arm64/kernel/probes/uprobes.c:84:	WARN_ON_ONCE(current->thread.fault_code != UPROBE_INV_FAULT_CODE);
linux-4.15.18+/arch/arm64/kernel/probes/uprobes.c:125:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/arm64/kernel/probes/uprobes.c:183:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/arm64/kernel/traps.c:230:		current->thread.fault_address = 0;
linux-4.15.18+/arch/arm64/kernel/traps.c:231:		current->thread.fault_code = err;
linux-4.15.18+/arch/arm64/kernel/traps.c:336:			current->comm, task_pid_nr(current), desc, pc);
linux-4.15.18+/arch/arm64/kernel/traps.c:355:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm64/kernel/traps.c:356:	if (find_vma(current->mm, addr) == NULL)
linux-4.15.18+/arch/arm64/kernel/traps.c:360:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/arm64/kernel/traps.c:614:	current->thread.fault_address = 0;
linux-4.15.18+/arch/arm64/kernel/traps.c:615:	current->thread.fault_code = 0;
linux-4.15.18+/arch/arm64/kernel/traps.c:627:	unsigned long tsk_stk = (unsigned long)current->stack;
linux-4.15.18+/arch/arm64/kernel/signal.c:181:	struct fpsimd_state *fpsimd = &current->thread.fpsimd_state;
linux-4.15.18+/arch/arm64/kernel/signal.c:237:	unsigned int vl = current->thread.sve_vl;
linux-4.15.18+/arch/arm64/kernel/signal.c:258:				      current->thread.sve_state,
linux-4.15.18+/arch/arm64/kernel/signal.c:275:	if (sve.vl != current->thread.sve_vl)
linux-4.15.18+/arch/arm64/kernel/signal.c:304:	err = __copy_from_user(current->thread.sve_state,
linux-4.15.18+/arch/arm64/kernel/signal.c:544:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/arm64/kernel/signal.c:569:				    current->comm, task_pid_nr(current), __func__,
linux-4.15.18+/arch/arm64/kernel/signal.c:586:	if (current->thread.fault_code) {
linux-4.15.18+/arch/arm64/kernel/signal.c:597:			vq = sve_vq_from_vl(current->thread.sve_vl);
linux-4.15.18+/arch/arm64/kernel/signal.c:626:	__put_user_error(current->thread.fault_address, &sf->uc.uc_mcontext.fault_address, err);
linux-4.15.18+/arch/arm64/kernel/signal.c:643:		__put_user_error(current->thread.fault_code, &esr_ctx->esr, err);
linux-4.15.18+/arch/arm64/kernel/signal.c:740:		sigtramp = VDSO_SYMBOL(current->mm->context.vdso, sigtramp);
linux-4.15.18+/arch/arm64/kernel/hw_breakpoint.c:239:	struct debug_info *debug_info = &current->thread.debug;
linux-4.15.18+/arch/arm64/kernel/hw_breakpoint.c:639:	debug_info = &current->thread.debug;
linux-4.15.18+/arch/arm64/kernel/hw_breakpoint.c:753:	debug_info = &current->thread.debug;
linux-4.15.18+/arch/arm64/kernel/hw_breakpoint.c:852:	struct debug_info *debug_info = &current->thread.debug;
linux-4.15.18+/arch/arm64/kernel/hw_breakpoint.c:921:	current_debug_info = &current->thread.debug;
linux-4.15.18+/arch/arm64/kernel/armv8_deprecated.c:423:			current->comm, (unsigned long)current->pid, regs->pc);
linux-4.15.18+/arch/arm64/kernel/armv8_deprecated.c:504:			current->comm, (unsigned long)current->pid, regs->pc);
linux-4.15.18+/arch/arm64/kernel/armv8_deprecated.c:572:			current->comm, (unsigned long)current->pid, regs->pc);
linux-4.15.18+/arch/arm64/kernel/signal32.c:231:	struct fpsimd_state *fpsimd = &current->thread.fpsimd_state;
linux-4.15.18+/arch/arm64/kernel/signal32.c:368:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/arm64/kernel/signal32.c:391:				    current->comm, task_pid_nr(current), __func__,
linux-4.15.18+/arch/arm64/kernel/signal32.c:402:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/arm64/kernel/signal32.c:428:				    current->comm, task_pid_nr(current), __func__,
linux-4.15.18+/arch/arm64/kernel/signal32.c:525:	__put_user_error(!!(current->thread.fault_code & ESR_ELx_WNR) <<
linux-4.15.18+/arch/arm64/kernel/signal32.c:527:	__put_user_error(current->thread.fault_address, &sf->uc.uc_mcontext.fault_address, err);
linux-4.15.18+/arch/arm64/kernel/ftrace.c:222:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/arm64/kernel/ftrace.c:233:	trace.depth = current->curr_ret_stack + 1;
linux-4.15.18+/arch/arm64/kernel/return_address.c:47:	frame.graph = current->curr_ret_stack;
linux-4.15.18+/arch/arm64/kernel/smp.c:232:	current->active_mm = mm;
linux-4.15.18+/arch/arm64/kernel/perf_callchain.c:167:	frame.graph = current->curr_ret_stack;
linux-4.15.18+/arch/arm64/kernel/sys_compat.c:91:		current->thread.tp_value = regs->regs[0];
linux-4.15.18+/arch/arm64/kernel/stacktrace.c:135:	frame.graph = current->curr_ret_stack;
linux-4.15.18+/arch/mips/netlogic/xlp/cop2-ex.c:106:		nlm_cop2_restore(&(current->thread.cp2));
linux-4.15.18+/arch/mips/netlogic/xlp/cop2-ex.c:110:					current->pid, current->comm);
linux-4.15.18+/arch/mips/kvm/tlb.c:643:	cpumask_clear_cpu(cpu, mm_cpumask(current->active_mm));
linux-4.15.18+/arch/mips/kvm/tlb.c:644:	current->active_mm = &init_mm;
linux-4.15.18+/arch/mips/kvm/tlb.c:657:	cpumask_set_cpu(cpu, mm_cpumask(current->mm));
linux-4.15.18+/arch/mips/kvm/tlb.c:658:	current->active_mm = current->mm;
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1057:	if (current->flags & PF_VCPU) {
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1075:	if (current->flags & PF_VCPU) {
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1077:		if (((cpu_context(cpu, current->mm) ^ asid_cache(cpu)) &
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1079:			get_new_mmu_context(current->mm, cpu);
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1080:		write_c0_entryhi(cpu_asid(cpu, current->mm));
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1081:		TLBMISS_HANDLER_SETUP_PGD(current->mm->pgd);
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1269:	if (((cpu_context(cpu, current->mm) ^ asid_cache(cpu)) &
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1271:		get_new_mmu_context(current->mm, cpu);
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1272:	write_c0_entryhi(cpu_asid(cpu, current->mm));
linux-4.15.18+/arch/mips/kvm/trap_emul.c:1273:	TLBMISS_HANDLER_SETUP_PGD(current->mm->pgd);
linux-4.15.18+/arch/mips/kvm/vz.c:2487:	if (current->flags & PF_VCPU) {
linux-4.15.18+/arch/mips/kvm/vz.c:2610:	if (current->flags & PF_VCPU)
linux-4.15.18+/arch/mips/kvm/mips.c:1640:	if (!(current->flags & PF_VCPU))
linux-4.15.18+/arch/mips/loongson64/loongson-3/cop2-ex.c:47:				_init_fpu(current->thread.fpu.fcr31);
linux-4.15.18+/arch/mips/include/asm/stackprotector.h:37:	current->stack_canary = canary;
linux-4.15.18+/arch/mips/include/asm/stackprotector.h:38:	__stack_chk_guard = current->stack_canary;
linux-4.15.18+/arch/mips/include/asm/elf.h:350:	current->thread.abi = &mips_abi;				\
linux-4.15.18+/arch/mips/include/asm/elf.h:355:	if (personality(current->personality) != PER_LINUX)		\
linux-4.15.18+/arch/mips/include/asm/elf.h:368:		current->thread.abi = &mips_abi_n32;			\
linux-4.15.18+/arch/mips/include/asm/elf.h:383:		current->thread.abi = &mips_abi_32;			\
linux-4.15.18+/arch/mips/include/asm/elf.h:417:		current->thread.abi = &mips_abi;			\
linux-4.15.18+/arch/mips/include/asm/elf.h:421:	p = personality(current->personality);				\
linux-4.15.18+/arch/mips/include/asm/elf.h:476:		    (unsigned long)current->mm->context.vdso);		\
linux-4.15.18+/arch/mips/include/asm/page.h:252:	 ((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
linux-4.15.18+/arch/mips/include/asm/mmu_context.h:153:	 * Mark current->active_mm as not "active" anymore.
linux-4.15.18+/arch/mips/include/asm/mmu_context.h:175: * After we have set current->mm to a new value, this activates
linux-4.15.18+/arch/mips/include/asm/fpu.h:203:	unsigned int fcr31 = current->thread.fpu.fcr31;
linux-4.15.18+/arch/mips/boot/dts/cavium-octeon/octeon_3xxx.dts:313:			current-speed = <115200>;
linux-4.15.18+/arch/mips/boot/dts/cavium-octeon/octeon_3xxx.dts:322:			current-speed = <115200>;
linux-4.15.18+/arch/mips/boot/dts/cavium-octeon/octeon_68xx.dts:434:			current-speed = <115200>;
linux-4.15.18+/arch/mips/boot/dts/cavium-octeon/octeon_68xx.dts:443:			current-speed = <115200>;
linux-4.15.18+/arch/mips/boot/dts/cavium-octeon/octeon_3xxx.dtsi:107:			current-speed = <115200>;
linux-4.15.18+/arch/mips/mm/tlb-r3k.c:203:	if (current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/mips/mm/fault.c:53:	       current->comm, current->pid, field, address, write,
linux-4.15.18+/arch/mips/mm/fault.c:62:		       current->thread.trap_nr, SIGSEGV) == NOTIFY_STOP)
linux-4.15.18+/arch/mips/mm/fault.c:127:					  current->comm, current->pid,
linux-4.15.18+/arch/mips/mm/fault.c:138:					  current->comm, current->pid,
linux-4.15.18+/arch/mips/mm/fault.c:225:		current->thread.trap_nr = (regs->cp0_cause >> 2) & 0x1f;
linux-4.15.18+/arch/mips/mm/fault.c:237:		current->thread.cp0_baduaddr = address;
linux-4.15.18+/arch/mips/mm/fault.c:284:	current->thread.trap_nr = (regs->cp0_cause >> 2) & 0x1f;
linux-4.15.18+/arch/mips/mm/c-tx39.c:203:	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID)) {
linux-4.15.18+/arch/mips/mm/mmap.c:29:	if (current->personality & ADDR_COMPAT_LAYOUT)
linux-4.15.18+/arch/mips/mm/mmap.c:60:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/mips/mm/mmap.c:165:	if (current->flags & PF_RANDOMIZE)
linux-4.15.18+/arch/mips/mm/gup.c:185:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/mips/mm/gup.c:252:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/mips/mm/tlb-r8k.c:194:	if (current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/mips/mm/c-octeon.c:140:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/mips/mm/c-octeon.c:141:	vma = find_vma(current->mm, addr);
linux-4.15.18+/arch/mips/mm/c-octeon.c:143:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/mips/mm/tlb-r4k.c:304:	if (current->active_mm != vma->vm_mm)
linux-4.15.18+/arch/mips/mm/c-r4k.c:653:	if ((mm == current->active_mm) && (pte_val(*ptep) & _PAGE_VALID))
linux-4.15.18+/arch/mips/mm/c-r4k.c:677:		if (vaddr && cpu_has_vtag_icache && mm == current->active_mm) {
linux-4.15.18+/arch/mips/mm/c-r4k.c:937:	if (mm == current->active_mm) {
linux-4.15.18+/arch/mips/mm/c-r4k.c:1003:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/mips/mm/c-r4k.c:1009:	args.mm = current->mm;
linux-4.15.18+/arch/mips/mm/c-r4k.c:1016:	up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:77:	mm_context_t *mm_ctx = &current->mm->context;
linux-4.15.18+/arch/mips/math-emu/dsemul.c:119:	pr_debug("allocate emuframe %d to %d\n", idx, current->pid);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:131:	pr_debug("free emuframe %d from %d\n", idx, current->pid);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:183:	fr_idx = atomic_read(&current->thread.bd_emu_frame);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:196:		regs->cp0_epc = current->thread.bd_emu_branch_pc;
linux-4.15.18+/arch/mips/math-emu/dsemul.c:198:		regs->cp0_epc = current->thread.bd_emu_cont_pc;
linux-4.15.18+/arch/mips/math-emu/dsemul.c:200:	atomic_set(&current->thread.bd_emu_frame, BD_EMUFRAME_NONE);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:201:	free_emuframe(fr_idx, current->mm);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:248:	fr_idx = atomic_read(&current->thread.bd_emu_frame);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:275:		free_emuframe(fr_idx, current->mm);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:280:	current->thread.bd_emu_branch_pc = branch_pc;
linux-4.15.18+/arch/mips/math-emu/dsemul.c:281:	current->thread.bd_emu_cont_pc = cont_pc;
linux-4.15.18+/arch/mips/math-emu/dsemul.c:282:	atomic_set(&current->thread.bd_emu_frame, fr_idx);
linux-4.15.18+/arch/mips/math-emu/dsemul.c:302:	xcp->cp0_epc = current->thread.bd_emu_cont_pc;
linux-4.15.18+/arch/mips/math-emu/cp1emu.c:711:			fpr = &current->thread.fpu.fpr[insn.i_format.rt];
linux-4.15.18+/arch/mips/math-emu/cp1emu.c:740:				fcr31 = current->thread.fpu.fcr31;
linux-4.15.18+/arch/mips/math-emu/cp1emu.c:1194:			fpr = &current->thread.fpu.fpr[MIPSInst_RT(ir)];
linux-4.15.18+/arch/mips/math-emu/ieee754.h:166:#define ieee754_csr (*(struct _ieee754_csr *)(&current->thread.fpu.fcr31))
linux-4.15.18+/arch/mips/cavium-octeon/crypto/octeon-crypto.c:37:		octeon_cop2_save(&(current->thread.cp2));
linux-4.15.18+/arch/mips/cavium-octeon/cpu.c:31:		prefetch(&current->thread.cp2);
linux-4.15.18+/arch/mips/cavium-octeon/cpu.c:36:		octeon_cop2_restore(&(current->thread.cp2));
linux-4.15.18+/arch/mips/kernel/ptrace.c:988: * - triggered by current->work.syscall_trace
linux-4.15.18+/arch/mips/kernel/ptrace.c:1039: * - triggered by current->work.syscall_trace
linux-4.15.18+/arch/mips/kernel/entry.S:51:	LONG_L	a2, TI_FLAGS($28)	# current->work
linux-4.15.18+/arch/mips/kernel/entry.S:85:	LONG_L	a2, TI_FLAGS($28)	# current->work
linux-4.15.18+/arch/mips/kernel/entry.S:146:	LONG_L	a2, TI_FLAGS($28)	# current->work
linux-4.15.18+/arch/mips/kernel/process.c:74:	atomic_set(&current->thread.bd_emu_frame, BD_EMUFRAME_NONE);
linux-4.15.18+/arch/mips/kernel/process.c:86:	if (!(current->flags & PF_KTHREAD))
linux-4.15.18+/arch/mips/kernel/process.c:652:	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
linux-4.15.18+/arch/mips/kernel/process.c:698:	if (current->mm == mm)
linux-4.15.18+/arch/mips/kernel/process.c:739:	if (task->signal == current->signal)
linux-4.15.18+/arch/mips/kernel/process.c:753:		max_users = (task->mm == current->mm) ? 1 : 0;
linux-4.15.18+/arch/mips/kernel/process.c:755:		if (atomic_read(&current->mm->mm_users) > max_users)
linux-4.15.18+/arch/mips/kernel/process.c:757:					  (void *)current->mm, 1);
linux-4.15.18+/arch/mips/kernel/traps.c:364:	       current->comm, current->pid, current_thread_info(), current,
linux-4.15.18+/arch/mips/kernel/traps.c:392:	if (notify_die(DIE_OOPS, str, regs, 0, current->thread.trap_nr,
linux-4.15.18+/arch/mips/kernel/traps.c:478:	if (notify_die(DIE_OOPS, "bus error", regs, 0, current->thread.trap_nr,
linux-4.15.18+/arch/mips/kernel/traps.c:763:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/mips/kernel/traps.c:764:		vma = find_vma(current->mm, (unsigned long)fault_addr);
linux-4.15.18+/arch/mips/kernel/traps.c:769:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/arch/mips/kernel/traps.c:812:	sig = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 1,
linux-4.15.18+/arch/mips/kernel/traps.c:819:	fcr31 = mask_fcr31_x(current->thread.fpu.fcr31);
linux-4.15.18+/arch/mips/kernel/traps.c:820:	current->thread.fpu.fcr31 &= ~fcr31;
linux-4.15.18+/arch/mips/kernel/traps.c:841:	if (notify_die(DIE_FP, "FP exception", regs, 0, current->thread.trap_nr,
linux-4.15.18+/arch/mips/kernel/traps.c:866:		sig = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 1,
linux-4.15.18+/arch/mips/kernel/traps.c:873:		fcr31 = mask_fcr31_x(current->thread.fpu.fcr31);
linux-4.15.18+/arch/mips/kernel/traps.c:874:		current->thread.fpu.fcr31 &= ~fcr31;
linux-4.15.18+/arch/mips/kernel/traps.c:897:	if (kgdb_ll_trap(DIE_TRAP, str, regs, code, current->thread.trap_nr,
linux-4.15.18+/arch/mips/kernel/traps.c:902:	if (notify_die(DIE_TRAP, str, regs, code, current->thread.trap_nr,
linux-4.15.18+/arch/mips/kernel/traps.c:969:	current->thread.trap_nr = (regs->cp0_cause >> 2) & 0x1f;
linux-4.15.18+/arch/mips/kernel/traps.c:1011:			       current->thread.trap_nr, SIGTRAP) == NOTIFY_STOP)
linux-4.15.18+/arch/mips/kernel/traps.c:1017:			       current->thread.trap_nr, SIGTRAP) == NOTIFY_STOP)
linux-4.15.18+/arch/mips/kernel/traps.c:1023:			       current->thread.trap_nr, SIGTRAP) == NOTIFY_STOP)
linux-4.15.18+/arch/mips/kernel/traps.c:1029:			       current->thread.trap_nr, SIGTRAP) == NOTIFY_STOP)
linux-4.15.18+/arch/mips/kernel/traps.c:1062:	current->thread.trap_nr = (regs->cp0_cause >> 2) & 0x1f;
linux-4.15.18+/arch/mips/kernel/traps.c:1118:					     &current->thread.cp0_baduaddr,
linux-4.15.18+/arch/mips/kernel/traps.c:1127:	current->thread.trap_nr = (regs->cp0_cause >> 2) & 0x1f;
linux-4.15.18+/arch/mips/kernel/traps.c:1129:	if (notify_die(DIE_RI, "RI Fault", regs, 0, current->thread.trap_nr,
linux-4.15.18+/arch/mips/kernel/traps.c:1189:	     ((current->thread.emulated_fp++ > mt_fpemul_threshold))) {
linux-4.15.18+/arch/mips/kernel/traps.c:1195:		if (cpumask_intersects(&current->cpus_allowed, &mt_fpu_cpumask)) {
linux-4.15.18+/arch/mips/kernel/traps.c:1198:			current->thread.user_cpus_allowed
linux-4.15.18+/arch/mips/kernel/traps.c:1199:				= current->cpus_allowed;
linux-4.15.18+/arch/mips/kernel/traps.c:1200:			cpumask_and(&tmask, &current->cpus_allowed,
linux-4.15.18+/arch/mips/kernel/traps.c:1244:	wait_on_atomic_t(&current->mm->context.fp_mode_switching,
linux-4.15.18+/arch/mips/kernel/traps.c:1304:	write_msa_csr(current->thread.fpu.msacsr);
linux-4.15.18+/arch/mips/kernel/traps.c:1341:						 current->thread.fpu.fcr31);
linux-4.15.18+/arch/mips/kernel/traps.c:1423:		sig = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 0,
linux-4.15.18+/arch/mips/kernel/traps.c:1430:		fcr31 = mask_fcr31_x(current->thread.fpu.fcr31);
linux-4.15.18+/arch/mips/kernel/traps.c:1431:		current->thread.fpu.fcr31 &= ~fcr31;
linux-4.15.18+/arch/mips/kernel/traps.c:1452:	current->thread.trap_nr = (regs->cp0_cause >> 2) & 0x1f;
linux-4.15.18+/arch/mips/kernel/traps.c:1454:		       current->thread.trap_nr, SIGFPE) == NOTIFY_STOP)
linux-4.15.18+/arch/mips/kernel/traps.c:2226:	current->active_mm = &init_mm;
linux-4.15.18+/arch/mips/kernel/traps.c:2227:	BUG_ON(current->mm);
linux-4.15.18+/arch/mips/kernel/vdso.c:100:	struct mips_vdso_image *image = current->thread.abi->vdso;
linux-4.15.18+/arch/mips/kernel/vdso.c:101:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/mips/kernel/signal.c:71:	struct mips_abi *abi = current->thread.abi;
linux-4.15.18+/arch/mips/kernel/signal.c:80:		    __put_user(get_fpr64(&current->thread.fpu.fpr[i], 0),
linux-4.15.18+/arch/mips/kernel/signal.c:83:	err |= __put_user(current->thread.fpu.fcr31, csr);
linux-4.15.18+/arch/mips/kernel/signal.c:90:	struct mips_abi *abi = current->thread.abi;
linux-4.15.18+/arch/mips/kernel/signal.c:100:		set_fpr64(&current->thread.fpu.fpr[i], 0, fpr_val);
linux-4.15.18+/arch/mips/kernel/signal.c:102:	err |= __get_user(current->thread.fpu.fcr31, csr);
linux-4.15.18+/arch/mips/kernel/signal.c:112:	struct mips_abi *abi = current->thread.abi;
linux-4.15.18+/arch/mips/kernel/signal.c:121:	struct mips_abi *abi = current->thread.abi;
linux-4.15.18+/arch/mips/kernel/signal.c:177:		err = __put_user(current->thread.fpu.msacsr, &msa->csr);
linux-4.15.18+/arch/mips/kernel/signal.c:180:			val = get_fpr64(&current->thread.fpu.fpr[i], 1);
linux-4.15.18+/arch/mips/kernel/signal.c:226:		current->thread.fpu.msacsr = csr;
linux-4.15.18+/arch/mips/kernel/signal.c:230:			set_fpr64(&current->thread.fpu.fpr[i], 1, val);
linux-4.15.18+/arch/mips/kernel/signal.c:298:	struct mips_abi *abi = current->thread.abi;
linux-4.15.18+/arch/mips/kernel/signal.c:351:	struct mips_abi *abi = current->thread.abi;
linux-4.15.18+/arch/mips/kernel/signal.c:494:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/mips/kernel/signal.c:701:	       current->comm, current->pid,
linux-4.15.18+/arch/mips/kernel/signal.c:748:	       current->comm, current->pid,
linux-4.15.18+/arch/mips/kernel/signal.c:772:	struct mips_abi *abi = current->thread.abi;
linux-4.15.18+/arch/mips/kernel/signal.c:773:	void *vdso = current->mm->context.vdso;
linux-4.15.18+/arch/mips/kernel/signal.c:835:			regs->regs[2] = current->thread.abi->restart;
linux-4.15.18+/arch/mips/kernel/branch.c:152:				fcr31 = current->thread.fpu.fcr31;
linux-4.15.18+/arch/mips/kernel/branch.c:688:			bit = get_fpr32(&current->thread.fpu.fpr[reg], 0) & 0x1;
linux-4.15.18+/arch/mips/kernel/branch.c:706:				fcr31 = current->thread.fpu.fcr31;
linux-4.15.18+/arch/mips/kernel/branch.c:822:		 current->comm);
linux-4.15.18+/arch/mips/kernel/branch.c:827:		 current->comm);
linux-4.15.18+/arch/mips/kernel/branch.c:832:		 current->comm);
linux-4.15.18+/arch/mips/kernel/branch.c:860:	printk("%s: unaligned epc - sending SIGBUS.\n", current->comm);
linux-4.15.18+/arch/mips/kernel/signal_n32.c:145:	       current->comm, current->pid,
linux-4.15.18+/arch/mips/kernel/watch.c:53:		&current->thread.watch.mips3264;
linux-4.15.18+/arch/mips/kernel/signal_o32.c:93:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/mips/kernel/signal_o32.c:148:	       current->comm, current->pid,
linux-4.15.18+/arch/mips/kernel/signal_o32.c:232:	       current->comm, current->pid,
linux-4.15.18+/arch/mips/kernel/ftrace.c:333:	if (unlikely(atomic_read(&current->tracing_graph_pause)))
linux-4.15.18+/arch/mips/kernel/ftrace.c:389:		current->curr_ret_stack--;
linux-4.15.18+/arch/mips/kernel/kgdb.c:146:			memcpy((void *)&current->thread.fpu.fcr31, mem,
linux-4.15.18+/arch/mips/kernel/kgdb.c:154:		memcpy((void *)&current->thread.fpu.fpr[fp_reg], mem,
linux-4.15.18+/arch/mips/kernel/kgdb.c:181:			memcpy(mem, (void *)&current->thread.fpu.fcr31,
linux-4.15.18+/arch/mips/kernel/kgdb.c:190:		memcpy(mem, (void *)&current->thread.fpu.fpr[fp_reg],
linux-4.15.18+/arch/mips/kernel/linux32.c:122:	if (personality(current->personality) == PER_LINUX32 &&
linux-4.15.18+/arch/mips/kernel/smp.c:533:	if ((atomic_read(&mm->mm_users) != 1) || (current->mm != mm)) {
linux-4.15.18+/arch/mips/kernel/smp.c:566:	if ((atomic_read(&mm->mm_users) != 1) || (current->mm != mm)) {
linux-4.15.18+/arch/mips/kernel/smp.c:620:	if ((atomic_read(&vma->vm_mm->mm_users) != 1) || (current->mm != vma->vm_mm)) {
linux-4.15.18+/arch/mips/kernel/uprobes.c:107:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/mips/kernel/uprobes.c:122:	utask->autask.saved_trap_nr = current->thread.trap_nr;
linux-4.15.18+/arch/mips/kernel/uprobes.c:123:	current->thread.trap_nr = UPROBE_TRAP_NR;
linux-4.15.18+/arch/mips/kernel/uprobes.c:124:	regs->cp0_epc = current->utask->xol_vaddr;
linux-4.15.18+/arch/mips/kernel/uprobes.c:131:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/mips/kernel/uprobes.c:133:	current->thread.trap_nr = utask->autask.saved_trap_nr;
linux-4.15.18+/arch/mips/kernel/uprobes.c:194:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/arch/mips/kernel/pm.c:48:	if (current->mm)
linux-4.15.18+/arch/mips/kernel/pm.c:49:		write_c0_entryhi(cpu_asid(cpu, current->mm));
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:204:	csr = current->thread.fpu.fcr31;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:227:	csr = current->thread.fpu.fcr31;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1185:		err = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 0,
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1192:		*fcr31 = res = mask_fcr31_x(current->thread.fpu.fcr31);
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1193:		current->thread.fpu.fcr31 &= ~res;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1206:			current->thread.cp0_baduaddr = (unsigned long)fault_addr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1216:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1289:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1363:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1433:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1508:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1627:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1746:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1864:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1976:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:1981:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:2032:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:2037:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:2095:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:2100:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:2156:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/mips-r2-to-r6-emul.c:2161:			current->thread.cp0_baduaddr = vaddr;
linux-4.15.18+/arch/mips/kernel/unaligned.c:1225:		res = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 1,
linux-4.15.18+/arch/mips/kernel/unaligned.c:1249:		fpr = &current->thread.fpu.fpr[wd];
linux-4.15.18+/arch/mips/kernel/unaligned.c:1738:		res = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 1,
linux-4.15.18+/arch/mips/kernel/kprobes.c:234:	pr_notice("%s: unaligned epc - sending SIGBUS.\n", current->comm);
linux-4.15.18+/arch/um/kernel/ptrace.c:151:	int ptraced = current->ptrace;
linux-4.15.18+/arch/um/kernel/trap.c:28:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/um/kernel/trap.c:95:				current->maj_flt++;
linux-4.15.18+/arch/um/kernel/trap.c:97:				current->min_flt++;
linux-4.15.18+/arch/um/kernel/trap.c:170:	current->thread.arch.faultinfo = fi;
linux-4.15.18+/arch/um/kernel/trap.c:177:	do_signal(&current->thread.regs);
linux-4.15.18+/arch/um/kernel/trap.c:224:		current->thread.segv_regs = container_of(regs, struct pt_regs, regs);
linux-4.15.18+/arch/um/kernel/trap.c:230:	else if (current->mm == NULL) {
linux-4.15.18+/arch/um/kernel/trap.c:253:	catcher = current->thread.fault_catcher;
linux-4.15.18+/arch/um/kernel/trap.c:257:		current->thread.fault_addr = (void *) address;
linux-4.15.18+/arch/um/kernel/trap.c:260:	else if (current->thread.fault_addr != NULL)
linux-4.15.18+/arch/um/kernel/trap.c:278:		current->thread.arch.faultinfo = fi;
linux-4.15.18+/arch/um/kernel/trap.c:284:		current->thread.arch.faultinfo = fi;
linux-4.15.18+/arch/um/kernel/trap.c:290:		current->thread.segv_regs = NULL;
linux-4.15.18+/arch/um/kernel/trap.c:321:		current->thread.arch.faultinfo = *fi;
linux-4.15.18+/arch/um/kernel/trap.c:336:	if (current->thread.fault_catcher != NULL)
linux-4.15.18+/arch/um/kernel/trap.c:337:		UML_LONGJMP(current->thread.fault_catcher, 1);
linux-4.15.18+/arch/um/kernel/process.c:94:	return current->thread.prev_sched;
linux-4.15.18+/arch/um/kernel/process.c:99:	struct pt_regs *regs = &current->thread.regs;
linux-4.15.18+/arch/um/kernel/process.c:123:	if (current->thread.prev_sched != NULL)
linux-4.15.18+/arch/um/kernel/process.c:124:		schedule_tail(current->thread.prev_sched);
linux-4.15.18+/arch/um/kernel/process.c:125:	current->thread.prev_sched = NULL;
linux-4.15.18+/arch/um/kernel/process.c:127:	fn = current->thread.request.u.thread.proc;
linux-4.15.18+/arch/um/kernel/process.c:128:	arg = current->thread.request.u.thread.arg;
linux-4.15.18+/arch/um/kernel/process.c:134:	userspace(&current->thread.regs.regs, current_thread_info()->aux_fp_regs);
linux-4.15.18+/arch/um/kernel/process.c:142:	schedule_tail(current->thread.prev_sched);
linux-4.15.18+/arch/um/kernel/process.c:151:	current->thread.prev_sched = NULL;
linux-4.15.18+/arch/um/kernel/process.c:153:	userspace(&current->thread.regs.regs, current_thread_info()->aux_fp_regs);
linux-4.15.18+/arch/um/kernel/process.c:160:	int kthread = current->flags & PF_KTHREAD;
linux-4.15.18+/arch/um/kernel/process.c:174:		arch_copy_thread(&current->thread.arch, &p->thread.arch);
linux-4.15.18+/arch/um/kernel/process.c:354:	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
linux-4.15.18+/arch/um/kernel/irq.c:463:	current->stack = to;
linux-4.15.18+/arch/um/kernel/exec.c:27:	arch_flush_thread(&current->thread.arch);
linux-4.15.18+/arch/um/kernel/exec.c:29:	ret = unmap(&current->mm->context.id, 0, STUB_START, 0, &data);
linux-4.15.18+/arch/um/kernel/exec.c:30:	ret = ret || unmap(&current->mm->context.id, STUB_END,
linux-4.15.18+/arch/um/kernel/exec.c:40:	__switch_mm(&current->mm->context.id);
linux-4.15.18+/arch/um/kernel/exec.c:47:	current->ptrace &= ~PT_DTRACE;
linux-4.15.18+/arch/um/kernel/tlb.c:303:		up_write(&current->mm->mmap_sem);
linux-4.15.18+/arch/um/kernel/tlb.c:305:		do_signal(&current->thread.regs);
linux-4.15.18+/arch/um/kernel/tlb.c:494:	flush_tlb_mm(current->mm);
linux-4.15.18+/arch/um/kernel/tlb.c:552:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/um/kernel/signal.c:28:	if ((current->ptrace & PT_DTRACE) && (current->ptrace & PT_PTRACED))
linux-4.15.18+/arch/um/kernel/signal.c:55:		sp = current->sas_ss_sp + current->sas_ss_size;
linux-4.15.18+/arch/um/kernel/signal.c:103:	if (current->ptrace & PT_DTRACE)
linux-4.15.18+/arch/um/kernel/signal.c:104:		current->thread.singlestep_syscall =
linux-4.15.18+/arch/um/kernel/signal.c:105:			is_syscall(PT_REGS_IP(&current->thread.regs));
linux-4.15.18+/arch/um/kernel/skas/process.c:51:	if (current->mm == NULL)
linux-4.15.18+/arch/um/kernel/skas/process.c:54:	return current->mm->context.id.stack;
linux-4.15.18+/arch/um/kernel/skas/mmu.c:63:	if (current->mm != NULL && current->mm != &init_mm)
linux-4.15.18+/arch/um/kernel/skas/mmu.c:64:		from_mm = &current->mm->context;
linux-4.15.18+/arch/um/kernel/skas/uaccess.c:43:	pte_t *pte = virt_to_pte(current->mm, virt);
linux-4.15.18+/arch/um/kernel/skas/uaccess.c:51:		pte = virt_to_pte(current->mm, virt);
linux-4.15.18+/arch/um/kernel/skas/uaccess.c:75:	current->thread.fault_catcher = &buf;
linux-4.15.18+/arch/um/kernel/skas/uaccess.c:83:	current->thread.fault_catcher = NULL;
linux-4.15.18+/arch/um/kernel/sysrq.c:34:	struct pt_regs *segv_regs = current->thread.segv_regs;
linux-4.15.18+/arch/frv/include/asm/math-emu.h:128:#define FPDATA		((struct fp_data *)current->thread.fp)
linux-4.15.18+/arch/frv/include/asm/user.h:35: *   The data area is stored.  We use current->end_text to
linux-4.15.18+/arch/frv/include/asm/user.h:36: *   current->brk to pick up all of the user variables, plus any
linux-4.15.18+/arch/frv/include/asm/user.h:46: *   current->start_stack, so we round each of these off in order to
linux-4.15.18+/arch/frv/include/asm/page.h:66:	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
linux-4.15.18+/arch/frv/include/asm/pgtable.h:491:	mm = current->mm;
linux-4.15.18+/arch/frv/mm/fault.c:55:	mm = current->mm;
linux-4.15.18+/arch/frv/mm/fault.c:108:			       current->pid, ear0, __frame->sp);
linux-4.15.18+/arch/frv/mm/fault.c:111:			       current->pid,
linux-4.15.18+/arch/frv/mm/fault.c:179:		current->maj_flt++;
linux-4.15.18+/arch/frv/mm/fault.c:181:		current->min_flt++;
linux-4.15.18+/arch/frv/mm/fault.c:231:	pge = pgd_offset(current->mm, ear0);
linux-4.15.18+/arch/frv/mm/elf-fdpic.c:76:		vma = find_vma(current->mm, addr);
linux-4.15.18+/arch/frv/mm/elf-fdpic.c:86:	info.high_limit = (current->mm->start_stack - 0x00200000);
linux-4.15.18+/arch/frv/kernel/process.c:272:	       &current->thread.user->f,
linux-4.15.18+/arch/frv/kernel/process.c:273:	       sizeof(current->thread.user->f));
linux-4.15.18+/arch/frv/kernel/traps.c:579:	printk("\nProcess %s (pid: %d)\n\n", current->comm, current->pid);
linux-4.15.18+/arch/frv/kernel/signal.c:61:	struct user_context *user = current->thread.user;
linux-4.15.18+/arch/frv/kernel/signal.c:65:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/frv/kernel/signal.c:142:	save_user_regs(current->thread.user);
linux-4.15.18+/arch/frv/kernel/signal.c:144:	if (copy_to_user(&sc->sc_context, current->thread.user, sizeof(sc->sc_context)) != 0)
linux-4.15.18+/arch/frv/kernel/signal.c:217:	if (current->personality & FDPIC_FUNCPTRS) {
linux-4.15.18+/arch/frv/kernel/signal.c:236:	       sig, current->comm, current->pid, frame, __frame->pc,
linux-4.15.18+/arch/frv/kernel/signal.c:298:	if (current->personality & FDPIC_FUNCPTRS) {
linux-4.15.18+/arch/frv/kernel/signal.c:318:	       sig, current->comm, current->pid, frame, __frame->pc,
linux-4.15.18+/arch/frv/kernel/break.S:671:	ldi.p		@(gr29,#4),gr15		; __current_thread_info = current->thread_info
linux-4.15.18+/arch/frv/kernel/switch_to.S:82:	ldi		@(gr11,#4),gr19		; get new_current->thread_info
linux-4.15.18+/arch/frv/kernel/gdb-stub.c:1200:	gdbstub_printk("Process %s (pid: %d)\n", current->comm, current->pid);
linux-4.15.18+/arch/frv/kernel/entry.S:153:	ldi.p		@(gr29,#4),gr15		; __current_thread_info = current->thread_info
linux-4.15.18+/arch/frv/kernel/entry.S:555:	ldi		@(gr29,#4),gr15		; __current_thread_info = current->thread_info
linux-4.15.18+/arch/mn10300/include/asm/switch_to.h:43:	current->thread.wchan = (u_long) __builtin_return_address(0);	\
linux-4.15.18+/arch/mn10300/include/asm/switch_to.h:46:	current->thread.wchan = 0;					\
linux-4.15.18+/arch/mn10300/include/asm/page.h:125:	((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0) | \
linux-4.15.18+/arch/mn10300/include/asm/elf.h:75:	struct pt_regs *_ur = current->thread.uregs;			\
linux-4.15.18+/arch/mn10300/include/asm/mmu_context.h:116: * after we have set current->mm to a new value, this activates the context for
linux-4.15.18+/arch/mn10300/mm/tlb-smp.c:163:	struct mm_struct *mm = current->mm;
linux-4.15.18+/arch/mn10300/mm/fault.c:194:			       current->pid, address, regs->sp);
linux-4.15.18+/arch/mn10300/mm/fault.c:202:			       current->pid,
linux-4.15.18+/arch/mn10300/mm/fault.c:273:			current->maj_flt++;
linux-4.15.18+/arch/mn10300/mm/fault.c:275:			current->min_flt++;
linux-4.15.18+/arch/mn10300/mm/cache-flush-icache.c:65:	pgd = pgd_offset(current->mm, start);
linux-4.15.18+/arch/mn10300/mm/cache-inv-icache.c:43:	pgd = pgd_offset(current->mm, start);
linux-4.15.18+/arch/mn10300/kernel/mn10300-watchdog.c:132:	 * Since current-> is always on the stack, and we always switch
linux-4.15.18+/arch/mn10300/kernel/traps.c:326:		       current->comm, current->pid);
linux-4.15.18+/arch/mn10300/kernel/signal.c:43:	current->restart_block.fn = do_no_restart_syscall;
linux-4.15.18+/arch/mn10300/kernel/signal.c:253:	       sig, current->comm, current->pid, frame, regs->pc,
linux-4.15.18+/arch/mn10300/kernel/signal.c:319:	       sig, current->comm, current->pid, frame, regs->pc,
linux-4.15.18+/arch/mn10300/kernel/signal.c:409: * - triggered by current->work.notify_resume
linux-4.15.18+/arch/mn10300/kernel/smp.c:594:	current->active_mm = &init_mm;
linux-4.15.18+/arch/mn10300/kernel/smp.c:595:	BUG_ON(current->mm);
linux-4.15.18+/arch/mn10300/kernel/smp.c:927:		: "a"(current->thread.sp), "a"(current->thread.pc));
linux-4.15.18+/arch/mn10300/kernel/smp.c:998:	cpumask_clear_cpu(cpu, &mm_cpumask(current->active_mm));
linux-4.15.18+/mm/vmacache.c:59:	return current->mm == mm && !(current->flags & PF_KTHREAD);
linux-4.15.18+/mm/vmacache.c:65:		current->vmacache.vmas[VMACACHE_HASH(addr)] = newvma;
linux-4.15.18+/mm/vmacache.c:98:		struct vm_area_struct *vma = current->vmacache.vmas[i];
linux-4.15.18+/mm/vmacache.c:126:		struct vm_area_struct *vma = current->vmacache.vmas[i];
linux-4.15.18+/mm/msync.c:35:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mincore.c:189:	vma = find_vma(current->mm, addr);
linux-4.15.18+/mm/mincore.c:256:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/mincore.c:258:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/mprotect.c:400:	const bool rier = (current->personality & READ_IMPLIES_EXEC) &&
linux-4.15.18+/mm/mprotect.c:420:	if (down_write_killable(&current->mm->mmap_sem))
linux-4.15.18+/mm/mprotect.c:428:	if ((pkey != -1) && !mm_pkey_is_allocated(current->mm, pkey))
linux-4.15.18+/mm/mprotect.c:431:	vma = find_vma(current->mm, start);
linux-4.15.18+/mm/mprotect.c:510:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/mprotect.c:540:	down_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/mprotect.c:541:	pkey = mm_pkey_alloc(current->mm);
linux-4.15.18+/mm/mprotect.c:549:		mm_pkey_free(current->mm, pkey);
linux-4.15.18+/mm/mprotect.c:554:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/mprotect.c:562:	down_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/mprotect.c:563:	ret = mm_pkey_free(current->mm, pkey);
linux-4.15.18+/mm/mprotect.c:564:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/slob.c:210:	if (current->reclaim_state)
linux-4.15.18+/mm/slob.c:211:		current->reclaim_state->reclaimed_slab += 1 << order;
linux-4.15.18+/mm/oom_kill.c:430:		current->comm, oc->gfp_mask, &oc->gfp_mask,
linux-4.15.18+/mm/oom_kill.c:432:			current->signal->oom_score_adj);
linux-4.15.18+/mm/oom_kill.c:1064:	    current->mm && !oom_unkillable_task(current, NULL, oc->nodemask) &&
linux-4.15.18+/mm/oom_kill.c:1065:	    current->signal->oom_score_adj != OOM_SCORE_ADJ_MIN) {
linux-4.15.18+/mm/page-writeback.c:1659:			current->dirty_paused_when = now;
linux-4.15.18+/mm/page-writeback.c:1660:			current->nr_dirtied = 0;
linux-4.15.18+/mm/page-writeback.c:1663:			current->nr_dirtied_pause = min(intv, m_intv);
linux-4.15.18+/mm/page-writeback.c:1727:		if (current->dirty_paused_when)
linux-4.15.18+/mm/page-writeback.c:1728:			pause -= now - current->dirty_paused_when;
linux-4.15.18+/mm/page-writeback.c:1750:				current->dirty_paused_when = now;
linux-4.15.18+/mm/page-writeback.c:1751:				current->nr_dirtied = 0;
linux-4.15.18+/mm/page-writeback.c:1753:				current->dirty_paused_when += period;
linux-4.15.18+/mm/page-writeback.c:1754:				current->nr_dirtied = 0;
linux-4.15.18+/mm/page-writeback.c:1755:			} else if (current->nr_dirtied_pause <= pages_dirtied)
linux-4.15.18+/mm/page-writeback.c:1756:				current->nr_dirtied_pause += pages_dirtied;
linux-4.15.18+/mm/page-writeback.c:1782:		current->dirty_paused_when = now + pause;
linux-4.15.18+/mm/page-writeback.c:1783:		current->nr_dirtied = 0;
linux-4.15.18+/mm/page-writeback.c:1784:		current->nr_dirtied_pause = nr_dirtied_pause;
linux-4.15.18+/mm/page-writeback.c:1878:	ratelimit = current->nr_dirtied_pause;
linux-4.15.18+/mm/page-writeback.c:1890:	if (unlikely(current->nr_dirtied >= ratelimit))
linux-4.15.18+/mm/page-writeback.c:1902:	if (*p > 0 && current->nr_dirtied < ratelimit) {
linux-4.15.18+/mm/page-writeback.c:1904:		nr_pages_dirtied = min(*p, ratelimit - current->nr_dirtied);
linux-4.15.18+/mm/page-writeback.c:1906:		current->nr_dirtied += nr_pages_dirtied;
linux-4.15.18+/mm/page-writeback.c:1910:	if (unlikely(current->nr_dirtied >= ratelimit))
linux-4.15.18+/mm/page-writeback.c:1911:		balance_dirty_pages(wb, current->nr_dirtied);
linux-4.15.18+/mm/page-writeback.c:2424:		current->nr_dirtied++;
linux-4.15.18+/mm/page-writeback.c:2507:		current->nr_dirtied--;
linux-4.15.18+/mm/frame_vector.c:37:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/vmscan.c:550:	if (current->flags & PF_SWAPWRITE)
linux-4.15.18+/mm/vmscan.c:554:	if (inode_to_bdi(inode) == current->backing_dev_info)
linux-4.15.18+/mm/vmscan.c:1740:	return !(current->flags & PF_LESS_THROTTLE) ||
linux-4.15.18+/mm/vmscan.c:1741:		current->backing_dev_info == NULL ||
linux-4.15.18+/mm/vmscan.c:1742:		bdi_write_congested(current->backing_dev_info);
linux-4.15.18+/mm/vmscan.c:2587:	struct reclaim_state *reclaim_state = current->reclaim_state;
linux-4.15.18+/mm/vmscan.c:2971:	if (current->flags & PF_KTHREAD)
linux-4.15.18+/mm/vmscan.c:3554:	current->reclaim_state = &reclaim_state;
linux-4.15.18+/mm/vmscan.c:3618:	current->reclaim_state = NULL;
linux-4.15.18+/mm/vmscan.c:3889:	current->flags &= ~PF_SWAPWRITE;
linux-4.15.18+/mm/vmscan.c:3915:	if (!gfpflags_allow_blocking(gfp_mask) || (current->flags & PF_MEMALLOC))
linux-4.15.18+/mm/frontswap.c:402:		if (security_vm_enough_memory_mm(current->mm, pages)) {
linux-4.15.18+/mm/slub.c:586:		p->pid = current->pid;
linux-4.15.18+/mm/slub.c:1680:	if (current->reclaim_state)
linux-4.15.18+/mm/slub.c:1681:		current->reclaim_state->reclaimed_slab += pages;
linux-4.15.18+/mm/util.c:301: * operating on current and current->mm, with force=0 and vma=NULL. However
linux-4.15.18+/mm/util.c:325:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/slab.c:1457:	if (current->reclaim_state)
linux-4.15.18+/mm/slab.c:1458:		current->reclaim_state->reclaimed_slab += nr_freed;
linux-4.15.18+/mm/slab.c:3151:	else if (current->mempolicy)
linux-4.15.18+/mm/slab.c:3334:	if (current->mempolicy || cpuset_do_slab_mem_spread()) {
linux-4.15.18+/mm/memcontrol.c:1531:	if (!current->memcg_may_oom)
linux-4.15.18+/mm/memcontrol.c:1548:	current->memcg_in_oom = memcg;
linux-4.15.18+/mm/memcontrol.c:1549:	current->memcg_oom_gfp_mask = mask;
linux-4.15.18+/mm/memcontrol.c:1550:	current->memcg_oom_order = order;
linux-4.15.18+/mm/memcontrol.c:1572:	struct mem_cgroup *memcg = current->memcg_in_oom;
linux-4.15.18+/mm/memcontrol.c:1600:		mem_cgroup_out_of_memory(memcg, current->memcg_oom_gfp_mask,
linux-4.15.18+/mm/memcontrol.c:1601:					 current->memcg_oom_order);
linux-4.15.18+/mm/memcontrol.c:1618:	current->memcg_in_oom = NULL;
linux-4.15.18+/mm/memcontrol.c:1893:	unsigned int nr_pages = current->memcg_nr_pages_over_high;
linux-4.15.18+/mm/memcontrol.c:1899:	memcg = get_mem_cgroup_from_mm(current->mm);
linux-4.15.18+/mm/memcontrol.c:1902:	current->memcg_nr_pages_over_high = 0;
linux-4.15.18+/mm/memcontrol.c:1947:		     current->flags & PF_EXITING))
linux-4.15.18+/mm/memcontrol.c:1956:	if (unlikely(current->flags & PF_MEMALLOC))
linux-4.15.18+/mm/memcontrol.c:2049:			current->memcg_nr_pages_over_high += batch;
linux-4.15.18+/mm/memcontrol.c:2235:	current->memcg_kmem_skip_account = 1;
linux-4.15.18+/mm/memcontrol.c:2237:	current->memcg_kmem_skip_account = 0;
linux-4.15.18+/mm/memcontrol.c:2242:	if (in_interrupt() || !current->mm || (current->flags & PF_KTHREAD))
linux-4.15.18+/mm/memcontrol.c:2274:	if (current->memcg_kmem_skip_account)
linux-4.15.18+/mm/memcontrol.c:2277:	memcg = get_mem_cgroup_from_mm(current->mm);
linux-4.15.18+/mm/memcontrol.c:2361:	memcg = get_mem_cgroup_from_mm(current->mm);
linux-4.15.18+/mm/mlock.c:524:	    is_vm_hugetlb_page(vma) || vma == get_gate_vma(current->mm))
linux-4.15.18+/mm/mlock.c:590:	vma = find_vma(current->mm, start);
linux-4.15.18+/mm/mlock.c:639:		mm = current->mm;
linux-4.15.18+/mm/mlock.c:680:	if (down_write_killable(&current->mm->mmap_sem))
linux-4.15.18+/mm/mlock.c:683:	locked += current->mm->locked_vm;
linux-4.15.18+/mm/mlock.c:691:		locked -= count_mm_mlocked_page_nr(current->mm,
linux-4.15.18+/mm/mlock.c:699:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/mlock.c:734:	if (down_write_killable(&current->mm->mmap_sem))
linux-4.15.18+/mm/mlock.c:737:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/mlock.c:757:	current->mm->def_flags &= VM_LOCKED_CLEAR_MASK;
linux-4.15.18+/mm/mlock.c:759:		current->mm->def_flags |= VM_LOCKED;
linux-4.15.18+/mm/mlock.c:762:			current->mm->def_flags |= VM_LOCKONFAULT;
linux-4.15.18+/mm/mlock.c:774:	for (vma = current->mm->mmap; vma ; vma = prev->vm_next) {
linux-4.15.18+/mm/mlock.c:802:	if (down_write_killable(&current->mm->mmap_sem))
linux-4.15.18+/mm/mlock.c:806:	if (!(flags & MCL_CURRENT) || (current->mm->total_vm <= lock_limit) ||
linux-4.15.18+/mm/mlock.c:809:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/mlock.c:820:	if (down_write_killable(&current->mm->mmap_sem))
linux-4.15.18+/mm/mlock.c:823:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/filemap.c:206:			 current->comm, page_to_pfn(page));
linux-4.15.18+/mm/filemap.c:839:		error = mem_cgroup_try_charge(page, current->mm,
linux-4.15.18+/mm/filemap.c:3209:	current->backing_dev_info = inode_to_bdi(inode);
linux-4.15.18+/mm/filemap.c:3269:	current->backing_dev_info = NULL;
linux-4.15.18+/mm/gup.c:961:	return __get_user_pages_locked(current, current->mm, start, nr_pages,
linux-4.15.18+/mm/gup.c:1009:	return __get_user_pages_unlocked(current, current->mm, start, nr_pages,
linux-4.15.18+/mm/gup.c:1092:	return __get_user_pages_locked(current, current->mm, start, nr_pages,
linux-4.15.18+/mm/gup.c:1229:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/gup.c:1302:	if (__get_user_pages(current, current->mm, addr, 1,
linux-4.15.18+/mm/gup.c:1716:	pgdp = pgd_offset(current->mm, addr);
linux-4.15.18+/mm/hugetlb.c:3676:			   current->pid);
linux-4.15.18+/mm/mmap.c:186:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:201:	if (current->brk_randomized)
linux-4.15.18+/mm/mmap.c:1319: * The caller must hold down_write(&current->mm->mmap_sem).
linux-4.15.18+/mm/mmap.c:1327:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:1341:	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
linux-4.15.18+/mm/mmap.c:1622:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:1741:					vma == get_gate_vma(current->mm)))
linux-4.15.18+/mm/mmap.c:1793:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:1888:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:2001:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:2040:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:2101:	get_area = current->mm->get_unmapped_area;
linux-4.15.18+/mm/mmap.c:2739:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:2766:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:2773:		     current->comm, current->pid);
linux-4.15.18+/mm/mmap.c:2875:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:2966:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mmap.c:3189:				     current->comm, current->pid,
linux-4.15.18+/mm/mmap.c:3229:	if (WARN_ON_ONCE(current->mm != new_vma->vm_mm))
linux-4.15.18+/mm/nommu.c:101:		vma = find_vma(current->mm, (unsigned long)objp);
linux-4.15.18+/mm/nommu.c:167:	return __get_user_pages(current, current->mm, start, nr_pages,
linux-4.15.18+/mm/nommu.c:196:	return __get_user_pages_unlocked(current, current->mm, start, nr_pages,
linux-4.15.18+/mm/nommu.c:253:		down_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/nommu.c:254:		vma = find_vma(current->mm, (unsigned long)ret);
linux-4.15.18+/mm/nommu.c:257:		up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/nommu.c:501:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/nommu.c:1013:			if (current->personality & READ_IMPLIES_EXEC) {
linux-4.15.18+/mm/nommu.c:1032:		    (current->personality & READ_IMPLIES_EXEC))
linux-4.15.18+/mm/nommu.c:1078:	if ((flags & MAP_PRIVATE) && current->ptrace)
linux-4.15.18+/mm/nommu.c:1193:	       len, current->pid, current->comm);
linux-4.15.18+/mm/nommu.c:1379:	current->mm->total_vm += len >> PAGE_SHIFT;
linux-4.15.18+/mm/nommu.c:1382:	add_vma_to_mm(current->mm, vma);
linux-4.15.18+/mm/nommu.c:1415:			len, current->pid);
linux-4.15.18+/mm/nommu.c:1421:			len, current->pid);
linux-4.15.18+/mm/nommu.c:1599:					current->pid, current->comm,
linux-4.15.18+/mm/nommu.c:1643:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/nommu.c:1711:	vma = find_vma_exact(current->mm, addr, old_len);
linux-4.15.18+/mm/nommu.c:1735:	down_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/nommu.c:1737:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/kmemleak.c:584:		object->pid = current->pid;
linux-4.15.18+/mm/kmemleak.c:588:		 * dependency issues with current->alloc_lock. In the worst
linux-4.15.18+/mm/kmemleak.c:591:		strncpy(object->comm, current->comm, sizeof(object->comm));
linux-4.15.18+/mm/kmemleak.c:1284:	if (current->mm)
linux-4.15.18+/mm/process_vm_access.c:110:		 * current/current->mm
linux-4.15.18+/mm/swapfile.c:2549:	BUG_ON(!current->mm);
linux-4.15.18+/mm/swapfile.c:2575:	if (!security_vm_enough_memory_mm(current->mm, p->pages))
linux-4.15.18+/mm/mremap.c:381:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mremap.c:397:		pr_warn_once("%s (%d): attempted to duplicate a private mapping with mremap.  This is not supported.\n", current->comm, current->pid);
linux-4.15.18+/mm/mremap.c:449:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mremap.c:527:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mremap.c:556:	if (down_write_killable(&current->mm->mmap_sem))
linux-4.15.18+/mm/mremap.c:638:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/memory-failure.c:197:	if ((flags & MF_ACTION_REQUIRED) && t->mm == current->mm) {
linux-4.15.18+/mm/kasan/kasan.c:45:	current->kasan_depth++;
linux-4.15.18+/mm/kasan/kasan.c:50:	current->kasan_depth--;
linux-4.15.18+/mm/kasan/kasan.c:458:	track->pid = current->pid;
linux-4.15.18+/mm/kasan/report.c:139:		info->access_addr, current->comm, task_pid_nr(current));
linux-4.15.18+/mm/kasan/report.c:386:	if (current->kasan_depth)
linux-4.15.18+/mm/madvise.c:431:		if (current->mm == mm)
linux-4.15.18+/mm/madvise.c:526:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/madvise.c:527:		vma = find_vma(current->mm, start);
linux-4.15.18+/mm/madvise.c:608:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/madvise.c:614:	down_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/madvise.c:827:		if (down_write_killable(&current->mm->mmap_sem))
linux-4.15.18+/mm/madvise.c:830:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/madvise.c:838:	vma = find_vma_prev(current->mm, start, &prev);
linux-4.15.18+/mm/madvise.c:875:			vma = find_vma(current->mm, start);
linux-4.15.18+/mm/madvise.c:880:		up_write(&current->mm->mmap_sem);
linux-4.15.18+/mm/madvise.c:882:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/migrate.c:1001:		if (current->flags & PF_MEMALLOC)
linux-4.15.18+/mm/migrate.c:1388:	int swapwrite = current->flags & PF_SWAPWRITE;
linux-4.15.18+/mm/migrate.c:1392:		current->flags |= PF_SWAPWRITE;
linux-4.15.18+/mm/migrate.c:1441:		current->flags &= ~PF_SWAPWRITE;
linux-4.15.18+/mm/huge_memory.c:519:	addr = current->mm->get_unmapped_area(filp, 0, len_pad,
linux-4.15.18+/mm/huge_memory.c:543:	return current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);
linux-4.15.18+/mm/rmap.c:582:	struct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;
linux-4.15.18+/mm/rmap.c:595:	struct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;
linux-4.15.18+/mm/rmap.c:603:	struct tlbflush_unmap_batch *tlb_ubc = &current->tlb_ubc;
linux-4.15.18+/mm/mempolicy.c:786:	old = current->mempolicy;
linux-4.15.18+/mm/mempolicy.c:787:	current->mempolicy = new;
linux-4.15.18+/mm/mempolicy.c:789:		current->il_prev = MAX_NUMNODES-1;
linux-4.15.18+/mm/mempolicy.c:843:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mempolicy.c:845:	struct mempolicy *pol = current->mempolicy;
linux-4.15.18+/mm/mempolicy.c:889:		} else if (pol == current->mempolicy &&
linux-4.15.18+/mm/mempolicy.c:891:			*policy = next_node_in(current->il_prev, pol->v.nodes);
linux-4.15.18+/mm/mempolicy.c:920:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/mempolicy.c:1115:	vma = find_vma(current->mm, start);
linux-4.15.18+/mm/mempolicy.c:1165:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/mempolicy.c:1588: * Falls back to current->mempolicy or system default policy, as necessary.
linux-4.15.18+/mm/mempolicy.c:1704:	policy = current->mempolicy;
linux-4.15.18+/mm/mempolicy.c:1837:	if (!(mask && current->mempolicy))
linux-4.15.18+/mm/mempolicy.c:1841:	mempolicy = current->mempolicy;
linux-4.15.18+/mm/mempolicy.c:2030:	 * No reference counting needed for current->mempolicy
linux-4.15.18+/mm/mempolicy.c:2055: * If mpol_dup() sees current->cpuset == cpuset_being_rebound, then it
linux-4.15.18+/mm/mempolicy.c:2074:	if (old == current->mempolicy) {
linux-4.15.18+/mm/memory.c:150:		if (current->rss_stat.count[i]) {
linux-4.15.18+/mm/memory.c:151:			add_mm_counter(mm, i, current->rss_stat.count[i]);
linux-4.15.18+/mm/memory.c:152:			current->rss_stat.count[i] = 0;
linux-4.15.18+/mm/memory.c:155:	current->rss_stat.events = 0;
linux-4.15.18+/mm/memory.c:707:	if (current->mm == mm)
linux-4.15.18+/mm/memory.c:757:		 current->comm,
linux-4.15.18+/mm/memory.c:4491:	struct mm_struct *mm = current->mm;
linux-4.15.18+/mm/memory.c:4534:	if (current->mm)
linux-4.15.18+/mm/memory.c:4535:		might_lock_read(&current->mm->mmap_sem);
linux-4.15.18+/mm/shmem.c:149:		0 : security_vm_enough_memory_mm(current->mm, VM_ACCT(size));
linux-4.15.18+/mm/shmem.c:163:			return security_vm_enough_memory_mm(current->mm,
linux-4.15.18+/mm/shmem.c:182:	return security_vm_enough_memory_mm(current->mm,
linux-4.15.18+/mm/shmem.c:1222:	error = mem_cgroup_try_charge(page, current->mm, GFP_KERNEL, &memcg,
linux-4.15.18+/mm/shmem.c:1658:	charge_mm = vma ? vma->vm_mm : current->mm;
linux-4.15.18+/mm/shmem.c:2028:	get_area = current->mm->get_unmapped_area;
linux-4.15.18+/mm/shmem.c:4166:	return current->mm->get_unmapped_area(file, addr, len, pgoff, flags);
linux-4.15.18+/mm/page_alloc.c:572:		current->comm, page_to_pfn(page));
linux-4.15.18+/mm/page_alloc.c:3276:		    (current->flags & (PF_MEMALLOC | PF_EXITING)))
linux-4.15.18+/mm/page_alloc.c:3298:			current->comm, &vaf, gfp_mask, &gfp_mask,
linux-4.15.18+/mm/page_alloc.c:3367:	if (current->flags & PF_DUMPCORE)
linux-4.15.18+/mm/page_alloc.c:3591:	if (current->flags & PF_MEMALLOC)
linux-4.15.18+/mm/page_alloc.c:3635:	current->reclaim_state = &reclaim_state;
linux-4.15.18+/mm/page_alloc.c:3640:	current->reclaim_state = NULL;
linux-4.15.18+/mm/page_alloc.c:3757:	if (in_serving_softirq() && (current->flags & PF_MEMALLOC))
linux-4.15.18+/mm/page_alloc.c:3760:		if (current->flags & PF_MEMALLOC)
linux-4.15.18+/mm/page_alloc.c:3863:			if (current->flags & PF_WQ_WORKER)
linux-4.15.18+/mm/page_alloc.c:4053:	if (current->flags & PF_MEMALLOC)
linux-4.15.18+/mm/page_alloc.c:4139:		WARN_ON_ONCE(current->flags & PF_MEMALLOC);
linux-4.15.18+/mm/mmu_notifier.c:272:	 * current->mm or explicitly with get_task_mm() or similar).
linux-4.15.18+/mm/mmu_notifier.c:294: * so mm has to be current->mm or the mm should be pinned safely such
linux-4.15.18+/mm/mmu_notifier.c:295: * as with get_task_mm(). If the mm is not current->mm, the mm_users
linux-4.15.18+/security/security.c:894:	if (!(current->personality & READ_IMPLIES_EXEC))
linux-4.15.18+/security/tomoyo/common.h:1125:	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
linux-4.15.18+/security/tomoyo/util.c:935:	struct mm_struct *mm = current->mm;
linux-4.15.18+/security/tomoyo/common.c:947:		const pid_t pid = current->pid;
linux-4.15.18+/security/tomoyo/tomoyo.c:327:	if (current->in_execve)
linux-4.15.18+/security/tomoyo/memory.c:21:	const pid_t pid = current->pid;
linux-4.15.18+/security/integrity/ima/ima_api.c:322:	ab = audit_log_start(current->audit_context, GFP_KERNEL,
linux-4.15.18+/security/integrity/integrity_audit.c:41:	ab = audit_log_start(current->audit_context, GFP_KERNEL, audit_msgno);
linux-4.15.18+/security/yama/yama_lsm.c:86:	if (current->flags & PF_KTHREAD) {
linux-4.15.18+/security/apparmor/procattr.c:134:				 , __func__, current->pid, token, count, hat);
linux-4.15.18+/security/apparmor/procattr.c:139:			 __func__, current->pid, token, count, "<NULL>");
linux-4.15.18+/security/apparmor/path.c:125:		get_fs_root(current->fs, &root);
linux-4.15.18+/security/apparmor/resource.c:165:					rlim = current->signal->rlim + j;
linux-4.15.18+/security/apparmor/resource.c:184:			rlim = current->signal->rlim + j;
linux-4.15.18+/security/apparmor/lsm.c:405:	if (current->in_execve) {
linux-4.15.18+/security/apparmor/lsm.c:688:	aa_inherit_files(bprm->cred, current->files);
linux-4.15.18+/security/apparmor/lsm.c:690:	current->pdeath_signal = 0;
linux-4.15.18+/security/apparmor/lsm.c:1026:	struct cred *cred = (struct cred *)current->real_cred;
linux-4.15.18+/security/keys/request_key_auth.c:155:	const struct cred *cred = current->cred;
linux-4.15.18+/security/keys/request_key_auth.c:195:		rka->pid = current->pid;
linux-4.15.18+/security/selinux/ss/services.c:519:	ab = audit_log_start(current->audit_context,
linux-4.15.18+/security/selinux/ss/services.c:754:	audit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,
linux-4.15.18+/security/selinux/ss/services.c:924:			audit_log(current->audit_context,
linux-4.15.18+/security/selinux/ss/services.c:1536:	audit_log(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR,
linux-4.15.18+/security/selinux/ss/services.c:2764:			audit_log(current->audit_context, GFP_ATOMIC,
linux-4.15.18+/security/selinux/ss/services.c:2898:				audit_log(current->audit_context,
linux-4.15.18+/security/lsm_audit.c:214:	char comm[sizeof(current->comm)];
linux-4.15.18+/security/lsm_audit.c:224:	audit_log_untrustedstring(ab, memcpy(comm, current->comm, sizeof(comm)));
linux-4.15.18+/security/lsm_audit.c:450:	ab = audit_log_start(current->audit_context, GFP_ATOMIC | __GFP_NOWARN,
linux-4.15.18+/security/commoncap.c:767: * 1) Audit candidate if current->cap_effective is set
linux-4.15.18+/security/commoncap.c:1329:			current->flags |= PF_SUPERPRIV;
linux-4.15.18+/security/smack/smack_access.c:641:	if (unlikely(current->flags & PF_KTHREAD))
linux-4.15.18+/security/smack/smack_lsm.c:135:		acc, current->comm, note);
linux-4.15.18+/security/smack/smack_lsm.c:157:		current->comm, otp->comm);
linux-4.15.18+/security/smack/smack_lsm.c:173:			inode->i_sb->s_id, inode->i_ino, current->comm);
linux-4.15.18+/security/smack/smack_lsm.c:187:		inode->i_sb->s_id, inode->i_ino, current->comm);
linux-4.15.18+/security/smack/smack_lsm.c:205:			inode->i_sb->s_id, inode->i_ino, current->comm);
linux-4.15.18+/security/smack/smack_lsm.c:216:		current->comm);
linux-4.15.18+/security/smack/smack_lsm.c:235:			inode->i_sb->s_id, inode->i_ino, current->comm);
linux-4.15.18+/security/smack/smack_lsm.c:246:		current->comm);
linux-4.15.18+/security/smack/smack_lsm.c:2312:	if (unlikely(current->flags & PF_KTHREAD)) {
linux-4.15.18+/security/smack/smack_lsm.c:2816:	if (unlikely(current->flags & PF_KTHREAD)) {
linux-4.15.18+/security/smack/smack_lsm.c:4888:	cred = (struct cred *) current->cred;
linux-4.15.18+/security/selinux/hooks.c:192:	struct cred *cred = (struct cred *) current->real_cred;
linux-4.15.18+/security/selinux/hooks.c:2563:	flush_unauthorized_files(bprm->cred, current->files);
linux-4.15.18+/security/selinux/hooks.c:2566:	current->pdeath_signal = 0;
linux-4.15.18+/security/selinux/hooks.c:2584:			rlim = current->signal->rlim + i;
linux-4.15.18+/security/selinux/hooks.c:2625:		spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/security/selinux/hooks.c:2627:			flush_sigqueue(&current->pending);
linux-4.15.18+/security/selinux/hooks.c:2628:			flush_sigqueue(&current->signal->shared_pending);
linux-4.15.18+/security/selinux/hooks.c:2630:			sigemptyset(&current->blocked);
linux-4.15.18+/security/selinux/hooks.c:2633:		spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/security/selinux/hooks.c:2639:	__wake_up_parent(current, current->real_parent);
linux-4.15.18+/security/selinux/hooks.c:3209:			ab = audit_log_start(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR);
linux-4.15.18+/security/selinux/hooks.c:5122:			       task_pid_nr(current), current->comm);
linux-4.15.18+/security/selinux/hooks.c:5997:				ab = audit_log_start(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR);
linux-4.15.18+/security/selinux/selinuxfs.c:147:		audit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_STATUS,
linux-4.15.18+/security/selinux/selinuxfs.c:274:		audit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_STATUS,
linux-4.15.18+/security/selinux/selinuxfs.c:530:	audit_log(current->audit_context, GFP_KERNEL, AUDIT_MAC_POLICY_LOAD,
linux-4.15.18+/security/keys/process_keys.c:849:	if (unlikely(current->flags & PF_EXITING)) {
linux-4.15.18+/sound/pci/rme9652/rme9652.c:2314:	rme9652->playback_pid = current->pid;
linux-4.15.18+/sound/pci/rme9652/rme9652.c:2374:	rme9652->capture_pid = current->pid;
linux-4.15.18+/sound/pci/rme9652/hdsp.c:4465:	hdsp->playback_pid = current->pid;
linux-4.15.18+/sound/pci/rme9652/hdsp.c:4542:	hdsp->capture_pid = current->pid;
linux-4.15.18+/sound/pci/korg1212/korg1212.c:1405:	korg1212->playback_pid = current->pid;
linux-4.15.18+/sound/pci/korg1212/korg1212.c:1436:	korg1212->capture_pid = current->pid;
linux-4.15.18+/sound/pci/rme9652/hdspm.c:6075:		hdspm->playback_pid = current->pid;
linux-4.15.18+/sound/pci/rme9652/hdspm.c:6081:		hdspm->capture_pid = current->pid;
linux-4.15.18+/sound/pci/asihpi/hpioctl.c:91:/* HPI_DEBUG_LOG(INFO,"hpi_release file %p, pid %d\n", file, current->pid); */
linux-4.15.18+/sound/soc/codecs/sta350.c:1144:	if (of_get_property(np, "st,overcurrent-warning-adjustment", NULL))
linux-4.15.18+/sound/core/timer.c:1696:	sprintf(str, "application %i", current->pid);
linux-4.15.18+/sound/core/timer.c:1699:	err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);
linux-4.15.18+/fs/f2fs/trace.c:78:			pid, current->comm);
linux-4.15.18+/fs/f2fs/data.c:192:			current->plug && (type == DATA || type == NODE))
linux-4.15.18+/fs/f2fs/data.c:193:			blk_finish_plug(current->plug);
linux-4.15.18+/fs/splice.c:918:	pipe = current->splice_pipe;
linux-4.15.18+/fs/splice.c:931:		current->splice_pipe = pipe;
linux-4.15.18+/fs/nfsd/vfs.c:972:	unsigned int		pflags = current->flags;
linux-4.15.18+/fs/nfsd/vfs.c:982:		current->flags |= PF_LESS_THROTTLE;
linux-4.15.18+/fs/nfsd/fault_inject.c:50:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/fs/nfsd/nfs4proc.c:256:		current->fs->umask = open->op_umask;
linux-4.15.18+/fs/nfsd/nfs4proc.c:262:		current->fs->umask = 0;
linux-4.15.18+/fs/nfsd/nfs4proc.c:609:	current->fs->umask = create->cr_umask;
linux-4.15.18+/fs/nfsd/nfs4proc.c:678:	current->fs->umask = 0;
linux-4.15.18+/fs/nfsd/nfsctl.c:153:	return exports_net_open(current->nsproxy->net_ns, file);
linux-4.15.18+/fs/nfsd/nfsctl.c:1184:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/fs/drop_caches.c:64:				current->comm, task_pid_nr(current),
linux-4.15.18+/fs/nfsd/nfs4layouts.c:206:	fl->fl_pid = current->tgid;
linux-4.15.18+/fs/nfsd/nfssvc.c:686:	/* At this point, the thread shares current->fs
linux-4.15.18+/fs/nfsd/nfssvc.c:694:	current->fs->umask = 0;
linux-4.15.18+/fs/file.c:544:	return __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);
linux-4.15.18+/fs/file.c:549:	return __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);
linux-4.15.18+/fs/file.c:563:	struct files_struct *files = current->files;
linux-4.15.18+/fs/file.c:585: * your throat.  'files' *MUST* be either current->files or obtained
linux-4.15.18+/fs/file.c:617:	__fd_install(current->files, fd, file);
linux-4.15.18+/fs/file.c:685:	struct files_struct *files = current->files;
linux-4.15.18+/fs/file.c:736:	struct files_struct *files = current->files;
linux-4.15.18+/fs/file.c:789:	struct files_struct *files = current->files;
linux-4.15.18+/fs/file.c:802:	struct files_struct *files = current->files;
linux-4.15.18+/fs/file.c:859:	struct files_struct *files = current->files;
linux-4.15.18+/fs/file.c:882:	struct files_struct *files = current->files;
linux-4.15.18+/fs/file.c:915:		struct files_struct *files = current->files;
linux-4.15.18+/fs/open.c:448:	set_fs_pwd(current->fs, &path);
linux-4.15.18+/fs/open.c:475:		set_fs_pwd(current->fs, &f.file->f_path);
linux-4.15.18+/fs/open.c:503:	set_fs_root(current->fs, &path);
linux-4.15.18+/fs/open.c:1155:	int retval = __close_fd(current->files, fd);
linux-4.15.18+/fs/nfsd/nfs4state.c:4312:	fl->fl_pid = current->tgid;
linux-4.15.18+/fs/nfsd/nfs4state.c:6053:	file_lock->fl_pid = current->tgid;
linux-4.15.18+/fs/nfsd/nfs4state.c:6209:	file_lock->fl_pid = current->tgid;
linux-4.15.18+/fs/nfsd/nfs4state.c:6271:	file_lock->fl_pid = current->tgid;
linux-4.15.18+/fs/nfsd/nfs4state.c:6522:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6540:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6563:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6590:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6626:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6697:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6730:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6751:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6775:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6828:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6862:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6883:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6906:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6957:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:6991:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:7013:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:7060:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/nfsd/nfs4state.c:7082:	struct nfsd_net *nn = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/pnode.c:305:	user_ns = current->nsproxy->mnt_ns->user_ns;
linux-4.15.18+/fs/ceph/file.c:1208:		current->journal_info = filp;
linux-4.15.18+/fs/ceph/file.c:1210:		current->journal_info = NULL;
linux-4.15.18+/fs/ceph/file.c:1321:	current->backing_dev_info = inode_to_bdi(inode);
linux-4.15.18+/fs/ceph/file.c:1448:	current->backing_dev_info = NULL;
linux-4.15.18+/fs/ceph/xattr.c:732:	struct ceph_mds_request *req = current->journal_info;
linux-4.15.18+/fs/ceph/xattr.c:781:		if (current->journal_info) {
linux-4.15.18+/fs/ceph/xattr.c:813:	if (current->journal_info &&
linux-4.15.18+/fs/ceph/xattr.c:1062:	if (current->journal_info) {
linux-4.15.18+/fs/ceph/mds_client.c:2602:	current->journal_info = req;
linux-4.15.18+/fs/ceph/mds_client.c:2610:	current->journal_info = NULL;
linux-4.15.18+/fs/ceph/addr.c:319:	if (!current->journal_info) {
linux-4.15.18+/fs/ceph/addr.c:598:		WARN_ON(!(current->flags & PF_MEMALLOC));
linux-4.15.18+/fs/ceph/addr.c:1453:		current->journal_info = vma->vm_file;
linux-4.15.18+/fs/ceph/addr.c:1455:		current->journal_info = NULL;
linux-4.15.18+/fs/ocfs2/cluster/masklog.c:94:	       level, current->comm, task_pid_nr(current),
linux-4.15.18+/fs/select.c:90:	if (ret < current->timer_slack_ns)
linux-4.15.18+/fs/select.c:91:		return current->timer_slack_ns;
linux-4.15.18+/fs/select.c:301:	if (current->personality & STICKY_TIMEOUTS)
linux-4.15.18+/fs/select.c:403:	fdt = files_fdtable(current->files);
linux-4.15.18+/fs/select.c:615:	fdt = files_fdtable(current->files);
linux-4.15.18+/fs/select.c:739:			memcpy(&current->saved_sigmask, &sigsaved,
linux-4.15.18+/fs/select.c:1029:		restart_block = &current->restart_block;
linux-4.15.18+/fs/select.c:1084:			memcpy(&current->saved_sigmask, &sigsaved,
linux-4.15.18+/fs/select.c:1109:	if (current->personality & STICKY_TIMEOUTS)
linux-4.15.18+/fs/select.c:1201:	fdt = files_fdtable(current->files);
linux-4.15.18+/fs/select.c:1338:			memcpy(&current->saved_sigmask, &sigsaved,
linux-4.15.18+/fs/select.c:1404:			memcpy(&current->saved_sigmask, &sigsaved,
linux-4.15.18+/fs/cifs/smb2file.c:146:		if (current->tgid != li->pid)
linux-4.15.18+/fs/cifs/smb2file.c:170:					       current->tgid, num, buf);
linux-4.15.18+/fs/cifs/smb2file.c:193:				       cfile->fid.volatile_fid, current->tgid,
linux-4.15.18+/fs/cifs/smb2file.c:227:					       current->tgid, num, buf);
linux-4.15.18+/fs/cifs/smb2file.c:239:				       current->tgid, num, buf);
linux-4.15.18+/fs/cifs/transport.c:60:	temp->pid = current->pid;
linux-4.15.18+/fs/cifs/misc.c:248:	buffer->Pid = cpu_to_le16((__u16)current->tgid);
linux-4.15.18+/fs/cifs/misc.c:249:	buffer->PidHigh = cpu_to_le16((__u16)(current->tgid >> 16));
linux-4.15.18+/fs/cifs/link.c:350:	io_parms.pid = current->tgid;
linux-4.15.18+/fs/cifs/link.c:390:	io_parms.pid = current->tgid;
linux-4.15.18+/fs/cifs/link.c:450:	io_parms.pid = current->tgid;
linux-4.15.18+/fs/cifs/link.c:503:	io_parms.pid = current->tgid;
linux-4.15.18+/fs/cifs/smb2transport.c:567:	temp->pid = current->pid;
linux-4.15.18+/fs/cifs/dir.c:403:				       current->tgid);
linux-4.15.18+/fs/cifs/dir.c:727:	io_parms.pid = current->tgid;
linux-4.15.18+/fs/cifs/file.c:82:			 current->comm, current->tgid);
linux-4.15.18+/fs/cifs/file.c:307:	cfile->pid = current->tgid;
linux-4.15.18+/fs/cifs/file.c:876:	lock->pid = current->tgid;
linux-4.15.18+/fs/cifs/file.c:910:		if (rw_check != CIFS_LOCK_OP && current->tgid == li->pid &&
linux-4.15.18+/fs/cifs/file.c:919:		     current->tgid == li->pid) || type == li->type))
linux-4.15.18+/fs/cifs/file.c:1484:			if (current->tgid != li->pid)
linux-4.15.18+/fs/cifs/file.c:1858:		if (!any_available && open_file->pid != current->tgid)
linux-4.15.18+/fs/cifs/file.c:2267:		pid = current->tgid;
linux-4.15.18+/fs/cifs/file.c:2545:		pid = current->tgid;
linux-4.15.18+/fs/cifs/file.c:3078:		pid = current->tgid;
linux-4.15.18+/fs/cifs/file.c:3403:		pid = current->tgid;
linux-4.15.18+/fs/cifs/file.c:3712:		pid = current->tgid;
linux-4.15.18+/fs/cifs/smb1ops.c:822:	netpid = current->tgid;
linux-4.15.18+/fs/cifs/smb1ops.c:880:	return CIFSSMBLock(0, tcon, fid->netfid, current->tgid, 0, 0, 0, 0,
linux-4.15.18+/fs/cifs/smb1ops.c:922:			   current->tgid, length, offset, unlock, lock,
linux-4.15.18+/fs/cifs/inode.c:488:	io_parms.pid = current->tgid;
linux-4.15.18+/fs/cifs/inode.c:1191:					current->tgid);
linux-4.15.18+/fs/cifs/inode.c:1212:					       current->tgid);
linux-4.15.18+/fs/cifs/inode.c:1249:					current->tgid))
linux-4.15.18+/fs/cifs/smb2inode.c:97:				     fid.volatile_fid, current->tgid,
linux-4.15.18+/fs/cifs/cifs_spnego.c:167:	sprintf(dp, ";pid=0x%x", current->pid);
linux-4.15.18+/fs/cifs/smb2ops.c:1315:			 current->tgid, length, offset, type, wait);
linux-4.15.18+/fs/cifs/connect.c:842:	current->flags |= PF_MEMALLOC;
linux-4.15.18+/fs/cifs/connect.c:2149:	if (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))
linux-4.15.18+/fs/cifs/connect.c:2253:	cifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));
linux-4.15.18+/fs/cifs/smb2pdu.c:116:	shdr->ProcessId = cpu_to_le32((__u16)current->tgid);
linux-4.15.18+/fs/cifs/smb2pdu.c:3198:		current->tgid, FILE_RENAME_INFORMATION, SMB2_O_INFO_FILE,
linux-4.15.18+/fs/cifs/smb2pdu.c:3216:		current->tgid, FILE_DISPOSITION_INFORMATION, SMB2_O_INFO_FILE,
linux-4.15.18+/fs/cifs/smb2pdu.c:3246:			current->tgid, FILE_LINK_INFORMATION, SMB2_O_INFO_FILE,
linux-4.15.18+/fs/cifs/smb2pdu.c:3282:		current->tgid, FILE_BASIC_INFORMATION, SMB2_O_INFO_FILE,
linux-4.15.18+/fs/cifs/smb2pdu.c:3292:			current->tgid, 0, SMB2_O_INFO_SECURITY, aclflag,
linux-4.15.18+/fs/cifs/smb2pdu.c:3302:		current->tgid, FILE_FULL_EA_INFORMATION, SMB2_O_INFO_FILE,
linux-4.15.18+/fs/notify/dnotify/dnotify.c:262:	fl_owner_t id = current->files;
linux-4.15.18+/fs/btrfs/file.c:1605:	nrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);
linux-4.15.18+/fs/btrfs/file.c:1920:	current->backing_dev_info = inode_to_bdi(inode);
linux-4.15.18+/fs/btrfs/file.c:1992:	current->backing_dev_info = NULL;
linux-4.15.18+/fs/btrfs/locking.c:42:	if (eb->lock_nested && current->pid == eb->lock_owner)
linux-4.15.18+/fs/btrfs/locking.c:73:	if (eb->lock_nested && current->pid == eb->lock_owner)
linux-4.15.18+/fs/btrfs/locking.c:108:	       current->pid == eb->lock_owner);
linux-4.15.18+/fs/btrfs/locking.c:112:	    current->pid == eb->lock_owner) {
linux-4.15.18+/fs/btrfs/locking.c:193:	eb->lock_owner = current->pid;
linux-4.15.18+/fs/btrfs/locking.c:208:	if (eb->lock_nested && current->pid == eb->lock_owner) {
linux-4.15.18+/fs/btrfs/locking.c:230:	if (eb->lock_nested && current->pid == eb->lock_owner) {
linux-4.15.18+/fs/btrfs/locking.c:251:	WARN_ON(eb->lock_owner == current->pid);
linux-4.15.18+/fs/btrfs/locking.c:271:	eb->lock_owner = current->pid;
linux-4.15.18+/fs/btrfs/volumes.c:476:			ioc = current->io_context;
linux-4.15.18+/fs/btrfs/volumes.c:5719:					    current->pid % map->num_stripes,
linux-4.15.18+/fs/btrfs/volumes.c:5748:					      current->pid % map->sub_stripes,
linux-4.15.18+/fs/btrfs/send.c:6670:	current->journal_info = BTRFS_SEND_TRANS_STUB;
linux-4.15.18+/fs/btrfs/send.c:6672:	current->journal_info = NULL;
linux-4.15.18+/fs/btrfs/tree-log.c:160:			root->log_start_pid = current->pid;
linux-4.15.18+/fs/btrfs/tree-log.c:161:		} else if (root->log_start_pid != current->pid) {
linux-4.15.18+/fs/btrfs/tree-log.c:177:		root->log_start_pid = current->pid;
linux-4.15.18+/fs/btrfs/transaction.c:490:	ASSERT(current->journal_info != BTRFS_SEND_TRANS_STUB);
linux-4.15.18+/fs/btrfs/transaction.c:495:	if (current->journal_info) {
linux-4.15.18+/fs/btrfs/transaction.c:497:		h = current->journal_info;
linux-4.15.18+/fs/btrfs/transaction.c:580:		current->journal_info = h;
linux-4.15.18+/fs/btrfs/transaction.c:596:	if (!current->journal_info && type != TRANS_USERSPACE)
linux-4.15.18+/fs/btrfs/transaction.c:597:		current->journal_info = h;
linux-4.15.18+/fs/btrfs/transaction.c:907:	if (current->journal_info == trans)
linux-4.15.18+/fs/btrfs/transaction.c:908:		current->journal_info = NULL;
linux-4.15.18+/fs/btrfs/transaction.c:1811:	current->journal_info = ac->newtrans;
linux-4.15.18+/fs/btrfs/transaction.c:1857:	if (current->journal_info == trans)
linux-4.15.18+/fs/btrfs/transaction.c:1858:		current->journal_info = NULL;
linux-4.15.18+/fs/btrfs/transaction.c:1910:	if (current->journal_info == trans)
linux-4.15.18+/fs/btrfs/transaction.c:1911:		current->journal_info = NULL;
linux-4.15.18+/fs/btrfs/transaction.c:2307:	if (current->journal_info == trans)
linux-4.15.18+/fs/btrfs/transaction.c:2308:		current->journal_info = NULL;
linux-4.15.18+/fs/btrfs/transaction.c:2330:	if (current->journal_info == trans)
linux-4.15.18+/fs/btrfs/transaction.c:2331:		current->journal_info = NULL;
linux-4.15.18+/fs/btrfs/disk-io.c:356:	bool need_lock = (current->journal_info == BTRFS_SEND_TRANS_STUB);
linux-4.15.18+/fs/btrfs/disk-io.c:3871:	if (current->flags & PF_MEMALLOC)
linux-4.15.18+/fs/btrfs/inode.c:7820:	if (current->journal_info) {
linux-4.15.18+/fs/btrfs/inode.c:7826:		dio_data = current->journal_info;
linux-4.15.18+/fs/btrfs/inode.c:7827:		current->journal_info = NULL;
linux-4.15.18+/fs/btrfs/inode.c:7963:		current->journal_info = dio_data;
linux-4.15.18+/fs/btrfs/inode.c:7988:		current->journal_info = dio_data;
linux-4.15.18+/fs/btrfs/inode.c:8695:		struct btrfs_dio_data *dio_data = current->journal_info;
linux-4.15.18+/fs/btrfs/inode.c:8837:		 * originally calculated.  Abuse current->journal_info for this.
linux-4.15.18+/fs/btrfs/inode.c:8843:		current->journal_info = &dio_data;
linux-4.15.18+/fs/btrfs/inode.c:8858:		current->journal_info = NULL;
linux-4.15.18+/fs/btrfs/inode.c:8918:	if (current->flags & PF_MEMALLOC) {
linux-4.15.18+/fs/hugetlbfs/inode.c:198:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/hugetlbfs/inode.c:439:			hash = hugetlb_fault_mutex_hash(h, current->mm,
linux-4.15.18+/fs/hugetlbfs/inode.c:560:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/hugetlbfs/inode.c:1328:				current->comm, current->pid);
linux-4.15.18+/fs/nfs/file.c:630:		current->backing_dev_info = inode_to_bdi(inode);
linux-4.15.18+/fs/nfs/file.c:632:		current->backing_dev_info = NULL;
linux-4.15.18+/fs/nfs/super.c:931:		data->net		= current->nsproxy->net_ns;
linux-4.15.18+/fs/nfs/super.c:2287:	data->net = current->nsproxy->net_ns;
linux-4.15.18+/fs/nfs/nfs3proc.c:321:		data->arg.create.verifier[1] = cpu_to_be32(current->pid);
linux-4.15.18+/fs/btrfs/extent-tree.c:4266:		ASSERT(current->journal_info);
linux-4.15.18+/fs/btrfs/extent-tree.c:4789:		if (!current->journal_info)
linux-4.15.18+/fs/btrfs/extent-tree.c:4829:	trans = (struct btrfs_trans_handle *)current->journal_info;
linux-4.15.18+/fs/btrfs/extent-tree.c:4914:	trans = (struct btrfs_trans_handle *)current->journal_info;
linux-4.15.18+/fs/btrfs/extent-tree.c:5258:	ASSERT(!current->journal_info || flush != BTRFS_RESERVE_FLUSH_ALL);
linux-4.15.18+/fs/btrfs/extent-tree.c:6065:	} else if (current->journal_info) {
linux-4.15.18+/fs/btrfs/extent-tree.c:7884:			trans = current->journal_info;
linux-4.15.18+/fs/nfs/nfs4state.c:814: * owner (current->files) and the second refers to a flock/OFD
linux-4.15.18+/fs/nfs/nfs4proc.c:2945:			[1] = (__u32)current->pid,
linux-4.15.18+/fs/nfs/blocklayout/blocklayout.c:126:	if (!bio && (current->flags & PF_MEMALLOC)) {
linux-4.15.18+/fs/nfs/inode.c:787:	l_ctx->lockowner = current->files;
linux-4.15.18+/fs/nfs/inode.c:798:		if (pos->lockowner != current->files)
linux-4.15.18+/fs/nfs/write.c:1213:			do_flush |= l_ctx->lockowner != current->files;
linux-4.15.18+/fs/aio.c:305:		pr_debug("pid(%d) [%d] page->count=%d\n", current->pid, i,
linux-4.15.18+/fs/aio.c:456:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/aio.c:499:			 current->pid, i, page_count(page));
linux-4.15.18+/fs/aio.c:727:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/aio.c:1074:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/aio.c:1382:			kill_ioctx(current->mm, ioctx, NULL);
linux-4.15.18+/fs/aio.c:1414:			kill_ioctx(current->mm, ioctx, NULL);
linux-4.15.18+/fs/aio.c:1443:		ret = kill_ioctx(current->mm, ioctx, &wait);
linux-4.15.18+/fs/eventpoll.c:2210:		sigsaved = current->blocked;
linux-4.15.18+/fs/eventpoll.c:2224:			memcpy(&current->saved_sigmask, &sigsaved,
linux-4.15.18+/fs/eventpoll.c:2253:		sigsaved = current->blocked;
linux-4.15.18+/fs/eventpoll.c:2267:			memcpy(&current->saved_sigmask, &sigsaved,
linux-4.15.18+/fs/ext4/mballoc.c:3081:		current->pid, ac->ac_g_ex.fe_len);
linux-4.15.18+/fs/ext4/super.c:455:		       sb->s_id, function, line, current->comm, &vaf);
linux-4.15.18+/fs/ext4/super.c:483:			       block, current->comm, &vaf);
linux-4.15.18+/fs/ext4/super.c:488:			       current->comm, &vaf);
linux-4.15.18+/fs/ext4/super.c:522:			       block, current->comm, path, &vaf);
linux-4.15.18+/fs/ext4/super.c:528:			       current->comm, path, &vaf);
linux-4.15.18+/fs/ext4/super.c:702:	       function, line, inode->i_ino, current->comm, &vaf);
linux-4.15.18+/fs/ext4/namei.c:106:			       current->comm, PTR_ERR(bh));
linux-4.15.18+/fs/ext4/ext4_jbd2.c:13:	handle_t *handle = current->journal_info;
linux-4.15.18+/fs/ext4/ext4_jbd2.c:21:	current->journal_info = handle;
linux-4.15.18+/fs/ext4/ext4_jbd2.c:36:	current->journal_info = handle;
linux-4.15.18+/fs/ext4/dir.c:509:			 inode->i_ino, current->comm);
linux-4.15.18+/fs/ext4/inode.c:2146:		if ((current->flags & PF_MEMALLOC) ||
linux-4.15.18+/fs/ext4/inode.c:2153:			WARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD))
linux-4.15.18+/fs/ext4/inode.c:5267:	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC))
linux-4.15.18+/fs/ext4/balloc.c:887:		colour = (current->pid % 16) *
linux-4.15.18+/fs/ext4/balloc.c:890:		colour = (current->pid % 16) * ((last_block - bg_start) / 16);
linux-4.15.18+/fs/signalfd.c:66:	poll_wait(file, &current->sighand->signalfd_wqh, wait);
linux-4.15.18+/fs/signalfd.c:68:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:69:	if (next_signal(&current->pending, &ctx->sigmask) ||
linux-4.15.18+/fs/signalfd.c:70:	    next_signal(&current->signal->shared_pending,
linux-4.15.18+/fs/signalfd.c:73:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:160:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:168:		spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:172:	add_wait_queue(&current->sighand->signalfd_wqh, &wait);
linux-4.15.18+/fs/signalfd.c:182:		spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:184:		spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:186:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:188:	remove_wait_queue(&current->sighand->signalfd_wqh, &wait);
linux-4.15.18+/fs/signalfd.c:293:		spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:295:		spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/signalfd.c:297:		wake_up(&current->sighand->signalfd_wqh);
linux-4.15.18+/fs/proc/inode.c:309:			get_area = current->mm->get_unmapped_area;
linux-4.15.18+/fs/proc/task_nommu.c:57:	if (current->fs && current->fs->users > 1)
linux-4.15.18+/fs/proc/task_nommu.c:58:		sbytes += kobjsize(current->fs);
linux-4.15.18+/fs/proc/task_nommu.c:60:		bytes += kobjsize(current->fs);
linux-4.15.18+/fs/proc/task_nommu.c:62:	if (current->files && atomic_read(&current->files->count) > 1)
linux-4.15.18+/fs/proc/task_nommu.c:63:		sbytes += kobjsize(current->files);
linux-4.15.18+/fs/proc/task_nommu.c:65:		bytes += kobjsize(current->files);
linux-4.15.18+/fs/proc/task_nommu.c:67:	if (current->sighand && atomic_read(&current->sighand->count) > 1)
linux-4.15.18+/fs/proc/task_nommu.c:68:		sbytes += kobjsize(current->sighand);
linux-4.15.18+/fs/proc/task_nommu.c:70:		bytes += kobjsize(current->sighand);
linux-4.15.18+/fs/proc/base.c:1048:			  current->comm, task_pid_nr(current), task_pid_nr(task),
linux-4.15.18+/fs/proc/base.c:2541:	length = mutex_lock_interruptible(&current->signal->cred_guard_mutex);
linux-4.15.18+/fs/proc/base.c:2547:	mutex_unlock(&current->signal->cred_guard_mutex);
linux-4.15.18+/fs/ntfs/file.c:1948:	current->backing_dev_info = inode_to_bdi(vi);
linux-4.15.18+/fs/ntfs/file.c:1952:	current->backing_dev_info = NULL;
linux-4.15.18+/fs/overlayfs/copy_up.c:40:				    f, fd, current->pid, current->comm);
linux-4.15.18+/fs/overlayfs/copy_up.c:54:		iterate_fd(current->files, 0, ovl_check_fd, dentry);
linux-4.15.18+/fs/ubifs/debug.c:573:	       current->pid, lst->empty_lebs, lst->idx_lebs);
linux-4.15.18+/fs/ubifs/debug.c:592:	       current->pid, bi->data_growth + bi->dd_growth,
linux-4.15.18+/fs/ubifs/debug.c:746:	pr_err("(pid %d) start dumping LEB properties\n", current->pid);
linux-4.15.18+/fs/ubifs/debug.c:759:	pr_err("(pid %d) finish dumping LEB properties\n", current->pid);
linux-4.15.18+/fs/ubifs/debug.c:767:	pr_err("(pid %d) dumping LPT information\n", current->pid);
linux-4.15.18+/fs/ubifs/debug.c:806:	       current->pid, sleb->lnum, offs);
linux-4.15.18+/fs/ubifs/debug.c:822:	pr_err("(pid %d) start dumping LEB %d\n", current->pid, lnum);
linux-4.15.18+/fs/ubifs/debug.c:846:	pr_err("(pid %d) finish dumping LEB %d\n", current->pid, lnum);
linux-4.15.18+/fs/ubifs/debug.c:898:	       current->pid, cat, heap->cnt);
linux-4.15.18+/fs/ubifs/debug.c:906:	pr_err("(pid %d) finish dumping heap\n", current->pid);
linux-4.15.18+/fs/ubifs/debug.c:914:	pr_err("(pid %d) dumping pnode:\n", current->pid);
linux-4.15.18+/fs/ubifs/debug.c:933:	pr_err("(pid %d) start dumping TNC tree\n", current->pid);
linux-4.15.18+/fs/ubifs/debug.c:945:	pr_err("(pid %d) finish dumping TNC tree\n", current->pid);
linux-4.15.18+/fs/ubifs/debug.c:3071:	       current->pid, fname, err);
linux-4.15.18+/fs/namei.c:532:	struct nameidata *old = current->nameidata;
linux-4.15.18+/fs/namei.c:538:	current->nameidata = p;
linux-4.15.18+/fs/namei.c:543:	struct nameidata *now = current->nameidata, *old = now->saved;
linux-4.15.18+/fs/namei.c:545:	current->nameidata = old;
linux-4.15.18+/fs/namei.c:829:	struct fs_struct *fs = current->fs;
linux-4.15.18+/fs/namei.c:889:	struct nameidata *nd = current->nameidata;
linux-4.15.18+/fs/namei.c:2186:			struct fs_struct *fs = current->fs;
linux-4.15.18+/fs/namei.c:2198:			get_fs_pwd(current->fs, &nd->path);
linux-4.15.18+/fs/autofs4/autofs_i.h:41:#define pr_fmt(fmt) KBUILD_MODNAME ":pid:%d:%s: " fmt, current->pid, __func__
linux-4.15.18+/fs/autofs4/root.c:519:		 current->pid, task_pgrp_nr(current), sbi->catatonic,
linux-4.15.18+/fs/exec.c:13: * "current->executable", and page faults do the actual loading. Clean.
linux-4.15.18+/fs/exec.c:19: * current->executable is only used by the procfs.  This allows a dispatch
linux-4.15.18+/fs/exec.c:178: * use a lot of memory, account these pages in current->mm temporary
linux-4.15.18+/fs/exec.c:184:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/exec.c:689:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/exec.c:785:	current->mm->start_stack = bprm->p;
linux-4.15.18+/fs/exec.c:1009:	old_mm = current->mm;
linux-4.15.18+/fs/exec.c:1284:	current->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |
linux-4.15.18+/fs/exec.c:1287:	current->personality &= ~bprm->per_clear;
linux-4.15.18+/fs/exec.c:1295:	do_close_on_exec(current->files);
linux-4.15.18+/fs/exec.c:1335:		current->pdeath_signal = 0;
linux-4.15.18+/fs/exec.c:1344:		if (current->signal->rlim[RLIMIT_STACK].rlim_cur > _STK_LIM)
linux-4.15.18+/fs/exec.c:1345:			current->signal->rlim[RLIMIT_STACK].rlim_cur = _STK_LIM;
linux-4.15.18+/fs/exec.c:1348:	arch_pick_mmap_layout(current->mm);
linux-4.15.18+/fs/exec.c:1350:	current->sas_ss_sp = current->sas_ss_size = 0;
linux-4.15.18+/fs/exec.c:1360:		set_dumpable(current->mm, suid_dumpable);
linux-4.15.18+/fs/exec.c:1362:		set_dumpable(current->mm, SUID_DUMP_USER);
linux-4.15.18+/fs/exec.c:1372:	current->mm->task_size = TASK_SIZE;
linux-4.15.18+/fs/exec.c:1376:	current->self_exec_id++;
linux-4.15.18+/fs/exec.c:1389:	if (mutex_lock_interruptible(&current->signal->cred_guard_mutex))
linux-4.15.18+/fs/exec.c:1396:	mutex_unlock(&current->signal->cred_guard_mutex);
linux-4.15.18+/fs/exec.c:1404:		mutex_unlock(&current->signal->cred_guard_mutex);
linux-4.15.18+/fs/exec.c:1445:	if (get_dumpable(current->mm) != SUID_DUMP_USER)
linux-4.15.18+/fs/exec.c:1453:	mutex_unlock(&current->signal->cred_guard_mutex);
linux-4.15.18+/fs/exec.c:1675:	old_pid = current->pid;
linux-4.15.18+/fs/exec.c:1677:	old_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));
linux-4.15.18+/fs/exec.c:1714:	if ((current->flags & PF_NPROC_EXCEEDED) &&
linux-4.15.18+/fs/exec.c:1722:	current->flags &= ~PF_NPROC_EXCEEDED;
linux-4.15.18+/fs/exec.c:1738:	current->in_execve = 1;
linux-4.15.18+/fs/exec.c:1763:		 * current->files (due to unshare_files above).
linux-4.15.18+/fs/exec.c:1765:		if (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))
linux-4.15.18+/fs/exec.c:1807:	current->fs->in_exec = 0;
linux-4.15.18+/fs/exec.c:1808:	current->in_execve = 0;
linux-4.15.18+/fs/exec.c:1826:	current->fs->in_exec = 0;
linux-4.15.18+/fs/exec.c:1827:	current->in_execve = 0;
linux-4.15.18+/fs/exec.c:1896:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/namespace.c:749:	struct mnt_namespace *ns = current->nsproxy->mnt_ns;
linux-4.15.18+/fs/namespace.c:846:	return mnt->mnt_ns == current->nsproxy->mnt_ns;
linux-4.15.18+/fs/namespace.c:1545:		if (&mnt->mnt == current->fs->root.mnt ||
linux-4.15.18+/fs/namespace.c:1587:	if (&mnt->mnt == current->fs->root.mnt && !(flags & MNT_DETACH)) {
linux-4.15.18+/fs/namespace.c:1664:	return ns_capable(current->nsproxy->mnt_ns->user_ns, CAP_SYS_ADMIN);
linux-4.15.18+/fs/namespace.c:1757:	return current->nsproxy->mnt_ns->seq >= mnt_ns->seq;
linux-4.15.18+/fs/namespace.c:3142:	get_fs_root(current->fs, &root);
linux-4.15.18+/fs/namespace.c:3194:	touch_mnt_namespace(current->nsproxy->mnt_ns);
linux-4.15.18+/fs/namespace.c:3243:	set_fs_pwd(current->fs, &root);
linux-4.15.18+/fs/namespace.c:3244:	set_fs_root(current->fs, &root);
linux-4.15.18+/fs/namespace.c:3328:	ns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;
linux-4.15.18+/fs/namespace.c:3334:	get_fs_root(current->fs, &fs_root);
linux-4.15.18+/fs/namespace.c:3410:	struct mnt_namespace *ns = current->nsproxy->mnt_ns;
linux-4.15.18+/fs/namespace.c:3466:	struct fs_struct *fs = current->fs;
linux-4.15.18+/fs/reiserfs/journal.c:3154:		th = current->journal_info;
linux-4.15.18+/fs/reiserfs/journal.c:3191:	struct reiserfs_transaction_handle *cur_th = current->journal_info;
linux-4.15.18+/fs/reiserfs/journal.c:3195:	 * current->journal_info pointer
linux-4.15.18+/fs/reiserfs/journal.c:3205:	struct reiserfs_transaction_handle *cur_th = current->journal_info;
linux-4.15.18+/fs/reiserfs/journal.c:3209:	 * current->journal_info pointer
linux-4.15.18+/fs/reiserfs/journal.c:3219:	struct reiserfs_transaction_handle *cur_th = current->journal_info;
linux-4.15.18+/fs/reiserfs/journal.c:3242:			th->t_handle_save = current->journal_info;
linux-4.15.18+/fs/reiserfs/journal.c:3243:			current->journal_info = th;
linux-4.15.18+/fs/reiserfs/journal.c:3246:		current->journal_info = th;
linux-4.15.18+/fs/reiserfs/journal.c:3249:	BUG_ON(current->journal_info != th);
linux-4.15.18+/fs/reiserfs/journal.c:3256:		current->journal_info = th->t_handle_save;
linux-4.15.18+/fs/reiserfs/journal.c:3383:	if (!current->journal_info && th->t_refcount > 1)
linux-4.15.18+/fs/reiserfs/journal.c:3395:		    current->journal_info;
linux-4.15.18+/fs/reiserfs/journal.c:3404:			memcpy(current->journal_info, th, sizeof(*th));
linux-4.15.18+/fs/reiserfs/journal.c:4014:	current->journal_info = th->t_handle_save;
linux-4.15.18+/fs/reiserfs/journal.c:4061:	current->journal_info = th;
linux-4.15.18+/fs/reiserfs/journal.c:4068:	current->journal_info = th->t_handle_save;
linux-4.15.18+/fs/fuse/file.c:1190:	current->backing_dev_info = inode_to_bdi(inode);
linux-4.15.18+/fs/fuse/file.c:1236:	current->backing_dev_info = NULL;
linux-4.15.18+/fs/fuse/file.c:1361:		fl_owner_t owner = current->files;
linux-4.15.18+/fs/fuse/dir.c:1658:		inarg.lock_owner = fuse_lock_owner_id(fc, current->files);
linux-4.15.18+/fs/ubifs/super.c:2122:			       current->pid, name, (int)PTR_ERR(ubi));
linux-4.15.18+/fs/ubifs/super.c:2256:		       current->pid, (unsigned int)PAGE_SIZE);
linux-4.15.18+/fs/ubifs/super.c:2282:		       current->pid, err);
linux-4.15.18+/fs/ubifs/compress.c:197:			       current->pid, compr->name, PTR_ERR(compr->cc));
linux-4.15.18+/fs/ubifs/misc.c:34:	       c->vi.ubi_num, c->vi.vol_id, current->pid,
linux-4.15.18+/fs/ubifs/misc.c:53:		c->vi.ubi_num, c->vi.vol_id, current->pid,
linux-4.15.18+/fs/ubifs/lpt_commit.c:1885:	pr_err("(pid %d) start dumping LEB %d\n", current->pid, lnum);
linux-4.15.18+/fs/ubifs/lpt_commit.c:1971:	pr_err("(pid %d) finish dumping LEB %d\n", current->pid, lnum);
linux-4.15.18+/fs/ubifs/lpt_commit.c:1988:	pr_err("(pid %d) start dumping all LPT LEBs\n", current->pid);
linux-4.15.18+/fs/ubifs/lpt_commit.c:1991:	pr_err("(pid %d) finish dumping all LPT LEBs\n", current->pid);
linux-4.15.18+/fs/ubifs/debug.h:154:		       __func__, __LINE__, current->pid);                      \
linux-4.15.18+/fs/ubifs/debug.h:168:	pr_debug("UBIFS DBG " type " (pid %d): " fmt "\n", current->pid,       \
linux-4.15.18+/fs/ubifs/debug.h:174:	pr_debug("UBIFS DBG " type " (pid %d): " fmt "%s\n", current->pid,     \
linux-4.15.18+/fs/ubifs/commit.c:293:		  c->bgt_name, current->pid);
linux-4.15.18+/fs/ubifs/commit.c:389:	dbg_cmt("pid %d goes sleep", current->pid);
linux-4.15.18+/fs/ubifs/commit.c:400:	dbg_cmt("commit finished, pid %d woke up", current->pid);
linux-4.15.18+/fs/autofs4/waitq.c:62:	sigpipe = sigismember(&current->pending.signal, SIGPIPE);
linux-4.15.18+/fs/autofs4/waitq.c:78:		spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/fs/autofs4/waitq.c:79:		sigdelset(&current->pending.signal, SIGPIPE);
linux-4.15.18+/fs/autofs4/waitq.c:81:		spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/fs/autofs4/waitq.c:495:		spin_lock_irqsave(&current->sighand->siglock, irqflags);
linux-4.15.18+/fs/autofs4/waitq.c:496:		oldset = current->blocked;
linux-4.15.18+/fs/autofs4/waitq.c:498:		siginitsetinv(&current->blocked, shutdown_sigs_mask);
linux-4.15.18+/fs/autofs4/waitq.c:500:		spin_unlock_irqrestore(&current->sighand->siglock, irqflags);
linux-4.15.18+/fs/autofs4/waitq.c:504:		spin_lock_irqsave(&current->sighand->siglock, irqflags);
linux-4.15.18+/fs/autofs4/waitq.c:505:		current->blocked = oldset;
linux-4.15.18+/fs/autofs4/waitq.c:507:		spin_unlock_irqrestore(&current->sighand->siglock, irqflags);
linux-4.15.18+/fs/cachefiles/internal.h:282:	printk(KERN_DEBUG "[%-6.6s] "FMT"\n", current->comm, ##__VA_ARGS__)
linux-4.15.18+/fs/cachefiles/daemon.c:576:	get_fs_pwd(current->fs, &path);
linux-4.15.18+/fs/cachefiles/daemon.c:648:	get_fs_pwd(current->fs, &path);
linux-4.15.18+/fs/coredump.c:161:	exe_file = get_mm_exe_file(current->mm);
linux-4.15.18+/fs/coredump.c:163:		return cn_esc_printf(cn, "%s (path unknown)", current->comm);
linux-4.15.18+/fs/coredump.c:278:				err = cn_esc_printf(cn, "%s", current->comm);
linux-4.15.18+/fs/coredump.c:373:	 *	It does list_replace_rcu(&leader->tasks, &current->tasks),
linux-4.15.18+/fs/coredump.c:453:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/coredump.c:455:		current->signal->group_exit_code |= 0x80;
linux-4.15.18+/fs/coredump.c:456:	current->signal->group_exit_task = NULL;
linux-4.15.18+/fs/coredump.c:457:	current->signal->flags = SIGNAL_GROUP_EXIT;
linux-4.15.18+/fs/coredump.c:458:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/coredump.c:534:	current->signal->rlim[RLIMIT_CORE] = (struct rlimit){1, 1};
linux-4.15.18+/fs/coredump.c:543:	struct mm_struct *mm = current->mm;
linux-4.15.18+/fs/coredump.c:626:				task_tgid_vnr(current), current->comm);
linux-4.15.18+/fs/coredump.c:635:			       task_tgid_vnr(current), current->comm);
linux-4.15.18+/fs/coredump.c:672:				task_tgid_vnr(current), current->comm);
linux-4.15.18+/fs/coredump.c:701:			 * their current->fs->root to point to arbitrary
linux-4.15.18+/fs/coredump.c:705:			 * current->fs->root must not be used. Instead, use the
linux-4.15.18+/fs/reiserfs/super.c:2550:	if (!current->journal_info) {
linux-4.15.18+/fs/reiserfs/super.c:2579:		journal_mark_dirty(current->journal_info, bh);
linux-4.15.18+/fs/reiserfs/inode.c:1788:	if (wbc->sync_mode == WB_SYNC_ALL && !(current->flags & PF_MEMALLOC)) {
linux-4.15.18+/fs/reiserfs/inode.c:2536:	if (checked && (current->flags & PF_MEMALLOC)) {
linux-4.15.18+/fs/reiserfs/inode.c:2781:		th = (struct reiserfs_transaction_handle *)current->
linux-4.15.18+/fs/reiserfs/inode.c:2790:		struct reiserfs_transaction_handle *th = current->journal_info;
linux-4.15.18+/fs/reiserfs/inode.c:2840:		th = (struct reiserfs_transaction_handle *)current->
linux-4.15.18+/fs/reiserfs/inode.c:2850:		struct reiserfs_transaction_handle *th = current->journal_info;
linux-4.15.18+/fs/reiserfs/inode.c:2902:		th = current->journal_info;
linux-4.15.18+/fs/reiserfs/inode.c:3004:		th = current->journal_info;
linux-4.15.18+/fs/stat.c:215:			current->comm);
linux-4.15.18+/fs/reiserfs/stree.c:633:					 current->comm, repeat_counter,
linux-4.15.18+/fs/reiserfs/reiserfs.h:2860:	void *t_handle_save;	/* save existing current->journal_info */
linux-4.15.18+/fs/reiserfs/reiserfs.h:2897:	struct reiserfs_transaction_handle *th = current->journal_info;
linux-4.15.18+/fs/dcache.c:3309:	get_fs_root_rcu(current->fs, &root);
linux-4.15.18+/fs/dcache.c:3465:	get_fs_root_and_pwd_rcu(current->fs, &root, &pwd);
linux-4.15.18+/fs/inode.c:746:			if (current->reclaim_state)
linux-4.15.18+/fs/inode.c:747:				current->reclaim_state->reclaimed_slab += reap;
linux-4.15.18+/fs/binfmt_aout.c:43: * changed due to the set[u|g]id. It's enforced by the "current->mm->dumpable"
linux-4.15.18+/fs/binfmt_aout.c:65:       	strncpy(dump.u_comm, current->comm, sizeof(dump.u_comm));
linux-4.15.18+/fs/binfmt_aout.c:172:	current->mm->arg_start = (unsigned long) p;
linux-4.15.18+/fs/binfmt_aout.c:181:	current->mm->arg_end = current->mm->env_start = (unsigned long) p;
linux-4.15.18+/fs/binfmt_aout.c:190:	current->mm->env_end = (unsigned long) p;
linux-4.15.18+/fs/binfmt_aout.c:248:	current->mm->end_code = ex.a_text +
linux-4.15.18+/fs/binfmt_aout.c:249:		(current->mm->start_code = N_TXTADDR(ex));
linux-4.15.18+/fs/binfmt_aout.c:250:	current->mm->end_data = ex.a_data +
linux-4.15.18+/fs/binfmt_aout.c:251:		(current->mm->start_data = N_DATADDR(ex));
linux-4.15.18+/fs/binfmt_aout.c:252:	current->mm->brk = ex.a_bss +
linux-4.15.18+/fs/binfmt_aout.c:253:		(current->mm->start_brk = N_BSSADDR(ex));
linux-4.15.18+/fs/binfmt_aout.c:324:	retval = set_brk(current->mm->start_brk, current->mm->brk);
linux-4.15.18+/fs/binfmt_aout.c:328:	current->mm->start_stack =
linux-4.15.18+/fs/binfmt_aout.c:333:	start_thread(regs, ex.a_entry, current->mm->start_stack);
linux-4.15.18+/fs/locks.c:442:	fl->fl_pid = current->tgid;
linux-4.15.18+/fs/locks.c:501:	fl->fl_owner = current->files;
linux-4.15.18+/fs/locks.c:502:	fl->fl_pid = current->tgid;
linux-4.15.18+/fs/locks.c:567:	fl->fl_pid = current->tgid;
linux-4.15.18+/fs/locks.c:1283:		if (fl->fl_owner != current->files &&
linux-4.15.18+/fs/locks.c:1311:	fl.fl_pid = current->tgid;
linux-4.15.18+/fs/locks.c:1331:		fl.fl_owner = current->files;
linux-4.15.18+/fs/locks.c:2315:		spin_lock(&current->files->file_lock);
linux-4.15.18+/fs/locks.c:2317:		spin_unlock(&current->files->file_lock);
linux-4.15.18+/fs/locks.c:2446:		spin_lock(&current->files->file_lock);
linux-4.15.18+/fs/locks.c:2448:		spin_unlock(&current->files->file_lock);
linux-4.15.18+/fs/locks.c:2488:	lock.fl_pid = current->tgid;
linux-4.15.18+/fs/locks.c:2508:		.fl_pid = current->tgid,
linux-4.15.18+/fs/mpage.c:81:	if (bio == NULL && (current->flags & PF_MEMALLOC)) {
linux-4.15.18+/fs/orangefs/orangefs-mod.c:227:				     current->comm);
linux-4.15.18+/fs/orangefs/waitqueue.c:46:			     current->comm);
linux-4.15.18+/fs/orangefs/waitqueue.c:70:	op->upcall.tgid = current->tgid;
linux-4.15.18+/fs/orangefs/waitqueue.c:71:	op->upcall.pid = current->pid;
linux-4.15.18+/fs/orangefs/waitqueue.c:80:		     current->comm,
linux-4.15.18+/fs/orangefs/waitqueue.c:81:		     current->pid);
linux-4.15.18+/fs/orangefs/waitqueue.c:116:		     current->comm);
linux-4.15.18+/fs/orangefs/waitqueue.c:233:		     current->comm);
linux-4.15.18+/fs/orangefs/devorangefs-req.c:314:		     current->comm);
linux-4.15.18+/fs/orangefs/devorangefs-req.c:337:			     current->comm);
linux-4.15.18+/fs/orangefs/devorangefs-req.c:497:			     current->comm);
linux-4.15.18+/fs/fs_struct.c:134:	struct fs_struct *fs = current->fs;
linux-4.15.18+/fs/fs_struct.c:144:	current->fs = new_fs;
linux-4.15.18+/fs/fs_struct.c:157:	return current->fs->umask;
linux-4.15.18+/fs/coda/upcall.c:577:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/coda/upcall.c:578:	*old = current->blocked;
linux-4.15.18+/fs/coda/upcall.c:580:	sigfillset(&current->blocked);
linux-4.15.18+/fs/coda/upcall.c:581:	sigdelset(&current->blocked, SIGKILL);
linux-4.15.18+/fs/coda/upcall.c:582:	sigdelset(&current->blocked, SIGSTOP);
linux-4.15.18+/fs/coda/upcall.c:583:	sigdelset(&current->blocked, SIGINT);
linux-4.15.18+/fs/coda/upcall.c:586:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/coda/upcall.c:591:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/coda/upcall.c:592:	current->blocked = *old;
linux-4.15.18+/fs/coda/upcall.c:594:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/fs/lockd/procfs.c:25:	struct lockd_net *ln = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/lockd/procfs.c:52:	struct lockd_net *ln = net_generic(current->nsproxy->net_ns,
linux-4.15.18+/fs/lockd/xdr4.c:121:	fl->fl_owner = current->files;
linux-4.15.18+/fs/lockd/xdr.c:129:	fl->fl_owner = current->files;
linux-4.15.18+/fs/afs/super.c:444:	if (current->nsproxy->net_ns != &init_net)
linux-4.15.18+/fs/afs/internal.h:997:	printk("[%-6.6s] "FMT"\n", current->comm ,##__VA_ARGS__)
linux-4.15.18+/fs/fhandle.c:121:		struct fs_struct *fs = current->fs;
linux-4.15.18+/fs/dlm/user.c:469:		       current->comm,
linux-4.15.18+/fs/fscache/internal.h:350:	printk(KERN_DEBUG "[%-6.6s] "FMT"\n", current->comm, ##__VA_ARGS__)
linux-4.15.18+/fs/devpts/inode.c:242:			(current->nsproxy->mnt_ns == init_task.nsproxy->mnt_ns);
linux-4.15.18+/fs/dlm/lock.c:2919:	lkb->lkb_ownpid = (int) current->pid;
linux-4.15.18+/fs/dlm/lock.c:5935:	lkb->lkb_ownpid = (int) current->pid;
linux-4.15.18+/fs/dlm/lock.c:6296:		if (pid == current->pid)
linux-4.15.18+/fs/userfaultfd.c:358:	if (current->flags & (PF_EXITING|PF_DUMPCORE))
linux-4.15.18+/fs/userfaultfd.c:575:	if (WARN_ON_ONCE(current->flags & PF_EXITING))
linux-4.15.18+/fs/userfaultfd.c:1906:	BUG_ON(!current->mm);
linux-4.15.18+/fs/userfaultfd.c:1926:	ctx->mm = current->mm;
linux-4.15.18+/fs/gfs2/super.c:809:	if (current->journal_info == NULL) {
linux-4.15.18+/fs/gfs2/super.c:1329:	    unlikely(current->flags & PF_MEMALLOC) &&
linux-4.15.18+/fs/gfs2/super.c:1532:	if (current->flags & PF_MEMALLOC)
linux-4.15.18+/fs/gfs2/super.c:1583:	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC))
linux-4.15.18+/fs/gfs2/trans.c:37:	BUG_ON(current->journal_info);
linux-4.15.18+/fs/gfs2/trans.c:66:	current->journal_info = tr;
linux-4.15.18+/fs/gfs2/trans.c:91:	struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/gfs2/trans.c:96:	current->journal_info = NULL;
linux-4.15.18+/fs/gfs2/trans.c:161:	struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/gfs2/trans.c:209:	struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/gfs2/trans.c:260:	struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/gfs2/trans.c:271:	struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/gfs2/meta_io.c:294:		struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/gfs2/meta_io.c:321:		struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/gfs2/meta_io.c:337:	struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/fs-writeback.c:1937:	current->flags |= PF_SWAPWRITE;
linux-4.15.18+/fs/fs-writeback.c:1967:	current->flags &= ~PF_SWAPWRITE;
linux-4.15.18+/fs/fs-writeback.c:2078:		       current->comm, task_pid_nr(current), inode->i_ino,
linux-4.15.18+/fs/gfs2/glops.c:104:	WARN_ON_ONCE(current->journal_info);
linux-4.15.18+/fs/gfs2/glops.c:105:	current->journal_info = &tr;
linux-4.15.18+/fs/gfs2/inode.c:1843:	if (current->journal_info)
linux-4.15.18+/fs/gfs2/bmap.c:1142:		if (current->journal_info == NULL) {
linux-4.15.18+/fs/gfs2/bmap.c:1164:		tr = current->journal_info;
linux-4.15.18+/fs/gfs2/bmap.c:1212:		if (current->journal_info) {
linux-4.15.18+/fs/gfs2/bmap.c:1444:		if (current->journal_info == NULL) {
linux-4.15.18+/fs/gfs2/bmap.c:1464:	if (current->journal_info) {
linux-4.15.18+/fs/gfs2/lops.c:45:	BUG_ON(!current->journal_info);
linux-4.15.18+/fs/ext2/inode.c:316:	colour = (current->pid % 16) *
linux-4.15.18+/fs/jbd2/journal.c:564:	if (journal->j_running_transaction && !current->journal_info) {
linux-4.15.18+/fs/jbd2/journal.c:614:	J_ASSERT(!current->journal_info);
linux-4.15.18+/fs/jbd2/transaction.c:296:		       current->comm, blocks, rsv_blocks,
linux-4.15.18+/fs/jbd2/transaction.c:388:	current->journal_info = handle;
linux-4.15.18+/fs/jbd2/transaction.c:526:	if (WARN_ON(current->journal_info)) {
linux-4.15.18+/fs/jbd2/transaction.c:676:	current->journal_info = NULL;
linux-4.15.18+/fs/jbd2/transaction.c:1698:	pid = current->pid;
linux-4.15.18+/fs/jbd2/transaction.c:1727:	current->journal_info = NULL;
linux-4.15.18+/fs/jbd2/transaction.c:1754:		if (handle->h_sync && !(current->flags & PF_MEMALLOC))
linux-4.15.18+/fs/binfmt_elf_fdpic.c:204:	kdebug("____ LOAD %d ____", current->pid);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:357:		current->personality |= READ_IMPLIES_EXEC;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:363:	current->mm->start_code = 0;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:364:	current->mm->end_code = 0;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:365:	current->mm->start_stack = 0;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:366:	current->mm->start_data = 0;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:367:	current->mm->end_data = 0;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:368:	current->mm->context.exec_fdpic_loadmap = 0;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:369:	current->mm->context.interp_fdpic_loadmap = 0;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:374:				  &current->mm->start_stack,
linux-4.15.18+/fs/binfmt_elf_fdpic.c:375:				  &current->mm->start_brk);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:377:	retval = setup_arg_pages(bprm, current->mm->start_stack,
linux-4.15.18+/fs/binfmt_elf_fdpic.c:389:	retval = elf_fdpic_map_file(&exec_params, bprm->file, current->mm,
linux-4.15.18+/fs/binfmt_elf_fdpic.c:396:					    current->mm, "interpreter");
linux-4.15.18+/fs/binfmt_elf_fdpic.c:408:	if (!current->mm->start_brk)
linux-4.15.18+/fs/binfmt_elf_fdpic.c:409:		current->mm->start_brk = current->mm->end_data;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:411:	current->mm->brk = current->mm->start_brk =
linux-4.15.18+/fs/binfmt_elf_fdpic.c:412:		PAGE_ALIGN(current->mm->start_brk);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:425:	current->mm->start_brk = vm_mmap(NULL, 0, stack_size, stack_prot,
linux-4.15.18+/fs/binfmt_elf_fdpic.c:430:	if (IS_ERR_VALUE(current->mm->start_brk)) {
linux-4.15.18+/fs/binfmt_elf_fdpic.c:431:		retval = current->mm->start_brk;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:432:		current->mm->start_brk = 0;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:436:	current->mm->brk = current->mm->start_brk;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:437:	current->mm->context.end_brk = current->mm->start_brk;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:438:	current->mm->start_stack = current->mm->start_brk + stack_size;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:442:	if (create_elf_fdpic_tables(bprm, current->mm,
linux-4.15.18+/fs/binfmt_elf_fdpic.c:446:	kdebug("- start_code  %lx", current->mm->start_code);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:447:	kdebug("- end_code    %lx", current->mm->end_code);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:448:	kdebug("- start_data  %lx", current->mm->start_data);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:449:	kdebug("- end_data    %lx", current->mm->end_data);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:450:	kdebug("- start_brk   %lx", current->mm->start_brk);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:451:	kdebug("- brk         %lx", current->mm->brk);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:452:	kdebug("- start_stack %lx", current->mm->start_stack);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:468:	start_thread(regs, entryaddr, current->mm->start_stack);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:573:	current->mm->context.exec_fdpic_loadmap = (unsigned long) sp;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:586:		current->mm->context.interp_fdpic_loadmap = (unsigned long) sp;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:687:	current->mm->arg_start = bprm->p;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:689:	current->mm->arg_start = current->mm->start_stack -
linux-4.15.18+/fs/binfmt_elf_fdpic.c:693:	p = (char __user *) current->mm->arg_start;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:702:	current->mm->arg_end = (unsigned long) p;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:705:	current->mm->env_start = (unsigned long) p;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:714:	current->mm->env_end = (unsigned long) p;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:1500:	for (vma = current->mm->mmap; vma; vma = vma->vm_next) {
linux-4.15.18+/fs/binfmt_elf_fdpic.c:1538:	for (vma = current->mm->mmap; vma; vma = vma->vm_next)
linux-4.15.18+/fs/binfmt_elf_fdpic.c:1614:	for (ct = current->mm->core_state->dumper.next;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:1637:	segs = current->mm->map_count;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:1658:	fill_psinfo(psinfo, current->group_leader, current->mm);
linux-4.15.18+/fs/binfmt_elf_fdpic.c:1663:	auxv = (elf_addr_t *) current->mm->saved_auxv;
linux-4.15.18+/fs/binfmt_elf_fdpic.c:1729:	for (vma = current->mm->mmap; vma; vma = vma->vm_next) {
linux-4.15.18+/fs/gfs2/aops.c:109:	if (current->journal_info)
linux-4.15.18+/fs/gfs2/aops.c:215:	if (PageChecked(page) || current->journal_info)
linux-4.15.18+/fs/gfs2/aops.c:896:	struct gfs2_trans *tr = current->journal_info;
linux-4.15.18+/fs/xfs/kmem.c:42:				current->comm, current->pid,
linux-4.15.18+/fs/xfs/kmem.c:92:				current->comm, current->pid,
linux-4.15.18+/fs/xfs/kmem.c:112:				current->comm, current->pid,
linux-4.15.18+/fs/xfs/xfs_trans_ail.c:515:	current->flags |= PF_MEMALLOC;
linux-4.15.18+/fs/xfs/xfs_buf.c:51:# define XB_SET_OWNER(bp)	((bp)->b_last_holder = current->pid)
linux-4.15.18+/fs/xfs/xfs_buf.c:422:					current->comm, current->pid,
linux-4.15.18+/fs/xfs/xfs_aops.c:1072:	if (WARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD)) ==
linux-4.15.18+/fs/xfs/xfs_aops.c:1080:	if (WARN_ON_ONCE(current->flags & PF_MEMALLOC_NOFS))
linux-4.15.18+/fs/xfs/xfs_linux.h:115:#define current_pid()		(current->pid)
linux-4.15.18+/fs/xfs/xfs_linux.h:116:#define current_test_flags(f)	(current->flags & (f))
linux-4.15.18+/fs/xfs/xfs_linux.h:118:		(*(sp) = current->flags, current->flags |= (f))
linux-4.15.18+/fs/xfs/xfs_linux.h:120:		(*(sp) = current->flags, current->flags &= ~(f))
linux-4.15.18+/fs/xfs/xfs_linux.h:122:		(current->flags = ((current->flags & ~(f)) | (*(sp) & (f))))
linux-4.15.18+/fs/xfs/xfs_file.c:664:	current->backing_dev_info = inode_to_bdi(inode);
linux-4.15.18+/fs/xfs/xfs_file.c:702:	current->backing_dev_info = NULL;
linux-4.15.18+/fs/buffer.c:3334:			" system call\n", current->comm);
linux-4.15.18+/fs/binfmt_elf.c:118:	current->mm->start_brk = current->mm->brk = end;
linux-4.15.18+/fs/binfmt_elf.c:230:	elf_info = (elf_addr_t *)current->mm->saved_auxv;
linux-4.15.18+/fs/binfmt_elf.c:280:	       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);
linux-4.15.18+/fs/binfmt_elf.c:303:	vma = find_extend_vma(current->mm, bprm->p);
linux-4.15.18+/fs/binfmt_elf.c:312:	p = current->mm->arg_end = current->mm->arg_start;
linux-4.15.18+/fs/binfmt_elf.c:324:	current->mm->arg_end = p;
linux-4.15.18+/fs/binfmt_elf.c:327:	current->mm->env_end = current->mm->env_start = p;
linux-4.15.18+/fs/binfmt_elf.c:339:	current->mm->env_end = p;
linux-4.15.18+/fs/binfmt_elf.c:673:	if (current->flags & PF_RANDOMIZE) {
linux-4.15.18+/fs/binfmt_elf.c:872:		current->personality |= READ_IMPLIES_EXEC;
linux-4.15.18+/fs/binfmt_elf.c:874:	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
linux-4.15.18+/fs/binfmt_elf.c:875:		current->flags |= PF_RANDOMIZE;
linux-4.15.18+/fs/binfmt_elf.c:887:	current->mm->start_stack = bprm->p;
linux-4.15.18+/fs/binfmt_elf.c:976:				if (current->flags & PF_RANDOMIZE)
linux-4.15.18+/fs/binfmt_elf.c:1121:	current->mm->end_code = end_code;
linux-4.15.18+/fs/binfmt_elf.c:1122:	current->mm->start_code = start_code;
linux-4.15.18+/fs/binfmt_elf.c:1123:	current->mm->start_data = start_data;
linux-4.15.18+/fs/binfmt_elf.c:1124:	current->mm->end_data = end_data;
linux-4.15.18+/fs/binfmt_elf.c:1125:	current->mm->start_stack = bprm->p;
linux-4.15.18+/fs/binfmt_elf.c:1127:	if ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {
linux-4.15.18+/fs/binfmt_elf.c:1128:		current->mm->brk = current->mm->start_brk =
linux-4.15.18+/fs/binfmt_elf.c:1129:			arch_randomize_brk(current->mm);
linux-4.15.18+/fs/binfmt_elf.c:1131:		current->brk_randomized = 1;
linux-4.15.18+/fs/binfmt_elf.c:1135:	if (current->personality & MMAP_PAGE_ZERO) {
linux-4.15.18+/fs/binfmt_elf.c:1601:	count = current->mm->map_count;
linux-4.15.18+/fs/binfmt_elf.c:1617:	for (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {
linux-4.15.18+/fs/binfmt_elf.c:1651:	 * Count usually is less than current->mm->map_count,
linux-4.15.18+/fs/binfmt_elf.c:1654:	n = current->mm->map_count - count;
linux-4.15.18+/fs/binfmt_elf.c:1855:	fill_auxv_note(&info->auxv, current->mm);
linux-4.15.18+/fs/binfmt_elf.c:2029:	for (ct = current->mm->core_state->dumper.next;
linux-4.15.18+/fs/binfmt_elf.c:2061:	fill_psinfo(info->psinfo, current->group_leader, current->mm);
linux-4.15.18+/fs/binfmt_elf.c:2066:	fill_auxv_note(info->notes + 3, current->mm);
linux-4.15.18+/fs/binfmt_elf.c:2234:	segs = current->mm->map_count;
linux-4.15.18+/fs/binfmt_elf.c:2237:	gate_vma = get_gate_vma(current->mm);
linux-4.15.18+/fs/nilfs2/nilfs.h:176:	struct nilfs_transaction_info *ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/nilfs.h:183:	struct nilfs_transaction_info *ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:158:	struct nilfs_transaction_info *cur_ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:171:		save = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:184:	current->journal_info = ti;
linux-4.15.18+/fs/nilfs2/segment.c:226:		trace_ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:244:	trace_ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:251:	ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:252:	current->journal_info = ti->ti_save;
linux-4.15.18+/fs/nilfs2/segment.c:272:	struct nilfs_transaction_info *ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:296:	current->journal_info = ti->ti_save;
linux-4.15.18+/fs/nilfs2/segment.c:308:	struct nilfs_transaction_info *ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:323:	current->journal_info = ti->ti_save;
linux-4.15.18+/fs/nilfs2/segment.c:343:		struct nilfs_transaction_info *ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:356:	struct nilfs_transaction_info *cur_ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:365:	current->journal_info = ti;
linux-4.15.18+/fs/nilfs2/segment.c:389:	struct nilfs_transaction_info *ti = current->journal_info;
linux-4.15.18+/fs/nilfs2/segment.c:396:	current->journal_info = ti->ti_save;
linux-4.15.18+/fs/nilfs2/segment.c:2250:	BUG_ON((ti = current->journal_info) && ti->ti_magic == NILFS_TI_MAGIC);
linux-4.15.18+/fs/ramfs/file-mmu.c:38:	return current->mm->get_unmapped_area(file, addr, len, pgoff, flags);
linux-4.15.18+/fs/ncpfs/sock.c:729:		spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/fs/ncpfs/sock.c:730:		old_set = current->blocked;
linux-4.15.18+/fs/ncpfs/sock.c:731:		if (current->flags & PF_EXITING)
linux-4.15.18+/fs/ncpfs/sock.c:741:			if (current->sighand->action[SIGINT - 1].sa.sa_handler == SIG_DFL)
linux-4.15.18+/fs/ncpfs/sock.c:743:			if (current->sighand->action[SIGQUIT - 1].sa.sa_handler == SIG_DFL)
linux-4.15.18+/fs/ncpfs/sock.c:746:		siginitsetinv(&current->blocked, mask);
linux-4.15.18+/fs/ncpfs/sock.c:748:		spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/fs/ncpfs/sock.c:752:		spin_lock_irqsave(&current->sighand->siglock, flags);
linux-4.15.18+/fs/ncpfs/sock.c:753:		current->blocked = old_set;
linux-4.15.18+/fs/ncpfs/sock.c:755:		spin_unlock_irqrestore(&current->sighand->siglock, flags);
linux-4.15.18+/fs/ncpfs/sock.c:783:	h->task = 2; /* (current->pid) & 0xff; */
linux-4.15.18+/ipc/ipc_sysctl.c:24:	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/ipc_sysctl.c:55:	struct ipc_namespace *ns = current->nsproxy->ipc_ns;
linux-4.15.18+/fs/binfmt_flat.c:101:		current->comm, current->pid, cprm->siginfo->si_signo);
linux-4.15.18+/fs/binfmt_flat.c:119:	sp = (unsigned long __user *)current->mm->start_stack;
linux-4.15.18+/fs/binfmt_flat.c:126:	current->mm->start_stack = (unsigned long)sp & -FLAT_STACK_ALIGN;
linux-4.15.18+/fs/binfmt_flat.c:127:	sp = (unsigned long __user *)current->mm->start_stack;
linux-4.15.18+/fs/binfmt_flat.c:138:	current->mm->arg_start = (unsigned long)p;
linux-4.15.18+/fs/binfmt_flat.c:147:	current->mm->arg_end = (unsigned long)p;
linux-4.15.18+/fs/binfmt_flat.c:149:	current->mm->env_start = (unsigned long) p;
linux-4.15.18+/fs/binfmt_flat.c:158:	current->mm->env_end = (unsigned long)p;
linux-4.15.18+/fs/binfmt_flat.c:363:	pr_cont(", killing %s!\n", current->comm);
linux-4.15.18+/fs/binfmt_flat.c:380:	ptr = (unsigned long __user *)(current->mm->start_code + r.reloc.offset);
linux-4.15.18+/fs/binfmt_flat.c:382:	ptr = (unsigned long __user *)(current->mm->start_data + r.reloc.offset);
linux-4.15.18+/fs/binfmt_flat.c:392:		val += current->mm->start_code;
linux-4.15.18+/fs/binfmt_flat.c:395:		val += current->mm->start_data;
linux-4.15.18+/fs/binfmt_flat.c:398:		val += current->mm->end_data;
linux-4.15.18+/fs/binfmt_flat.c:699:		current->mm->start_code = start_code;
linux-4.15.18+/fs/binfmt_flat.c:700:		current->mm->end_code = end_code;
linux-4.15.18+/fs/binfmt_flat.c:701:		current->mm->start_data = datapos;
linux-4.15.18+/fs/binfmt_flat.c:702:		current->mm->end_data = datapos + data_len;
linux-4.15.18+/fs/binfmt_flat.c:710:		current->mm->start_brk = datapos + data_len + bss_len;
linux-4.15.18+/fs/binfmt_flat.c:711:		current->mm->brk = (current->mm->start_brk + 3) & ~3;
linux-4.15.18+/fs/binfmt_flat.c:713:		current->mm->context.end_brk = memp + memp_size - stack_len;
linux-4.15.18+/fs/binfmt_flat.c:962:	current->mm->start_stack =
linux-4.15.18+/fs/binfmt_flat.c:963:		((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;
linux-4.15.18+/fs/binfmt_flat.c:964:	pr_debug("sp=%lx\n", current->mm->start_stack);
linux-4.15.18+/fs/binfmt_flat.c:967:	res = transfer_args_to_stack(bprm, &current->mm->start_stack);
linux-4.15.18+/fs/binfmt_flat.c:969:		res = create_flat_tables(bprm, current->mm->start_stack);
linux-4.15.18+/fs/binfmt_flat.c:985:			current->mm->start_stack -= sizeof(unsigned long);
linux-4.15.18+/fs/binfmt_flat.c:986:			sp = (unsigned long __user *)current->mm->start_stack;
linux-4.15.18+/fs/binfmt_flat.c:998:		 regs, start_addr, current->mm->start_stack);
linux-4.15.18+/fs/binfmt_flat.c:999:	start_thread(regs, start_addr, current->mm->start_stack);
linux-4.15.18+/ipc/sem.c:569:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/sem.c:1036:			current->comm, task_pid_nr(current));
linux-4.15.18+/ipc/sem.c:1581:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/sem.c:1679:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/sem.c:1732:	undo_list = current->sysvsem.undo_list;
linux-4.15.18+/ipc/sem.c:1741:		current->sysvsem.undo_list = undo_list;
linux-4.15.18+/ipc/sem.c:1875:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/mq_sysctl.c:20:	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/util.c:871:	iter->ns    = get_ipc_ns(current->nsproxy->ipc_ns);
linux-4.15.18+/ipc/msg.c:275:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/msg.c:539:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/msg.c:648:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/msg.c:743:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/msg.c:981:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/kernel/acct.c:43: * ->mmap_sem to walk the vma list of current->mm. Nasty, since it leaks
linux-4.15.18+/kernel/acct.c:417:	struct pacct_struct *pacct = &current->signal->pacct;
linux-4.15.18+/kernel/acct.c:428:	strlcpy(ac->ac_comm, current->comm, sizeof(ac->ac_comm));
linux-4.15.18+/kernel/acct.c:432:	run_time -= current->group_leader->start_time;
linux-4.15.18+/kernel/acct.c:456:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/acct.c:457:	tty = current->signal->tty;	/* Safe as we hold the siglock */
linux-4.15.18+/kernel/acct.c:466:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/acct.c:481:	flim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
linux-4.15.18+/kernel/acct.c:482:	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
linux-4.15.18+/kernel/acct.c:508:		ac.ac_ppid = task_tgid_nr_ns(rcu_dereference(current->real_parent),
linux-4.15.18+/kernel/acct.c:524:	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;
linux-4.15.18+/kernel/acct.c:535:	struct pacct_struct *pacct = &current->signal->pacct;
linux-4.15.18+/kernel/acct.c:539:	if (group_dead && current->mm) {
linux-4.15.18+/kernel/acct.c:542:		down_read(&current->mm->mmap_sem);
linux-4.15.18+/kernel/acct.c:543:		vma = current->mm->mmap;
linux-4.15.18+/kernel/acct.c:548:		up_read(&current->mm->mmap_sem);
linux-4.15.18+/kernel/acct.c:551:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/acct.c:556:		if (current->flags & PF_FORKNOEXEC)
linux-4.15.18+/kernel/acct.c:559:	if (current->flags & PF_SUPERPRIV)
linux-4.15.18+/kernel/acct.c:561:	if (current->flags & PF_DUMPCORE)
linux-4.15.18+/kernel/acct.c:563:	if (current->flags & PF_SIGNALED)
linux-4.15.18+/kernel/acct.c:569:	pacct->ac_minflt += current->min_flt;
linux-4.15.18+/kernel/acct.c:570:	pacct->ac_majflt += current->maj_flt;
linux-4.15.18+/kernel/acct.c:571:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/audit.c:1404:		t = READ_ONCE(current->signal->audit_tty);
linux-4.15.18+/kernel/audit.c:1425:			t = READ_ONCE(current->signal->audit_tty);
linux-4.15.18+/kernel/audit.c:1428:			t = xchg(&current->signal->audit_tty, t);
linux-4.15.18+/kernel/audit.c:2269:	ab = audit_log_start(current->audit_context, GFP_KERNEL,
linux-4.15.18+/kernel/audit.c:2281:	audit_log_name(current->audit_context, name, link, 0, NULL);
linux-4.15.18+/ipc/shm.c:271: * The descriptor has already been removed from the current->mm->mmap list
linux-4.15.18+/ipc/shm.c:621:	list_add(&shp->shm_clist, &current->sysvshm.shm_clist);
linux-4.15.18+/ipc/shm.c:681:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/shm.c:1055:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/shm.c:1225:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/shm.c:1341:	ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/shm.c:1402:	if (down_write_killable(&current->mm->mmap_sem)) {
linux-4.15.18+/ipc/shm.c:1412:		if (find_vma_intersection(current->mm, addr, addr + size))
linux-4.15.18+/ipc/shm.c:1422:	up_write(&current->mm->mmap_sem);
linux-4.15.18+/ipc/shm.c:1483:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/audit_watch.c:277:			audit_filter_inodes(current, current->audit_context);
linux-4.15.18+/kernel/ptrace.c:459:	if (!current->ptrace) {
linux-4.15.18+/kernel/ptrace.c:460:		ret = security_ptrace_traceme(current->parent);
linux-4.15.18+/kernel/ptrace.c:466:		if (!ret && !(current->real_parent->flags & PF_EXITING)) {
linux-4.15.18+/kernel/ptrace.c:467:			current->ptrace = PT_PTRACED;
linux-4.15.18+/kernel/ptrace.c:468:			ptrace_link(current, current->real_parent);
linux-4.15.18+/kernel/ptrace.c:640:		if (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||
linux-4.15.18+/kernel/ptrace.c:641:		    current->ptrace & PT_SUSPEND_SECCOMP)
linux-4.15.18+/kernel/exit.c:496:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/exit.c:536:	BUG_ON(mm != current->active_mm);
linux-4.15.18+/kernel/exit.c:539:	current->mm = NULL;
linux-4.15.18+/kernel/exit.c:754:			current->comm, task_pid_nr(current), free);
linux-4.15.18+/kernel/exit.c:826:			current->comm, task_pid_nr(current),
linux-4.15.18+/kernel/exit.c:889:	if (unlikely(current->pi_state_cache))
linux-4.15.18+/kernel/exit.c:890:		kfree(current->pi_state_cache);
linux-4.15.18+/kernel/exit.c:947:	struct signal_struct *sig = current->signal;
linux-4.15.18+/kernel/exit.c:954:		struct sighand_struct *const sighand = current->sighand;
linux-4.15.18+/kernel/exit.c:1089:		struct signal_struct *psig = current->signal;
linux-4.15.18+/kernel/exit.c:1114:		spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/exit.c:1139:		spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/exit.c:1505:	add_wait_queue(&current->signal->wait_chldexit, &wo->child_wait);
linux-4.15.18+/kernel/exit.c:1546:	remove_wait_queue(&current->signal->wait_chldexit, &wo->child_wait);
linux-4.15.18+/kernel/delayacct.c:69:	current->delays->blkio_start = ktime_get_ns();
linux-4.15.18+/kernel/delayacct.c:159:	current->delays->freepages_start = ktime_get_ns();
linux-4.15.18+/kernel/delayacct.c:165:		&current->delays->lock,
linux-4.15.18+/kernel/delayacct.c:166:		&current->delays->freepages_start,
linux-4.15.18+/kernel/delayacct.c:167:		&current->delays->freepages_delay,
linux-4.15.18+/kernel/delayacct.c:168:		&current->delays->freepages_count);
linux-4.15.18+/kernel/sched/idle.c:304:	WARN_ON_ONCE(current->policy != SCHED_FIFO);
linux-4.15.18+/kernel/sched/idle.c:305:	WARN_ON_ONCE(current->nr_cpus_allowed != 1);
linux-4.15.18+/kernel/sched/idle.c:306:	WARN_ON_ONCE(!(current->flags & PF_KTHREAD));
linux-4.15.18+/kernel/sched/idle.c:307:	WARN_ON_ONCE(!(current->flags & PF_NO_SETAFFINITY));
linux-4.15.18+/kernel/sched/idle.c:312:	current->flags |= PF_IDLE;
linux-4.15.18+/kernel/sched/idle.c:324:	current->flags &= ~PF_IDLE;
linux-4.15.18+/kernel/sched/membarrier.c:44:	if (!(atomic_read(&current->mm->membarrier_state)
linux-4.15.18+/kernel/sched/membarrier.c:83:		if (p && p->mm == current->mm) {
linux-4.15.18+/kernel/sched/wait.c:387:	return (current->flags & PF_KTHREAD) && kthread_should_stop();
linux-4.15.18+/kernel/sched/cputime.c:746:	if (current->flags & PF_VCPU)
linux-4.15.18+/kernel/sched/cputime.c:789:	current->flags |= PF_VCPU;
linux-4.15.18+/kernel/sched/cputime.c:800:	current->flags &= ~PF_VCPU;
linux-4.15.18+/kernel/sched/cputime.c:818:	vtime = &current->vtime;
linux-4.15.18+/kernel/fork.c:837:	if (current->mm) {
linux-4.15.18+/kernel/fork.c:838:		mm->flags = current->mm->flags & MMF_INIT_MASK;
linux-4.15.18+/kernel/fork.c:839:		mm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;
linux-4.15.18+/kernel/fork.c:1073:	if (mm && mm != current->mm &&
linux-4.15.18+/kernel/fork.c:1184:	struct mm_struct *mm, *oldmm = current->mm;
linux-4.15.18+/kernel/fork.c:1236:	oldmm = current->mm;
linux-4.15.18+/kernel/fork.c:1265:	struct fs_struct *fs = current->fs;
linux-4.15.18+/kernel/fork.c:1291:	oldf = current->files;
linux-4.15.18+/kernel/fork.c:1313:	struct io_context *ioc = current->io_context;
linux-4.15.18+/kernel/fork.c:1341:		atomic_inc(&current->sighand->count);
linux-4.15.18+/kernel/fork.c:1350:	memcpy(sig->action, current->sighand->action, sizeof(sig->action));
linux-4.15.18+/kernel/fork.c:1421:	task_lock(current->group_leader);
linux-4.15.18+/kernel/fork.c:1422:	memcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);
linux-4.15.18+/kernel/fork.c:1423:	task_unlock(current->group_leader);
linux-4.15.18+/kernel/fork.c:1430:	sig->oom_score_adj = current->signal->oom_score_adj;
linux-4.15.18+/kernel/fork.c:1431:	sig->oom_score_adj_min = current->signal->oom_score_adj_min;
linux-4.15.18+/kernel/fork.c:1447:	assert_spin_locked(&current->sighand->siglock);
linux-4.15.18+/kernel/fork.c:1451:	p->seccomp = current->seccomp;
linux-4.15.18+/kernel/fork.c:1473:	current->clear_child_tid = tidptr;
linux-4.15.18+/kernel/fork.c:1575:				current->signal->flags & SIGNAL_UNKILLABLE)
linux-4.15.18+/kernel/fork.c:1585:				current->nsproxy->pid_ns_for_children))
linux-4.15.18+/kernel/fork.c:1621:	current->flags &= ~PF_NPROC_EXCEEDED;
linux-4.15.18+/kernel/fork.c:1663:	p->default_timer_slack_ns = current->timer_slack_ns;
linux-4.15.18+/kernel/fork.c:1805:		p->group_leader = current->group_leader;
linux-4.15.18+/kernel/fork.c:1806:		p->tgid = current->tgid;
linux-4.15.18+/kernel/fork.c:1809:			p->exit_signal = current->group_leader->exit_signal;
linux-4.15.18+/kernel/fork.c:1843:		p->real_parent = current->real_parent;
linux-4.15.18+/kernel/fork.c:1844:		p->parent_exec_id = current->parent_exec_id;
linux-4.15.18+/kernel/fork.c:1847:		p->parent_exec_id = current->self_exec_id;
linux-4.15.18+/kernel/fork.c:1852:	spin_lock(&current->sighand->siglock);
linux-4.15.18+/kernel/fork.c:1892:			p->signal->tty = tty_kref_get(current->signal->tty);
linux-4.15.18+/kernel/fork.c:1906:			current->signal->nr_threads++;
linux-4.15.18+/kernel/fork.c:1907:			atomic_inc(&current->signal->live);
linux-4.15.18+/kernel/fork.c:1908:			atomic_inc(&current->signal->sigcnt);
linux-4.15.18+/kernel/fork.c:1919:	spin_unlock(&current->sighand->siglock);
linux-4.15.18+/kernel/fork.c:1934:	spin_unlock(&current->sighand->siglock);
linux-4.15.18+/kernel/fork.c:2257:		if (atomic_read(&current->sighand->count) > 1)
linux-4.15.18+/kernel/fork.c:2273:	struct fs_struct *fs = current->fs;
linux-4.15.18+/kernel/fork.c:2294:	struct files_struct *fd = current->files;
linux-4.15.18+/kernel/fork.c:2389:			fs = current->fs;
linux-4.15.18+/kernel/fork.c:2391:			current->fs = new_fs;
linux-4.15.18+/kernel/fork.c:2400:			fd = current->files;
linux-4.15.18+/kernel/fork.c:2401:			current->files = new_fd;
linux-4.15.18+/kernel/power/process.c:132:	current->flags |= PF_SUSPEND_TASK;
linux-4.15.18+/ipc/mqueue.c:338:		ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/mqueue.c:549:		if (walk->task->static_prio <= current->static_prio) {
linux-4.15.18+/ipc/mqueue.c:778:	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
linux-4.15.18+/ipc/mqueue.c:863:	struct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;
linux-4.15.18+/kernel/sched/fair.c:1370:	this_cpupid = cpu_pid_to_cpupid(dst_cpu, current->pid);
linux-4.15.18+/kernel/sched/fair.c:2304:	if (tsk->mm == current->mm)
linux-4.15.18+/kernel/sched/fair.c:5646:	if (time_after(jiffies, current->wakee_flip_decay_ts + HZ)) {
linux-4.15.18+/kernel/sched/fair.c:5647:		current->wakee_flips >>= 1;
linux-4.15.18+/kernel/sched/fair.c:5648:		current->wakee_flip_decay_ts = jiffies;
linux-4.15.18+/kernel/sched/fair.c:5651:	if (current->last_wakee != p) {
linux-4.15.18+/kernel/sched/fair.c:5652:		current->last_wakee = p;
linux-4.15.18+/kernel/sched/fair.c:5653:		current->wakee_flips++;
linux-4.15.18+/kernel/sched/fair.c:5676:	unsigned int master = current->wakee_flips;
linux-4.15.18+/kernel/utsname_sysctl.c:26:	uts_ns = current->nsproxy->uts_ns;
linux-4.15.18+/kernel/nsproxy.c:207:					 new_fs ? new_fs : current->fs);
linux-4.15.18+/kernel/module.c:2186:	update_protections(current->mm);
linux-4.15.18+/kernel/module.c:3453:	current->flags &= ~PF_USED_ASYNC;
linux-4.15.18+/kernel/module.c:3492:	if (!mod->async_probe_requested && (current->flags & PF_USED_ASYNC))
linux-4.15.18+/kernel/signal.c:236:				current->comm, current->pid, sig);
linux-4.15.18+/kernel/signal.c:632:		current->jobctl |= JOBCTL_STOP_DEQUEUED;
linux-4.15.18+/kernel/signal.c:1528:	spinlock_t *lock = &current->sighand->siglock;
linux-4.15.18+/kernel/signal.c:1763:	if (!likely(current->ptrace))
linux-4.15.18+/kernel/signal.c:1778:	if (unlikely(current->mm->core_state) &&
linux-4.15.18+/kernel/signal.c:1779:	    unlikely(current->mm == current->parent->mm))
linux-4.15.18+/kernel/signal.c:1796: * This must be called with current->sighand->siglock held.
linux-4.15.18+/kernel/signal.c:1799: * We always set current->last_siginfo while stopped here.
linux-4.15.18+/kernel/signal.c:1804: * is gone, we keep current->exit_code unless clear_code.
linux-4.15.18+/kernel/signal.c:1807:	__releases(&current->sighand->siglock)
linux-4.15.18+/kernel/signal.c:1808:	__acquires(&current->sighand->siglock)
linux-4.15.18+/kernel/signal.c:1824:		spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:1826:		spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:1840:	current->last_siginfo = info;
linux-4.15.18+/kernel/signal.c:1841:	current->exit_code = exit_code;
linux-4.15.18+/kernel/signal.c:1850:	if (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))
linux-4.15.18+/kernel/signal.c:1861:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:1905:			current->exit_code = 0;
linux-4.15.18+/kernel/signal.c:1914:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:1915:	current->last_siginfo = NULL;
linux-4.15.18+/kernel/signal.c:1918:	current->jobctl &= ~JOBCTL_LISTENING;
linux-4.15.18+/kernel/signal.c:1945:	if (unlikely(current->task_works))
linux-4.15.18+/kernel/signal.c:1948:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:1950:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:1968: * Must be called with @current->sighand->siglock held, which is released
linux-4.15.18+/kernel/signal.c:1976:	__releases(&current->sighand->siglock)
linux-4.15.18+/kernel/signal.c:1978:	struct signal_struct *sig = current->signal;
linux-4.15.18+/kernel/signal.c:1980:	if (!(current->jobctl & JOBCTL_STOP_PENDING)) {
linux-4.15.18+/kernel/signal.c:1987:		if (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||
linux-4.15.18+/kernel/signal.c:2035:	if (likely(!current->ptrace)) {
linux-4.15.18+/kernel/signal.c:2047:		spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:2089: * Must be called with @current->sighand->siglock held, which may be
linux-4.15.18+/kernel/signal.c:2094:	struct signal_struct *signal = current->signal;
linux-4.15.18+/kernel/signal.c:2095:	int signr = current->jobctl & JOBCTL_STOP_SIGMASK;
linux-4.15.18+/kernel/signal.c:2097:	if (current->ptrace & PT_SEIZED) {
linux-4.15.18+/kernel/signal.c:2107:		current->exit_code = 0;
linux-4.15.18+/kernel/signal.c:2122:	current->jobctl |= JOBCTL_STOP_DEQUEUED;
linux-4.15.18+/kernel/signal.c:2126:	signr = current->exit_code;
linux-4.15.18+/kernel/signal.c:2130:	current->exit_code = 0;
linux-4.15.18+/kernel/signal.c:2143:		info->si_pid = task_pid_vnr(current->parent);
linux-4.15.18+/kernel/signal.c:2145:						task_uid(current->parent));
linux-4.15.18+/kernel/signal.c:2150:	if (sigismember(&current->blocked, signr)) {
linux-4.15.18+/kernel/signal.c:2160:	struct sighand_struct *sighand = current->sighand;
linux-4.15.18+/kernel/signal.c:2161:	struct signal_struct *signal = current->signal;
linux-4.15.18+/kernel/signal.c:2164:	if (unlikely(current->task_works))
linux-4.15.18+/kernel/signal.c:2207:		if (ptrace_reparented(current->group_leader))
linux-4.15.18+/kernel/signal.c:2208:			do_notify_parent_cldstop(current->group_leader,
linux-4.15.18+/kernel/signal.c:2218:		if (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&
linux-4.15.18+/kernel/signal.c:2222:		if (unlikely(current->jobctl & JOBCTL_TRAP_MASK)) {
linux-4.15.18+/kernel/signal.c:2228:		signr = dequeue_signal(current, &current->blocked, &ksig->info);
linux-4.15.18+/kernel/signal.c:2233:		if (unlikely(current->ptrace) && signr != SIGKILL) {
linux-4.15.18+/kernel/signal.c:2315:		current->flags |= PF_SIGNALED;
linux-4.15.18+/kernel/signal.c:2364:	sigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);
linux-4.15.18+/kernel/signal.c:2478:	struct restart_block *restart = &current->restart_block;
linux-4.15.18+/kernel/signal.c:2492:		sigandnsets(&newblocked, newset, &current->blocked);
linux-4.15.18+/kernel/signal.c:2500: * set_current_blocked - change current->blocked mask
linux-4.15.18+/kernel/signal.c:2518:	 * to do. The current->blocked shouldn't be modified by other task.
linux-4.15.18+/kernel/signal.c:2580:	old_set = current->blocked;
linux-4.15.18+/kernel/signal.c:2604:	sigset_t old_set = current->blocked;
linux-4.15.18+/kernel/signal.c:2627:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:2628:	sigorsets(set, &current->pending.signal,
linux-4.15.18+/kernel/signal.c:2629:		  &current->signal->shared_pending.signal);
linux-4.15.18+/kernel/signal.c:2630:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:2633:	sigandsets(set, &current->blocked, set);
linux-4.15.18+/kernel/signal.c:3120:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:3121:	current->sighand->action[sig - 1].sa.sa_handler = action;
linux-4.15.18+/kernel/signal.c:3128:		flush_sigqueue_mask(&mask, &current->signal->shared_pending);
linux-4.15.18+/kernel/signal.c:3129:		flush_sigqueue_mask(&mask, &current->pending);
linux-4.15.18+/kernel/signal.c:3132:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/signal.c:3196:			(current->sas_ss_flags & SS_FLAG_BITS);
linux-4.15.18+/kernel/signal.c:3358:	old_set = current->blocked.sig[0];
linux-4.15.18+/kernel/signal.c:3364:		new_blocked = current->blocked;
linux-4.15.18+/kernel/signal.c:3559:	return current->blocked.sig[0];
linux-4.15.18+/kernel/signal.c:3564:	int old = current->blocked.sig[0];
linux-4.15.18+/kernel/signal.c:3608:	current->saved_sigmask = current->blocked;
linux-4.15.18+/kernel/locking/rtmutex-debug.c:113:	       current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/locking/rtmutex-debug.c:116:	       current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/locking/rtmutex-debug.c:130:		current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/locking/spinlock_debug.c:60:		current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/locking/spinlock_debug.c:144:		msg, raw_smp_processor_id(), current->comm,
linux-4.15.18+/kernel/locking/lockdep.c:99:	current->lockdep_recursion++;
linux-4.15.18+/kernel/locking/lockdep.c:113:	current->lockdep_recursion--;
linux-4.15.18+/kernel/locking/lockdep.c:327:	current->lockdep_recursion++;
linux-4.15.18+/kernel/locking/lockdep.c:333:	current->lockdep_recursion--;
linux-4.15.18+/kernel/locking/lockdep.c:1688:	if (current->hardirq_context)
linux-4.15.18+/kernel/locking/lockdep.c:1691:		if (current->softirq_context)
linux-4.15.18+/kernel/locking/lockdep.c:2102:	pr_warn("%s/%d: ", current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/locking/lockdep.c:2844:	if (unlikely(!debug_locks || current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:2847:	if (unlikely(current->hardirqs_enabled)) {
linux-4.15.18+/kernel/locking/lockdep.c:2875:	if (DEBUG_LOCKS_WARN_ON(current->hardirq_context))
linux-4.15.18+/kernel/locking/lockdep.c:2878:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:2880:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:2899:	if (unlikely(!debug_locks || current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:2935:	if (unlikely(!debug_locks || current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:2950:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:2965:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:2975:	if (unlikely(!debug_locks || current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3221:		if (DEBUG_LOCKS_WARN_ON(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3225:		current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:3227:		current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:3832:		if (DEBUG_LOCKS_WARN_ON(current->hardirqs_enabled)) {
linux-4.15.18+/kernel/locking/lockdep.c:3836:		if (DEBUG_LOCKS_WARN_ON(!current->hardirqs_enabled)) {
linux-4.15.18+/kernel/locking/lockdep.c:3849:			DEBUG_LOCKS_WARN_ON(current->softirqs_enabled);
linux-4.15.18+/kernel/locking/lockdep.c:3852:			DEBUG_LOCKS_WARN_ON(!current->softirqs_enabled);
linux-4.15.18+/kernel/locking/lockdep.c:3867:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3871:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:3875:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:3884:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3888:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:3892:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:3907:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3913:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:3917:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:3927:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3932:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:3936:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:3946:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3952:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:3954:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:3966:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3972:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:3974:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:3985:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:3991:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:3993:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:4002:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:4008:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:4010:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:4145:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:4150:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:4153:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:4165:	if (unlikely(current->lockdep_recursion))
linux-4.15.18+/kernel/locking/lockdep.c:4170:	current->lockdep_recursion = 1;
linux-4.15.18+/kernel/locking/lockdep.c:4172:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:4189:	current->curr_chain_key = 0;
linux-4.15.18+/kernel/locking/lockdep.c:4190:	current->lockdep_depth = 0;
linux-4.15.18+/kernel/locking/lockdep.c:4191:	current->lockdep_recursion = 0;
linux-4.15.18+/kernel/locking/lockdep.c:4192:	memset(current->held_locks, 0, MAX_LOCK_DEPTH*sizeof(struct held_lock));
linux-4.15.18+/kernel/locking/lockdep.c:4430:	       current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/locking/lockdep.c:4440:	if (unlikely(current->lockdep_depth > 0))
linux-4.15.18+/kernel/locking/rtmutex.c:1023:	raw_spin_lock(&current->pi_lock);
linux-4.15.18+/kernel/locking/rtmutex.c:1028:	 * Remove it from current->pi_waiters and deboost.
linux-4.15.18+/kernel/locking/rtmutex.c:1059:	raw_spin_unlock(&current->pi_lock);
linux-4.15.18+/kernel/locking/rtmutex.c:1077:	raw_spin_lock(&current->pi_lock);
linux-4.15.18+/kernel/locking/rtmutex.c:1079:	current->pi_blocked_on = NULL;
linux-4.15.18+/kernel/locking/rtmutex.c:1080:	raw_spin_unlock(&current->pi_lock);
linux-4.15.18+/kernel/cgroup/cgroup-v1.c:1070:			task_tgid_nr(current), current->comm);
linux-4.15.18+/kernel/cgroup/cgroup.c:1295:	cset = current->nsproxy->cgroup_ns->root_cset;
linux-4.15.18+/kernel/cgroup/cgroup.c:1745:	if (current->nsproxy->cgroup_ns == &init_cgroup_ns) {
linux-4.15.18+/kernel/cgroup/cgroup.c:2015:	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
linux-4.15.18+/kernel/cgroup/cgroup.c:3411:	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
linux-4.15.18+/kernel/cgroup/cgroup.c:4322:	struct cgroup_namespace *ns = current->nsproxy->cgroup_ns;
linux-4.15.18+/kernel/cgroup/cgroup.c:4757:			current->comm, current->pid, ss->name);
linux-4.15.18+/kernel/cgroup/cgroup.c:5430:						current->nsproxy->cgroup_ns);
linux-4.15.18+/kernel/cgroup/cpuset.c:2092:	set_cpus_allowed_ptr(task, &current->cpus_allowed);
linux-4.15.18+/kernel/cgroup/cpuset.c:2093:	task->mems_allowed = current->mems_allowed;
linux-4.15.18+/kernel/cgroup/cpuset.c:2461:	nodes_setall(current->mems_allowed);
linux-4.15.18+/kernel/cgroup/cpuset.c:2492: * Are any of the nodes in the nodemask allowed in current->mems_allowed?
linux-4.15.18+/kernel/cgroup/cpuset.c:2496:	return nodes_intersects(*nodemask, current->mems_allowed);
linux-4.15.18+/kernel/cgroup/cpuset.c:2560:	if (node_isset(node, current->mems_allowed))
linux-4.15.18+/kernel/cgroup/cpuset.c:2571:	if (current->flags & PF_EXITING) /* Let dying task have memory */
linux-4.15.18+/kernel/cgroup/cpuset.c:2615:	return *rotor = next_node_in(*rotor, current->mems_allowed);
linux-4.15.18+/kernel/cgroup/cpuset.c:2620:	if (current->cpuset_mem_spread_rotor == NUMA_NO_NODE)
linux-4.15.18+/kernel/cgroup/cpuset.c:2621:		current->cpuset_mem_spread_rotor =
linux-4.15.18+/kernel/cgroup/cpuset.c:2622:			node_random(&current->mems_allowed);
linux-4.15.18+/kernel/cgroup/cpuset.c:2624:	return cpuset_spread_node(&current->cpuset_mem_spread_rotor);
linux-4.15.18+/kernel/cgroup/cpuset.c:2629:	if (current->cpuset_slab_spread_rotor == NUMA_NO_NODE)
linux-4.15.18+/kernel/cgroup/cpuset.c:2630:		current->cpuset_slab_spread_rotor =
linux-4.15.18+/kernel/cgroup/cpuset.c:2631:			node_random(&current->mems_allowed);
linux-4.15.18+/kernel/cgroup/cpuset.c:2633:	return cpuset_spread_node(&current->cpuset_slab_spread_rotor);
linux-4.15.18+/kernel/cgroup/cpuset.c:2668:	pr_info("%s cpuset=", current->comm);
linux-4.15.18+/kernel/cgroup/cpuset.c:2671:		nodemask_pr_args(&current->mems_allowed));
linux-4.15.18+/kernel/cgroup/cpuset.c:2733:				current->nsproxy->cgroup_ns);
linux-4.15.18+/kernel/sched/core.c:2210:		p->numa_preferred_nid = current->numa_preferred_nid;
linux-4.15.18+/kernel/sched/core.c:2357:	p->prio = current->normal_prio;
linux-4.15.18+/kernel/sched/core.c:2513:	hlist_add_head(&notifier->link, &current->preempt_notifiers);
linux-4.15.18+/kernel/sched/core.c:2638:		      current->comm, current->pid, preempt_count()))
linux-4.15.18+/kernel/sched/core.c:2752:	if (current->set_child_tid)
linux-4.15.18+/kernel/sched/core.c:2753:		put_user(task_pid_vnr(current), current->set_child_tid);
linux-4.15.18+/kernel/sched/core.c:3079:		current->preempt_disable_ip = ip;
linux-4.15.18+/kernel/sched/core.c:3399:	raw_spin_lock_irq(&current->pi_lock);
linux-4.15.18+/kernel/sched/core.c:3400:	raw_spin_unlock_irq(&current->pi_lock);
linux-4.15.18+/kernel/sched/core.c:3406:	current->flags |= PF_NOFREEZE;
linux-4.15.18+/kernel/sched/core.c:3460:	WARN_ON_ONCE(current->state);
linux-4.15.18+/kernel/sched/core.c:4833:	current->sched_class->yield_task(rq);
linux-4.15.18+/kernel/sched/core.c:5008:	int old_iowait = current->in_iowait;
linux-4.15.18+/kernel/sched/core.c:5010:	current->in_iowait = 1;
linux-4.15.18+/kernel/sched/core.c:5018:	current->in_iowait = token;
linux-4.15.18+/kernel/sched/core.c:5431:	struct mm_struct *mm = current->active_mm;
linux-4.15.18+/kernel/sched/core.c:6003:	 * Blocking primitives will set (and therefore destroy) current->state,
linux-4.15.18+/kernel/sched/core.c:6007:	WARN_ONCE(current->state != TASK_RUNNING && current->task_state_change,
linux-4.15.18+/kernel/sched/core.c:6010:			current->state,
linux-4.15.18+/kernel/sched/core.c:6011:			(void *)current->task_state_change,
linux-4.15.18+/kernel/sched/core.c:6012:			(void *)current->task_state_change);
linux-4.15.18+/kernel/sched/core.c:6047:			current->pid, current->comm);
linux-4.15.18+/kernel/printk/printk.c:672:				 current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/printk/printk.c:775:		if (!___ratelimit(&user->rs, current->comm))
linux-4.15.18+/kernel/printk/printk.c:3122:	       log_lvl, raw_smp_processor_id(), current->pid, current->comm,
linux-4.15.18+/kernel/kcov.c:388:		if (unused != 0 || current->kcov != kcov)
linux-4.15.18+/kernel/workqueue.c:2125:		       current->comm, preempt_count(), task_pid_nr(current),
linux-4.15.18+/kernel/workqueue.c:2432:	WARN_ONCE(current->flags & PF_MEMALLOC,
linux-4.15.18+/kernel/workqueue.c:2434:		  current->pid, current->comm, target_wq->name, target_func);
linux-4.15.18+/kernel/compat.c:245:	old_set = current->blocked.sig[0];
linux-4.15.18+/kernel/compat.c:252:		new_blocked = current->blocked;
linux-4.15.18+/kernel/kthread.c:68:	current->set_child_tid = (__force void __user *)kthread;
linux-4.15.18+/kernel/kthread.c:226:	current->vfork_done = &self->exited;
linux-4.15.18+/kernel/kthread.c:258:	current->pref_node_fork = create->node;
linux-4.15.18+/kernel/kthread.c:549:	current->flags |= PF_NOFREEZE;
linux-4.15.18+/kernel/kthread.c:1178:	if (!(current->flags & PF_KTHREAD))
linux-4.15.18+/kernel/kthread.c:1204:	if (current->flags & PF_KTHREAD) {
linux-4.15.18+/kernel/workqueue_internal.h:64:	if (in_task() && (current->flags & PF_WQ_WORKER))
linux-4.15.18+/kernel/user_namespace.c:1275:	if (current->fs->users != 1)
linux-4.15.18+/kernel/sysctl.c:1967:		current->comm, table->procname);
linux-4.15.18+/kernel/time/tick-sched.c:212:	if (check_tick_dependency(&current->tick_dep_mask))
linux-4.15.18+/kernel/time/tick-sched.c:215:	if (check_tick_dependency(&current->signal->tick_dep_mask))
linux-4.15.18+/kernel/time/tick-sched.c:380:		if (atomic_read(&current->tick_dep_mask) ||
linux-4.15.18+/kernel/time/tick-sched.c:381:		    atomic_read(&current->signal->tick_dep_mask))
linux-4.15.18+/kernel/time/posix-stubs.c:26:		    current->pid, current->comm);
linux-4.15.18+/kernel/time/posix-stubs.c:137:	current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
linux-4.15.18+/kernel/time/posix-stubs.c:138:	current->restart_block.nanosleep.rmtp = rmtp;
linux-4.15.18+/kernel/time/posix-stubs.c:221:	current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
linux-4.15.18+/kernel/time/posix-stubs.c:222:	current->restart_block.nanosleep.compat_rmtp = rmtp;
linux-4.15.18+/kernel/livepatch/patch.c:97:		 * current->patch_state reads.  Otherwise we could read an
linux-4.15.18+/kernel/livepatch/patch.c:103:		patch_state = current->patch_state;
linux-4.15.18+/kernel/time/posix-cpu-timers.c:346:			p = current->group_leader;
linux-4.15.18+/kernel/time/posix-cpu-timers.c:1318:		restart = &current->restart_block;
linux-4.15.18+/kernel/time/posix-cpu-timers.c:1332:	struct restart_block *restart_block = &current->restart_block;
linux-4.15.18+/kernel/time/posix-timers.c:62: * key, constructed from current->signal address and per signal struct counter.
linux-4.15.18+/kernel/time/posix-timers.c:162:	struct signal_struct *sig = current->signal;
linux-4.15.18+/kernel/time/posix-timers.c:170:	struct signal_struct *sig = current->signal;
linux-4.15.18+/kernel/time/posix-timers.c:436:	struct task_struct *rtn = current->group_leader;
linux-4.15.18+/kernel/time/posix-timers.c:561:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/time/posix-timers.c:562:	new_timer->it_signal = current->signal;
linux-4.15.18+/kernel/time/posix-timers.c:563:	list_add(&new_timer->list, &current->signal->posix_timers);
linux-4.15.18+/kernel/time/posix-timers.c:564:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/time/posix-timers.c:630:		if (timr->it_signal == current->signal) {
linux-4.15.18+/kernel/time/posix-timers.c:989:	spin_lock(&current->sighand->siglock);
linux-4.15.18+/kernel/time/posix-timers.c:991:	spin_unlock(&current->sighand->siglock);
linux-4.15.18+/kernel/time/posix-timers.c:1224:	current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
linux-4.15.18+/kernel/time/posix-timers.c:1225:	current->restart_block.nanosleep.rmtp = rmtp;
linux-4.15.18+/kernel/time/posix-timers.c:1250:	current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
linux-4.15.18+/kernel/time/posix-timers.c:1251:	current->restart_block.nanosleep.compat_rmtp = rmtp;
linux-4.15.18+/kernel/time/itimer.c:305:			    current->comm);
linux-4.15.18+/kernel/time/alarmtimer.c:727:	restart = &current->restart_block;
linux-4.15.18+/kernel/time/alarmtimer.c:773:	struct restart_block *restart = &current->restart_block;
linux-4.15.18+/kernel/time/hrtimer.c:1490:	restart = &current->restart_block;
linux-4.15.18+/kernel/time/hrtimer.c:1526:	slack = current->timer_slack_ns;
linux-4.15.18+/kernel/time/hrtimer.c:1542:	restart = &current->restart_block;
linux-4.15.18+/kernel/time/hrtimer.c:1562:	current->restart_block.nanosleep.type = rmtp ? TT_NATIVE : TT_NONE;
linux-4.15.18+/kernel/time/hrtimer.c:1563:	current->restart_block.nanosleep.rmtp = rmtp;
linux-4.15.18+/kernel/time/hrtimer.c:1580:	current->restart_block.nanosleep.type = rmtp ? TT_COMPAT : TT_NONE;
linux-4.15.18+/kernel/time/hrtimer.c:1581:	current->restart_block.nanosleep.compat_rmtp = rmtp;
linux-4.15.18+/kernel/time/timer.c:1783:			current->state = TASK_RUNNING;
linux-4.15.18+/kernel/context_tracking.c:64:	WARN_ON_ONCE(!current->mm);
linux-4.15.18+/kernel/sysctl_binary.c:1249:			struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/kernel/sysctl_binary.c:1363:			"system call with ", current->comm);
linux-4.15.18+/kernel/exec_domain.c:53:	unsigned int old = current->personality;
linux-4.15.18+/kernel/softirq.c:116:	 * is set and before current->softirq_enabled is cleared.
linux-4.15.18+/kernel/softirq.c:130:		current->preempt_disable_ip = get_lock_parent_ip();
linux-4.15.18+/kernel/softirq.c:245:	unsigned long old_flags = current->flags;
linux-4.15.18+/kernel/softirq.c:257:	current->flags &= ~PF_MEMALLOC;
linux-4.15.18+/kernel/auditsc.c:1017:	const char __user *p = (const char __user *)current->mm->arg_start;
linux-4.15.18+/kernel/auditsc.c:1605:	context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:1636:	context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:1718:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:1741:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:1757:		get_fs_pwd(current->fs, &context->pwd);
linux-4.15.18+/kernel/auditsc.c:1769:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:1868:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2087:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2111:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2135:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2154:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2167:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2187:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2198:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2213:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2231:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2245:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2261:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2350:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2390:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2401:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2409:	struct audit_context *context = current->audit_context;
linux-4.15.18+/kernel/auditsc.c:2418:	audit_log(current->audit_context, GFP_KERNEL,
linux-4.15.18+/kernel/auditsc.c:2427:	char comm[sizeof(current->comm)];
linux-4.15.18+/kernel/auditsc.c:2441:	audit_log_d_path_exe(ab, current->mm);
linux-4.15.18+/kernel/auditsc.c:2485:	struct audit_context *ctx = current->audit_context;
linux-4.15.18+/kernel/debug/gdbstub.c:746:		ks->threadid = shadow_pid(current->pid);
linux-4.15.18+/kernel/debug/gdbstub.c:964:		int_to_threadref(thref, shadow_pid(current->pid));
linux-4.15.18+/kernel/debug/debug_core.c:232:	if (current->mm) {
linux-4.15.18+/kernel/debug/debug_core.c:236:			if (!current->vmacache.vmas[i])
linux-4.15.18+/kernel/debug/debug_core.c:238:			flush_cache_range(current->vmacache.vmas[i],
linux-4.15.18+/kernel/watchdog.c:421:			current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/debug/kdb/kdb_main.c:1186:			   kdb_current, kdb_current ? kdb_current->pid : 0);
linux-4.15.18+/kernel/debug/kdb/kdb_main.c:1202:				   kdb_current, kdb_current->pid);
linux-4.15.18+/kernel/futex.c:494: * offset_within_page).  For private mappings, it's (uaddr, current->mm).
linux-4.15.18+/kernel/futex.c:503:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/futex.c:726:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/futex.c:787:	if (likely(current->pi_state_cache))
linux-4.15.18+/kernel/futex.c:801:	current->pi_state_cache = pi_state;
linux-4.15.18+/kernel/futex.c:808:	struct futex_pi_state *pi_state = current->pi_state_cache;
linux-4.15.18+/kernel/futex.c:811:	current->pi_state_cache = NULL;
linux-4.15.18+/kernel/futex.c:851:	if (current->pi_state_cache) {
linux-4.15.18+/kernel/futex.c:861:		current->pi_state_cache = pi_state;
linux-4.15.18+/kernel/futex.c:1591:			char comm[sizeof(current->comm)];
linux-4.15.18+/kernel/futex.c:2202:	prio = min(current->normal_prio, MAX_RT_PRIO);
linux-4.15.18+/kernel/futex.c:2650:					     current->timer_slack_ns);
linux-4.15.18+/kernel/futex.c:2685:	restart = &current->restart_block;
linux-4.15.18+/kernel/futex.c:3151:					     current->timer_slack_ns);
linux-4.15.18+/kernel/futex.c:3327:	current->robust_list = head;
linux-4.15.18+/kernel/seccomp.c:54: * with current->seccomp.filter, the most recently attached or inherited filter.
linux-4.15.18+/kernel/seccomp.c:193:			READ_ONCE(current->seccomp.filter);
linux-4.15.18+/kernel/seccomp.c:222:	assert_spin_locked(&current->sighand->siglock);
linux-4.15.18+/kernel/seccomp.c:224:	if (current->seccomp.mode && current->seccomp.mode != seccomp_mode)
linux-4.15.18+/kernel/seccomp.c:271:	BUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));
linux-4.15.18+/kernel/seccomp.c:272:	assert_spin_locked(&current->sighand->siglock);
linux-4.15.18+/kernel/seccomp.c:312:	BUG_ON(!mutex_is_locked(&current->signal->cred_guard_mutex));
linux-4.15.18+/kernel/seccomp.c:313:	assert_spin_locked(&current->sighand->siglock);
linux-4.15.18+/kernel/seccomp.c:431: * Caller must be holding current->sighand->siglock lock.
linux-4.15.18+/kernel/seccomp.c:441:	assert_spin_locked(&current->sighand->siglock);
linux-4.15.18+/kernel/seccomp.c:445:	for (walker = current->seccomp.filter; walker; walker = walker->prev)
linux-4.15.18+/kernel/seccomp.c:467:	filter->prev = current->seccomp.filter;
linux-4.15.18+/kernel/seccomp.c:468:	current->seccomp.filter = filter;
linux-4.15.18+/kernel/seccomp.c:633:	int mode = current->seccomp.mode;
linux-4.15.18+/kernel/seccomp.c:636:	    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))
linux-4.15.18+/kernel/seccomp.c:774:	int mode = current->seccomp.mode;
linux-4.15.18+/kernel/seccomp.c:778:	    unlikely(current->ptrace & PT_SUSPEND_SECCOMP))
linux-4.15.18+/kernel/seccomp.c:798:	return current->seccomp.mode;
linux-4.15.18+/kernel/seccomp.c:804: * Once current->seccomp.mode is non-zero, it may not be changed.
linux-4.15.18+/kernel/seccomp.c:813:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/seccomp.c:825:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/seccomp.c:840: * Once current->seccomp.mode is non-zero, it may not be changed.
linux-4.15.18+/kernel/seccomp.c:865:	    mutex_lock_killable(&current->signal->cred_guard_mutex))
linux-4.15.18+/kernel/seccomp.c:868:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/seccomp.c:881:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/seccomp.c:883:		mutex_unlock(&current->signal->cred_guard_mutex);
linux-4.15.18+/kernel/seccomp.c:947: * prctl_set_seccomp: configures current->seccomp.mode
linux-4.15.18+/kernel/seccomp.c:990:	    current->seccomp.mode != SECCOMP_MODE_DISABLED) {
linux-4.15.18+/kernel/livepatch/transition.c:607:	child->patch_state = current->patch_state;
linux-4.15.18+/kernel/bpf/offload.c:29:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/kernel/bpf/devmap.c:321:	struct net *net = current->nsproxy->net_ns;
linux-4.15.18+/kernel/events/callchain.c:225:			if  (current->mm)
linux-4.15.18+/kernel/events/uprobes.c:1180:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/events/uprobes.c:1227:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/events/uprobes.c:1388:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/kernel/events/uprobes.c:1438:	if (!current->utask)
linux-4.15.18+/kernel/events/uprobes.c:1439:		current->utask = kzalloc(sizeof(struct uprobe_task), GFP_KERNEL);
linux-4.15.18+/kernel/events/uprobes.c:1440:	return current->utask;
linux-4.15.18+/kernel/events/uprobes.c:1474:			current->comm, current->pid, msg);
linux-4.15.18+/kernel/events/uprobes.c:1479:	if (current->flags & PF_EXITING)
linux-4.15.18+/kernel/events/uprobes.c:1482:	if (!__create_xol_area(current->utask->dup_xol_addr) &&
linux-4.15.18+/kernel/events/uprobes.c:1492:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/kernel/events/uprobes.c:1493:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/events/uprobes.c:1531:	area = current->mm->uprobes_state.xol_area;
linux-4.15.18+/kernel/events/uprobes.c:1569:				current->pid, current->tgid);
linux-4.15.18+/kernel/events/uprobes.c:1716:	 * will not be accounted to the task.  'mm' *is* current->mm,
linux-4.15.18+/kernel/events/uprobes.c:1734:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/events/uprobes.c:1788:		unapply_uprobe(uprobe, current->mm);
linux-4.15.18+/kernel/events/uprobes.c:1825:	utask = current->utask;
linux-4.15.18+/kernel/events/uprobes.c:1959:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/events/uprobes.c:1961:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/events/uprobes.c:1986:	utask = current->utask;
linux-4.15.18+/kernel/events/uprobes.c:1999:	if (!current->mm)
linux-4.15.18+/kernel/events/uprobes.c:2002:	if (!test_bit(MMF_HAS_UPROBES, &current->mm->flags) &&
linux-4.15.18+/kernel/events/uprobes.c:2003:	    (!current->utask || !current->utask->return_instances))
linux-4.15.18+/kernel/events/uprobes.c:2016:	struct uprobe_task *utask = current->utask;
linux-4.15.18+/kernel/events/uprobes.c:2018:	if (!current->mm || !utask || !utask->active_uprobe)
linux-4.15.18+/kernel/events/core.c:3449:	ctx = current->perf_event_ctxp[ctxn];
linux-4.15.18+/kernel/events/core.c:4790:	mutex_lock(&current->perf_event_mutex);
linux-4.15.18+/kernel/events/core.c:4791:	list_for_each_entry(event, &current->perf_event_list, owner_entry) {
linux-4.15.18+/kernel/events/core.c:4796:	mutex_unlock(&current->perf_event_mutex);
linux-4.15.18+/kernel/events/core.c:4806:	mutex_lock(&current->perf_event_mutex);
linux-4.15.18+/kernel/events/core.c:4807:	list_for_each_entry(event, &current->perf_event_list, owner_entry) {
linux-4.15.18+/kernel/events/core.c:4812:	mutex_unlock(&current->perf_event_mutex);
linux-4.15.18+/kernel/events/core.c:5513:	} else if (current->mm) {
linux-4.15.18+/kernel/events/core.c:5986:		if ((current->mm != NULL) &&
linux-4.15.18+/kernel/events/core.c:6283:		ctx = rcu_dereference(current->perf_event_ctxp[ctxn]);
linux-4.15.18+/kernel/events/core.c:6331:		ctx = current->perf_event_ctxp[ctxn];
linux-4.15.18+/kernel/events/core.c:7036:		ctx = rcu_dereference(current->perf_event_ctxp[ctxn]);
linux-4.15.18+/kernel/events/core.c:10257:	mutex_lock(&current->perf_event_mutex);
linux-4.15.18+/kernel/events/core.c:10258:	list_add_tail(&event->owner_entry, &current->perf_event_list);
linux-4.15.18+/kernel/events/core.c:10259:	mutex_unlock(&current->perf_event_mutex);
linux-4.15.18+/kernel/irq/manage.c:918:	if (WARN_ON_ONCE(!(current->flags & PF_EXITING)))
linux-4.15.18+/kernel/pid_namespace.c:278:		current->signal->group_exit_code = pid_ns->reboot;
linux-4.15.18+/kernel/futex_compat.c:131:	current->compat_robust_list = head;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:131:	if (!current->ret_stack)
linux-4.15.18+/kernel/trace/trace_functions_graph.c:141:	if (current->curr_ret_stack == FTRACE_RETFUNC_DEPTH - 1) {
linux-4.15.18+/kernel/trace/trace_functions_graph.c:142:		atomic_inc(&current->trace_overrun);
linux-4.15.18+/kernel/trace/trace_functions_graph.c:162:	if (current->curr_ret_stack < -1)
linux-4.15.18+/kernel/trace/trace_functions_graph.c:167:	index = ++current->curr_ret_stack;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:169:		current->curr_ret_stack -= FTRACE_NOTRACE_DEPTH;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:171:	current->ret_stack[index].ret = ret;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:172:	current->ret_stack[index].func = func;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:173:	current->ret_stack[index].calltime = calltime;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:175:	current->ret_stack[index].fp = frame_pointer;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:178:	current->ret_stack[index].retp = retp;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:180:	*depth = current->curr_ret_stack;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:192:	index = current->curr_ret_stack;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:227:	if (unlikely(current->ret_stack[index].fp != frame_pointer)) {
linux-4.15.18+/kernel/trace/trace_functions_graph.c:231:		     current->ret_stack[index].fp,
linux-4.15.18+/kernel/trace/trace_functions_graph.c:233:		     (void *)current->ret_stack[index].func,
linux-4.15.18+/kernel/trace/trace_functions_graph.c:234:		     current->ret_stack[index].ret);
linux-4.15.18+/kernel/trace/trace_functions_graph.c:240:	*ret = current->ret_stack[index].ret;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:241:	trace->func = current->ret_stack[index].func;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:242:	trace->calltime = current->ret_stack[index].calltime;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:243:	trace->overrun = atomic_read(&current->trace_overrun);
linux-4.15.18+/kernel/trace/trace_functions_graph.c:259:	current->curr_ret_stack--;
linux-4.15.18+/kernel/trace/trace_functions_graph.c:265:	if (current->curr_ret_stack < -1) {
linux-4.15.18+/kernel/trace/trace_functions_graph.c:266:		current->curr_ret_stack += FTRACE_NOTRACE_DEPTH;
linux-4.15.18+/kernel/trace/trace_events_filter.c:308:	cmp = pred->regex.match(current->comm, &pred->regex,
linux-4.15.18+/kernel/trace/trace.c:2765:	entry->tgid		= current->tgid;
linux-4.15.18+/kernel/trace/trace_hwlat.c:282:	if (!cpumask_equal(current_mask, &current->cpus_allowed))
linux-4.15.18+/kernel/trace/trace_probe.c:236:	ret = strlcpy(dst, current->comm, maxlen);
linux-4.15.18+/kernel/trace/trace_probe.c:244:	*(u32 *)dest = strlen(current->comm) + 1;
linux-4.15.18+/kernel/trace/bpf_trace.c:112:		     current->flags & (PF_KTHREAD | PF_EXITING)))
linux-4.15.18+/kernel/trace/bpf_trace.c:134:			    current->comm, task_pid_nr(current));
linux-4.15.18+/kernel/trace/trace_uprobe.c:182:	udd = (void *) current->utask->vaddr;
linux-4.15.18+/kernel/trace/trace_uprobe.c:1071:		 * uprobe_apply(). current->mm must be probed and we can rely
linux-4.15.18+/kernel/trace/trace_uprobe.c:1167:	if (!uprobe_perf_filter(&tu->consumer, 0, current->mm))
linux-4.15.18+/kernel/trace/trace_uprobe.c:1234:	current->utask->vaddr = (unsigned long) &udd;
linux-4.15.18+/kernel/trace/trace_uprobe.c:1269:	current->utask->vaddr = (unsigned long) &udd;
linux-4.15.18+/kernel/trace/ftrace.c:864:	if (!current->ret_stack)
linux-4.15.18+/kernel/trace/ftrace.c:868:		current->ret_stack[index].subtime = 0;
linux-4.15.18+/kernel/trace/ftrace.c:898:			current->ret_stack[index - 1].subtime += calltime;
linux-4.15.18+/kernel/trace/ftrace.c:900:		if (current->ret_stack[index].subtime < calltime)
linux-4.15.18+/kernel/trace/ftrace.c:901:			calltime -= current->ret_stack[index].subtime;
linux-4.15.18+/kernel/trace/trace_sched_wakeup.c:558:	    (!dl_task(p) && (p->prio >= wakeup_prio || p->prio >= current->prio)))
linux-4.15.18+/kernel/trace/trace.h:543:	unsigned int val = current->trace_recursion;
linux-4.15.18+/kernel/trace/trace.h:555:	current->trace_recursion = val;
linux-4.15.18+/kernel/trace/trace.h:563:	unsigned int val = current->trace_recursion;
linux-4.15.18+/kernel/trace/trace.h:572:	current->trace_recursion = val;
linux-4.15.18+/kernel/trace/trace_branch.c:43:	if (current->trace_recursion & TRACE_BRANCH_BIT)
linux-4.15.18+/kernel/trace/trace_branch.c:57:	current->trace_recursion |= TRACE_BRANCH_BIT;
linux-4.15.18+/kernel/trace/trace_branch.c:89:	current->trace_recursion &= ~TRACE_BRANCH_BIT;
linux-4.15.18+/kernel/reboot.c:227:	current->flags |= PF_NO_SETAFFINITY;
linux-4.15.18+/kernel/sys.c:452:		current->flags |= PF_NPROC_EXCEEDED;
linux-4.15.18+/kernel/sys.c:454:		current->flags &= ~PF_NPROC_EXCEEDED;
linux-4.15.18+/kernel/sys.c:842: * This is SMP safe as current->tgid does not change.
linux-4.15.18+/kernel/sys.c:866:	pid = task_tgid_vnr(rcu_dereference(current->real_parent));
linux-4.15.18+/kernel/sys.c:901:	cutime = current->signal->cutime;
linux-4.15.18+/kernel/sys.c:902:	cstime = current->signal->cstime;
linux-4.15.18+/kernel/sys.c:962:	struct task_struct *group_leader = current->group_leader;
linux-4.15.18+/kernel/sys.c:1097:	struct task_struct *curr = current->group_leader;
linux-4.15.18+/kernel/sys.c:1108:	struct task_struct *group_leader = current->group_leader;
linux-4.15.18+/kernel/sys.c:1143:	(personality(current->personality) == PER_LINUX32 && \
linux-4.15.18+/kernel/sys.c:1159:	if (current->personality & UNAME26) {
linux-4.15.18+/kernel/sys.c:1260:	if (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
linux-4.15.18+/kernel/sys.c:1311:	if (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
linux-4.15.18+/kernel/sys.c:1402:	task_lock(current->group_leader);
linux-4.15.18+/kernel/sys.c:1403:	x = current->signal->rlim[resource];
linux-4.15.18+/kernel/sys.c:1404:	task_unlock(current->group_leader);
linux-4.15.18+/kernel/sys.c:1421:	task_lock(current->group_leader);
linux-4.15.18+/kernel/sys.c:1422:	r = current->signal->rlim[resource];
linux-4.15.18+/kernel/sys.c:1423:	task_unlock(current->group_leader);
linux-4.15.18+/kernel/sys.c:1762:	mask = xchg(&current->fs->umask, mask & S_IRWXUGO);
linux-4.15.18+/kernel/sys.c:1835:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/sys.c:1924:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/sys.c:2037:	struct mm_struct *mm = current->mm;
linux-4.15.18+/kernel/sys.c:2290:		if (current->timer_slack_ns > ULONG_MAX)
linux-4.15.18+/kernel/sys.c:2293:			error = current->timer_slack_ns;
linux-4.15.18+/kernel/sys.c:2297:			current->timer_slack_ns =
linux-4.15.18+/kernel/sys.c:2298:					current->default_timer_slack_ns;
linux-4.15.18+/kernel/sys.c:2300:			current->timer_slack_ns = arg2;
linux-4.15.18+/kernel/sys.c:2309:			current->flags &= ~PF_MCE_PROCESS;
linux-4.15.18+/kernel/sys.c:2312:			current->flags |= PF_MCE_PROCESS;
linux-4.15.18+/kernel/sys.c:2314:				current->flags |= PF_MCE_EARLY;
linux-4.15.18+/kernel/sys.c:2316:				current->flags &= ~PF_MCE_EARLY;
linux-4.15.18+/kernel/sys.c:2318:				current->flags &=
linux-4.15.18+/kernel/sys.c:2330:		if (current->flags & PF_MCE_PROCESS)
linux-4.15.18+/kernel/sys.c:2331:			error = (current->flags & PF_MCE_EARLY) ?
linux-4.15.18+/kernel/kexec_core.c:1063:	prstatus.pr_pid = current->pid;
linux-4.15.18+/kernel/rcu/tree.c:786:			  current->pid, current->comm,
linux-4.15.18+/kernel/rcu/tree.c:948:			  current->pid, current->comm,
linux-4.15.18+/kernel/rcu/tree_plugin.h:307:		current->rcu_read_unlock_special.b.need_qs = false;
linux-4.15.18+/kernel/rcu/tree_plugin.h:796:	if (likely(list_empty(&current->rcu_node_entry)))
linux-4.15.18+/kernel/rcu/tree_plugin.h:2599:	WRITE_ONCE(current->rcu_tasks_idle_cpu, smp_processor_id());
linux-4.15.18+/kernel/rcu/tree_plugin.h:2607:	WRITE_ONCE(current->rcu_tasks_idle_cpu, -1);
linux-4.15.18+/kernel/rcu/update.c:238:	current->rcu_read_lock_nesting++;
linux-4.15.18+/kernel/rcu/update.c:301:	       current->lockdep_recursion == 0;
linux-4.15.18+/kernel/rcu/update.c:872:	current->rcu_tasks_idx = __srcu_read_lock(&tasks_rcu_exit_srcu);
linux-4.15.18+/kernel/rcu/update.c:880:	__srcu_read_unlock(&tasks_rcu_exit_srcu, current->rcu_tasks_idx);
linux-4.15.18+/kernel/async.c:195:	current->flags |= PF_USED_ASYNC;
linux-4.15.18+/kernel/panic.c:530:			raw_smp_processor_id(), current->pid, file, line,
linux-4.15.18+/kernel/panic.c:534:			raw_smp_processor_id(), current->pid, caller);
linux-4.15.18+/kernel/panic.c:655:		current->comm, task_pid_nr(current),
linux-4.15.18+/kernel/umh.c:69:	spin_lock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/umh.c:71:	spin_unlock_irq(&current->sighand->siglock);
linux-4.15.18+/kernel/umh.c:180:		 * want to pollute current->children, and we need a parent
linux-4.15.18+/kernel/freezer.c:64:	long save = current->state;
linux-4.15.18+/kernel/freezer.c:66:	pr_debug("%s entered refrigerator\n", current->comm);
linux-4.15.18+/kernel/freezer.c:72:		current->flags |= PF_FROZEN;
linux-4.15.18+/kernel/freezer.c:75:			current->flags &= ~PF_FROZEN;
linux-4.15.18+/kernel/freezer.c:78:		if (!(current->flags & PF_FROZEN))
linux-4.15.18+/kernel/freezer.c:84:	pr_debug("%s left refrigerator\n", current->comm);
linux-4.15.18+/kernel/freezer.c:174:	current->flags &= ~PF_NOFREEZE;
linux-4.15.18+/kernel/capability.c:48:	char name[sizeof(current->comm)];
linux-4.15.18+/kernel/capability.c:72:	char name[sizeof(current->comm)];
linux-4.15.18+/kernel/capability.c:378:		current->flags |= PF_SUPERPRIV;
linux-4.15.18+/kernel/cred.c:26:	       current->comm, current->pid, ##__VA_ARGS__)
linux-4.15.18+/kernel/cred.c:32:			  current->comm, current->pid, ##__VA_ARGS__);	\
linux-4.15.18+/kernel/cred.c:147:	BUG_ON(cred == current->cred);
linux-4.15.18+/kernel/cred.c:148:	BUG_ON(cred == current->real_cred);
linux-4.15.18+/kernel/cred.c:523:	const struct cred *old = current->cred;
linux-4.15.18+/kernel/cred.c:533:	rcu_assign_pointer(current->cred, new);
linux-4.15.18+/kernel/cred.c:552:	const struct cred *override = current->cred;
linux-4.15.18+/kernel/cred.c:561:	rcu_assign_pointer(current->cred, old);
linux-4.15.18+/kernel/cred.c:593: * Does not take, and does not return holding current->cred_replace_mutex.
qemu-utils/guest-files/test-list-9-3-15:166:concurrent-tree-lkr-remove-all
qemu-utils/guest-files/test-list-9-3-15:167:concurrent-tree-lkr-insert-remove
qemu-utils/guest-files/test-list-9-3-15:168:concurrent-tree-lkr-acquire-release
qemu-utils/guest-files/test-list-9-3-15:169:concurrent-tree-lkr-insert-serial-large
ftfs/toku_run_test.c:816:	{"concurrent-tree-lkr-remove-all",
ftfs/toku_run_test.c:818:	{ "concurrent-tree-lkr-insert-remove",
ftfs/toku_run_test.c:820:	{ "concurrent-tree-lkr-acquire-release",
ftfs/toku_run_test.c:822:	{ "concurrent-tree-lkr-insert-serial-large",
ftfs/ftfs_southbound.c:102:	struct fs_struct *current_fs = current->fs;
ftfs/toku_linkage.c:151:pid_t getpid(void) { return current->pid; }
ftfs/ftfs_dir.c:162:	//pwd = current->fs->pwd;
ftfs/userspace-testing/all.tests:166:concurrent-tree-lkr-remove-all
ftfs/userspace-testing/all.tests:167:concurrent-tree-lkr-insert-remove
ftfs/userspace-testing/all.tests:168:concurrent-tree-lkr-acquire-release
ftfs/userspace-testing/all.tests:169:concurrent-tree-lkr-insert-serial-large
ftfs/toku_misc.c:134:         down_read(&current->mm->mmap_sem);
ftfs/toku_misc.c:136:         up_read(&current->mm->mmap_sem);
ft/block_table.cc:1193:    for (i = 0; i < current->length_of_array; i++) {
ft/block_table.cc:1194:        struct block_translation_pair *pair = &current->block_translation[i];
ft/block_table.cc:1204:            !(i < current->length_of_array &&
ft/block_table.cc:1205:                current->block_translation[i].size > 0 &&
ft/block_table.cc:1206:                current->block_translation[i].u.diskoff == pair->u.diskoff)
ft/block_table.cc:1216:            !(i < current->length_of_array &&
ft/block_table.cc:1217:                current->block_translation[i].size > 0 &&
ft/block_table.cc:1218:                current->block_translation[i].u.diskoff == pair->u.diskoff) &&
ft/block_table.cc:1236:    s->num_blocks_allocated = current->length_of_array;
ft/block_table.cc:1241:    for (int64_t i = 0; i < current->length_of_array; ++i) {
ft/block_table.cc:1242:        struct block_translation_pair *block = &current->block_translation[i];
ft/cachetable.cc:4477:    	printf("below hsh. evictor:: client thread is going to wake up. %" PRIu64 " elapsed\n", current-cachetable_create_time);
locktree/locktree.h:471:    // Prevent concurrent-transaction workloads from trying the optimization
locktree/locktree.h:474:    // system is in a concurrent-transaction state.
locktree/locktree.h:483:    // do the optimization in a concurrent-transaction system. Similarly, it
